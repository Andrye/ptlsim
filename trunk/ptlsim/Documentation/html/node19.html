<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<!--Converted with LaTeX2HTML 2002-2-1 (1.70)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Branch Prediction</TITLE>
<META NAME="description" CONTENT="Branch Prediction">
<META NAME="keywords" CONTENT="PTLsimManual">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<META NAME="Generator" CONTENT="LaTeX2HTML v2002-2-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="PTLsimManual.css">

<LINK REL="previous" HREF="node18.html">
<LINK REL="up" HREF="node8.html">
<LINK REL="next" HREF="node20.html">
</HEAD>

<BODY >
<!--Navigation Panel-->
<A NAME="tex2html628"
  HREF="node20.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html624"
  HREF="node8.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html620"
  HREF="node18.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html626"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html629"
  HREF="node20.html">Appendices</A>
<B> Up:</B> <A NAME="tex2html625"
  HREF="node8.html">Out of Order Processor</A>
<B> Previous:</B> <A NAME="tex2html621"
  HREF="node18.html">Cache Hierarchy</A>
 &nbsp; <B>  <A NAME="tex2html627"
  HREF="node1.html">Contents</A></B> 
<BR>
<BR>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL>
<LI><A NAME="tex2html630"
  HREF="node19.html#SECTION031110000000000000000">Introduction</A>
<LI><A NAME="tex2html631"
  HREF="node19.html#SECTION031120000000000000000">Conditional Branch Predictor</A>
<LI><A NAME="tex2html632"
  HREF="node19.html#SECTION031130000000000000000">Branch Target Buffer</A>
<LI><A NAME="tex2html633"
  HREF="node19.html#SECTION031140000000000000000">Return Address Stack</A>
</UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION031100000000000000000">
Branch Prediction</A>
</H1>

<P>

<H1><A NAME="SECTION031110000000000000000">
Introduction</A>
</H1>

<P>
PTLsim provides a variety of branch predictors in <TT><FONT SIZE="-1">branchpred.cpp</FONT></TT>.
The branch prediction subsystem is relatively independent of the core
simulator and can be treated as a black box, so long as it implements
the interfaces in <TT><FONT SIZE="-1">branchpred.h</FONT></TT>.

<P>
The branch prediction subsystem always contains at least three distinct
predictors for the three main classes of branches:

<P>

<UL>
<LI><I>Conditional Branch Predictor</I> returns a boolean (taken or not
taken) for each conditional branch (<TT><FONT SIZE="-1">br.cc</FONT></TT> uop)
</LI>
<LI><I>Branch Target Buffer</I> (BTB) predicts indirect branch (<TT><FONT SIZE="-1">jmp</FONT></TT>
uop) targets
</LI>
<LI><I>Return Address Stack</I> (RAS) predicts return instructions (i.e.
specially marked indirect <TT><FONT SIZE="-1">jmp</FONT></TT> uops) based on prior
calls
</LI>
<LI>Unconditional branches (<TT><FONT SIZE="-1">bru</FONT></TT>) are never predicted since
their destination is explicitly encoded.
</LI>
</UL>
All these predictors are accessed by the core through the <TT><FONT SIZE="-1">BranchPredictorInterface</FONT></TT>
object. Based on the opcode and other uop information, the core determines
the type flags of each branch uop:

<P>

<UL>
<LI><TT><FONT SIZE="-1">BRANCH_HINT_UNCOND</FONT></TT> for unconditional branches. These
are never predicted since the destination is implied.
</LI>
<LI><TT><FONT SIZE="-1">BRANCH_HINT_COND</FONT></TT> for conditional branches.
</LI>
<LI><TT><FONT SIZE="-1">BRANCH_HINT_INDIRECT</FONT></TT> for indirect branches, including
returns.
</LI>
<LI><TT><FONT SIZE="-1">BRANCH_HINT_CALL</FONT></TT> for calls (both direct and indirect).
This implies that the return address of the call should be a should
be pushed on the RAS.
</LI>
<LI><TT><FONT SIZE="-1">BRANCH_HINT_RET</FONT></TT> for returns (indirect branches).
This implies that the return address should be taken from the top
RAS stack entry, not the BTB.
</LI>
</UL>
Multiple flags may be present for each uop (for instance, <TT><FONT SIZE="-1">BRANCH_HINT_RET</FONT></TT>
and <TT><FONT SIZE="-1">BRANCH_HINT_INDIRECT</FONT></TT> are both used for the <TT><FONT SIZE="-1">jmp</FONT></TT>
uop terminating an x86 <TT><FONT SIZE="-1">ret</FONT></TT> instruction).

<P>
To make a prediction at fetch time, the core calls the <TT><FONT SIZE="-1">BranchPredictorInterface::predict()</FONT></TT>
method, passing it a <TT><FONT SIZE="-1">PredictorUpdate</FONT></TT> structure. This
structure is carried along with each uop until it retires, and contains
all the information needed to eventually update the branch predictor
at the end of the pipeline. The contents will vary depending on the
predictor chosen, but in general this structure contains pointers
into internal predictor counter tables and various flags. The <TT><FONT SIZE="-1">predict()</FONT></TT>
method fills in this structure.

<P>
As each uop commits, the <TT><FONT SIZE="-1">BranchPredictorInterface::update()</FONT></TT>
method is passed the uop's saved <TT><FONT SIZE="-1">PredictorUpdate</FONT></TT> structure
and the branch outcome (expected target RIP versus real target RIP)
so the branch predictor can be updated. In PTLsim, predictor updates
only occur at retirement to avoid corruption caused by speculative
instructions.

<P>

<H1><A NAME="SECTION031120000000000000000">
Conditional Branch Predictor</A>
</H1>

<P>
The PTLsim conditional branch predictor is the most flexible predictor,
since it can be easily replaced. The default predictor implemented
in <TT><FONT SIZE="-1">branchpred.cpp</FONT></TT> is a selection based predictor.
In essence, two separate predictors are maintained. The <I>history
predictor</I> hashes a shift register of previously predicted branches
into a table slot; this slot returns whether or not the branch with
that history is predicted as taken. PTLsim supports various combinations
of the history and branch address to provide <I>gshare</I> based semantics.
The <I>bimodal predictor</I> is simpler; it uses 2-bit saturating
counters to predict if a given branch is likely to be taken. Finally,
a <I>selection predictor</I> specifies which of the two predictors
is more accurate and should be used for future predictions. This style
of predictor, sometimes called a <I>McFarling predictor</I>, has been
described extensively in the literature and variations are used by
most modern processors.

<P>
Through the <TT><FONT SIZE="-1">CombinedPredictor</FONT></TT> template class, the
user can specify the sizes of all the tables (history, bimodal, selector),
the history depth, the method in which the global history and branch
address are combined and so on. Alternatively, the conditional branch
predictor can be replaced with something entirely different if desired.

<P>

<H1><A NAME="SECTION031130000000000000000">
Branch Target Buffer</A>
</H1>

<P>
The Branch Target Buffer (BTB) is essentially a small cache that maps
indirect branch RIP addresses (i.e., <TT><FONT SIZE="-1">jmp</FONT></TT> uops) into
predicted target RIP addresses. It is set associative, with a user
configurable number of sets and ways. In PTLsim, the BTB does not
take into account any indirect branch history information. The BTB
is a nearly universal structure in branch prediction; see the literature
for more information.

<P>

<H1><A NAME="SECTION031140000000000000000">
Return Address Stack</A>
</H1>

<P>
The Return Address Stack (RAS) predicts the target address of indirect
jumps marked with the <TT><FONT SIZE="-1">BRANCH_HINT_RET</FONT></TT> flag. Whenever
the <TT><FONT SIZE="-1">BRANCH_HINT_RET</FONT></TT> flag is passed to the predict()
method, the top RAS stack entry is returned as the predicted target,
overriding anything in the BTB.

<P>
Unlike the conditional branch predictor and BTB, the RAS updated speculatively
in the frontend pipeline, before the outcome of calls and returns
are known. This allows better performance when closely spaced calls
and returns must be predicted as they are fetched, before either the
call or corresponding return have actually executed. However, when
called with the <TT><FONT SIZE="-1">BRANCH_HINT_RET</FONT></TT> flag, the <TT><FONT SIZE="-1">predict()</FONT></TT>
method only returns the RIP at the top of the RAS, but does not push
or pop the RAS. This must be done after the corresponding <TT><FONT SIZE="-1">bru</FONT></TT>
or <TT><FONT SIZE="-1">jmp</FONT></TT> (for direct and&nbsp;or indirect calls, respectively)
or <TT><FONT SIZE="-1">jmp</FONT></TT> (for returns) uop is actually allocated in
the ROB. 

<P>
This approach is required since the RAS is speculatively updated:
if uops must be annulled (because of branch mispredictions or mis-speculations),
the annulment occurs by walking backwards in the ROB until the excepting
uop is encountered. However, if the RAS were updated during the fetch
stage, some uops may not be in the ROB yet and hence the rollback
logic cannot undo speculative changes made to the RAS by these uops.
This causes the RAS to get out of alignment and performance suffers.

<P>
To solve this problem, the RAS is only updated in the allocate stage
immediately after fetch. In the out of order core's <TT><FONT SIZE="-1">rename()</FONT></TT>
function, the <TT><FONT SIZE="-1">BranchPredictorInterface::updateras()</FONT></TT>
method is called to either push or pop an entry from the RAS (calls
push entries, returns pop entries). Unlike the conditional branch
predictor and BTB, this is the only place the RAS is updated, rather
than performing updates at commit time.

<P>
If uops must be annulled, the <TT><FONT SIZE="-1">ReorderBufferEntry::annul()</FONT></TT>
method calls the <TT><FONT SIZE="-1">BranchPredictorInterface::annulras()</FONT></TT>
method with the <TT><FONT SIZE="-1">PredictorUpdate</FONT></TT> structure for each
uop it encounters in reverse program order. This method effectively
undoes whatever change was made to the RAS when the <TT><FONT SIZE="-1">updateras()</FONT></TT>
method was called with the same <TT><FONT SIZE="-1">PredictorUpdate</FONT></TT> information
during renaming and allocation. This is possible because <TT><FONT SIZE="-1">updateras()</FONT></TT>
saves checkpoint information (namely, the old RAS top of stack and
the value at that stack slot) before updating the RAS; this allows
the RAS state to be rolled backwards in time as uops are annulled
in reverse program order. At the end of the annulment process when
fetching is restarted at the correct RIP, the RAS state should be
identical to the state that existed before the last uop to be annulled
was originally fetched.

<P>
<HR>
<!--Navigation Panel-->
<A NAME="tex2html628"
  HREF="node20.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html624"
  HREF="node8.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html620"
  HREF="node18.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html626"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html629"
  HREF="node20.html">Appendices</A>
<B> Up:</B> <A NAME="tex2html625"
  HREF="node8.html">Out of Order Processor</A>
<B> Previous:</B> <A NAME="tex2html621"
  HREF="node18.html">Cache Hierarchy</A>
 &nbsp; <B>  <A NAME="tex2html627"
  HREF="node1.html">Contents</A></B> 
<!--End of Navigation Panel-->
<ADDRESS>
Matt T Yourst
2005-12-02
</ADDRESS>
</BODY>
</HTML>
