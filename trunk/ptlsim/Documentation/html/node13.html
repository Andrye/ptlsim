<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<!--Converted with LaTeX2HTML 2002-2-1 (1.70)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Scheduling, Dispatch and
Issue</TITLE>
<META NAME="description" CONTENT="Scheduling, Dispatch and
Issue">
<META NAME="keywords" CONTENT="PTLsimManual">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<META NAME="Generator" CONTENT="LaTeX2HTML v2002-2-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="PTLsimManual.css">

<LINK REL="next" HREF="node14.html">
<LINK REL="previous" HREF="node12.html">
<LINK REL="up" HREF="node9.html">
<LINK REL="next" HREF="node14.html">
</HEAD>

<BODY >
<!--Navigation Panel-->
<A NAME="tex2html511"
  HREF="node14.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html507"
  HREF="node9.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html501"
  HREF="node12.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html509"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html512"
  HREF="node14.html">Speculation and Recovery</A>
<B> Up:</B> <A NAME="tex2html508"
  HREF="node9.html">Out of Order Processor</A>
<B> Previous:</B> <A NAME="tex2html502"
  HREF="node12.html">Frontend and Key Structures</A>
 &nbsp; <B>  <A NAME="tex2html510"
  HREF="node1.html">Contents</A></B> 
<BR>
<BR>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL>
<LI><A NAME="tex2html513"
  HREF="node13.html#SECTION04410000000000000000">Clustering and Issue Queue Configuration</A>
<LI><A NAME="tex2html514"
  HREF="node13.html#SECTION04420000000000000000">Cluster Selection</A>
<LI><A NAME="tex2html515"
  HREF="node13.html#SECTION04430000000000000000">Issue Queue Structure and Operation</A>
<UL>
<LI><A NAME="tex2html516"
  HREF="node13.html#SECTION04431000000000000000">Implementation</A>
<LI><A NAME="tex2html517"
  HREF="node13.html#SECTION04432000000000000000">Other Designs</A>
</UL>
<BR>
<LI><A NAME="tex2html518"
  HREF="node13.html#SECTION04440000000000000000">Issue</A>
</UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION04400000000000000000"></A><A NAME="sec:ClusterDispatchScheduleIssue"></A>
<BR>
Scheduling, Dispatch and
Issue
</H1>

<P>

<H1><A NAME="SECTION04410000000000000000"></A><A NAME="sec:Clustering"></A>
<BR>
Clustering and Issue Queue Configuration
</H1>

<P>
The PTLsim out of order model can simulate an arbitrarily complex
set of functional units grouped into <I>clusters</I>. Clusters are
specified by the <TT><FONT SIZE="-1">Cluster</FONT></TT> class and are defined by
the <TT><FONT SIZE="-1">clusters[]</FONT></TT> array in <TT><FONT SIZE="-1">ooohwdef.h</FONT></TT>.
Each Cluster element defines the name of the cluster, which functional
units belong to the cluster (<TT><FONT SIZE="-1">fu_mask</FONT></TT> field) and the
maximum number of uops that can be issued in that cluster each cycle
(<TT><FONT SIZE="-1">issue_width</FONT></TT> field)

<P>
The <TT><FONT SIZE="-1">intercluster_latency_map</FONT></TT> matrix defines the
forwarding latency, in cycles, between a given cluster and every other
cluster. If <TT><FONT SIZE="-1">intercluster_latency_map[</FONT></TT><I>A</I><TT><FONT SIZE="-1">][</FONT></TT><I>B</I><TT><FONT SIZE="-1">]</FONT></TT>
is <I>L</I> cycles, this means that functional units in cluster <I>B</I>
must wait <I>L</I> cycles after a uop <I>U</I> in cluster A completes
before cluster B's functional units can issue a uop dependent on <I>U</I>'s
result. If the latency is zero between clusters <I>A</I> and <I>B</I>,
producer and consumer uops in <I>A</I> and <I>B</I> can always be
issued back to back in subsequent cycles. Hence, the diagonal of the
forwarding latency matrix is always all zeros.

<P>
This clustering mechanism can be used to implement several features
of modern microprocessors. First, traditional clustering is possible,
in which it takes multiple additional cycles to forward results between
different clusters (for instance, one or more integer clusters and
a floating point unit). Second, several issue queues and corresponding
issue width limits can be defined within a given virtual cluster,
for instance to sort loads, stores and ALU operations into separate
issue queues with different policies. This is done by specifying an
inter-cluster latency of zero cycles between the relevant pseudo-clusters
with separate issue queues. Both of these uses are required to accurately
model most modern processors.

<P>
There is also an equivalent <TT><FONT SIZE="-1">intercluster_bandwidth_map</FONT></TT>
matrix to specify the maximum number of values that can be routed
between any two clusters each cycle.

<P>
The <TT><FONT SIZE="-1">IssueQueue</FONT></TT> template class is used to declare issue
queues; each cluster has its own issue queue. The syntax <TT><FONT SIZE="-1">IssueQueue&lt;</FONT></TT><I>size</I><TT><FONT SIZE="-1">&gt;</FONT></TT>
<TT><FONT SIZE="-1">issueq_</FONT></TT><I>name</I><TT><FONT SIZE="-1">;</FONT></TT> is used to declare
an issue queue with a specific size. In the current implementation,
the size can be from 1 to 64 slots. The macros <TT><FONT SIZE="-1">foreach_issueq()</FONT></TT>,
<TT><FONT SIZE="-1">sched_get_all_issueq_free_slots()</FONT></TT> and <TT><FONT SIZE="-1">issueq_operation_on_cluster_with_result()</FONT></TT>
macros must be modified if the cluster and issue queue configuration
is changed to reflect all available clusters; the modifications required
should be obvious from the example code. These macros with switch
statements are required instead of a simple array since the issue
queues can be of different template types and sizes.

<P>

<H1><A NAME="SECTION04420000000000000000">
Cluster Selection</A>
</H1>

<P>
The <TT><FONT SIZE="-1">ReorderBufferEntry::select_cluster()</FONT></TT> function
is responsible for routing a given uop into a specific cluster at
the time it is dispatched; uops do not switch between clusters after
this.

<P>
Various heuristics are employed to select which cluster a given uop
should be routed to. In the reference implementation provided in <TT><FONT SIZE="-1">ooocore.cpp</FONT></TT>,
a weighted score is generated for each possible cluster by scanning
through the uop's operands to determine which cluster they will be
forwarded from. If a given operand's corresponding producer uop <I>S</I>
is currently either dispatched to cluster <I>C</I> but waiting to
execute or is still on the bypass network of cluster <I>C</I>, then
cluster <I>C</I>'s score is incremented. The final cluster is selected
as the cluster with the highest score out of the set of clusters which
the uop can actually issue on (e.g. a floating point uop cannot issue
on a cluster with only integer units). This mechanism is designed
to route each uop to the cluster in which the majority of its operands
will become available at the earliest time; in practice it works quite
well and variants of this technique are often used in real processors.

<P>

<H1><A NAME="SECTION04430000000000000000"></A><A NAME="sec:Scheduling"></A>
<BR>
Issue Queue Structure and Operation
</H1>

<P>
PTLsim implements issue queues in the <TT><FONT SIZE="-1">IssueQueue</FONT></TT> template
class using the collapsing priority queue design used in most modern
processors. 

<P>
As each uop is dispatched, it is placed at the end of the issue queue
for its cluster and several associative arrays are updated to reflect
which operands the uop is still waiting for. In the IssueQueue class,
the <TT><FONT SIZE="-1">insert()</FONT></TT> method takes the ROB index of the uop
(its <I>tag</I> in issue queue terminology), the tags (ROB indices)
of its operands, and a map of which of the operands are ready versus
waiting. The ROB index is inserted into an associative array, and
the ROB index tags of any waiting operands are inserted into corresponding
slots in parallel arrays, one array per operand (in the current implementation,
up to 4 operands are tracked). If an operand was ready at dispatch
time, the slot for that operand in the corresponding array is marked
as invalid since there is no need to wake it up later. Notice that
the new slot is always at the end of the issue queue array; this is
made possible by the collapsing mechanism described below.

<P>
The issue queue maintains two bitmaps to track the state of each slot
in the queue. The <TT><FONT SIZE="-1">valid</FONT></TT> bitmap indicates which slots
are occupied by uops, while the <TT><FONT SIZE="-1">issued</FONT></TT> bitmap indicates
which of those uops have been issued. Together, these two bitmaps
form the state machine described in Table <A HREF="#table:IssueQueueStateMachine">9.1</A>.

<P>
<BR><P></P>
<DIV ALIGN="CENTER">

<P>

<P>
<DIV ALIGN="CENTER">
<A NAME="3889"></A>
<TABLE CELLPADDING=3 BORDER="1">
<CAPTION><STRONG>Table 9.1:</STRONG>
Issue Queue State Machine</CAPTION>
<TR><TD ALIGN="CENTER">Valid</TD>
<TD ALIGN="CENTER">Issued</TD>
<TD ALIGN="LEFT">Meaning
<BR>
 
<TT><FONT SIZE="-1">0</FONT></TT></TD>
</TR>
</TABLE>
</DIV>
</DIV>
<BR>

<P>
After <TT><FONT SIZE="-1">insert()</FONT></TT> is called, the slot is placed in the
dispatched state. As each uop completes, its tag (ROB index) is broadcast
using the <TT><FONT SIZE="-1">broadcast()</FONT></TT> method to one or more issue
queues accessible in that cycle. Because of clustering, some issue
queues will receive the broadcast later than others; this is discussed
below. Each slot in each of the four operand arrays is compared against
the broadcast value. If the operand tag in that slot is valid and
matches the broadcast tag, the slot (in one of the operand arrays
only, not the entire issue queue) is invalidated to indicate it is
ready and no longer waiting for further broadcasts.

<P>
Every cycle, the <TT><FONT SIZE="-1">clock()</FONT></TT> method uses the <TT><FONT SIZE="-1">valid</FONT></TT>
and <TT><FONT SIZE="-1">issued</FONT></TT> bitmaps together with the valid bitmaps
of each of the operand arrays to compute which issue queue slots in
the dispatched state are no longer waiting on any of their operands.
This bitmap of ready slots is then latched into the <TT><FONT SIZE="-1">allready</FONT></TT>
bitmap.

<P>
The <TT><FONT SIZE="-1">issue()</FONT></TT> method simply finds the index of the first
set bit in the <TT><FONT SIZE="-1">allready</FONT></TT> bitmap (this is the slot of
the oldest ready uop in program order), marks the corresponding slot
as issued, and returns the slot. The processor then selects a functional
unit for the uop in that slot and executes it via the <TT><FONT SIZE="-1">ReorderBufferEntry::issue()</FONT></TT>
method. After the uop has completed execution (i.e. it cannot possibly
be replayed), the <TT><FONT SIZE="-1">release()</FONT></TT> method is called to remove
the slot from the issue queue, freeing it up for incoming uops in
the dispatch stage. The collapsing design of the issue queue means
that the slot is not simply marked as invalid - all slots after it
are physically shifted left by one, leaving a free slot at the end
of the array. This design is relatively simple to implement in hardware
and makes determining the oldest ready to issue uop very trivial.

<P>
Because of the collapsing mechanism, it is critical to note that the
slot index returned by <TT><FONT SIZE="-1">issue()</FONT></TT> will become invalid
after the next call to the <TT><FONT SIZE="-1">remove()</FONT></TT> method; hence,
it should never be stored anywhere if a slot could be removed from
the issue queue in the meantime.

<P>
If a uop issues but determines that it cannot actually complete at
that time, it must be <I>replayed</I>. The <TT><FONT SIZE="-1">replay()</FONT></TT>
method clears the issued bit for the uop's issue queue slot, returning
it to the dispatched state. The replay mechanism can optionally add
additional dependencies such that the uop is only re-issued after
those dependencies are resolved. This is important for loads and stores,
which may need to add a dependency on a prior store queue entry after
finding a matching address in the load or store queues. In rare cases,
a replay may also be required when a uop is issued but no applicable
functional units are left for it to execute on. The <TT><FONT SIZE="-1">ReorderBufferEntry::replay()</FONT></TT>
method is a wrapper around <TT><FONT SIZE="-1">IssueQueue::replay()</FONT></TT> used
to collect the operands the uop is still waiting for.

<P>

<H2><A NAME="SECTION04431000000000000000">
Implementation</A>
</H2>

<P>
PTLsim uses a novel method of modeling the issue queue and other associative
structures with small tags. Specifically, the <TT><FONT SIZE="-1">FullyAssociativeArrayTags8bit</FONT></TT>
template class declared in <TT><FONT SIZE="-1">logic.h</FONT></TT> and used to build
the issue queue makes use of the host processor's 128-bit vector (SSE)
instructions to do massively parallel associative matching, masking
and bit scanning on up to 16 tags every clock cycle. This makes it
substantially faster than simulators using the naive approach of scanning
the issue queue entries linearly. Similar classes in <TT><FONT SIZE="-1">logic.h</FONT></TT>
support O(1) associative searches of both 8-bit and 16-bit tags; tags
longer than this are generally more efficient if the generic <TT><FONT SIZE="-1">FullyAssociativeArrayTags</FONT></TT>
using standard integer comparisons is used instead.

<P>
As a result of this high performance design, each issue queue is limited
to 64 entries and the tags to be matched must be between 0 and 255
to fit in 8 bits. The <TT><FONT SIZE="-1">FullyAssociativeArrayTags16bit</FONT></TT>
class can be used instead if longer tags are required, at the cost
of reduced simulation performance.

<P>

<H2><A NAME="SECTION04432000000000000000">
Other Designs</A>
</H2>

<P>
It's important to remember that the issue queue design described above
is <I>one</I> possible implemention out of the many designs currently
used in industry and research processors. For instance, in lieu of
the collapsing design (used by the Pentium 4 and Power4/5/970), the
AMD K8 uses a sequence number tag of the ROB and comparator logic
to select the earliest ready instruction. Similarly, the Pentium 4
uses a set of bit vectors (a <I>dependency matrix</I>) instead of
tag broadcasts to wake up instructions. These other approaches may
be implemented by modifying the <TT><FONT SIZE="-1">IssueQueue</FONT></TT> class as
appropriate.

<P>

<H1><A NAME="SECTION04440000000000000000"></A><A NAME="sec:Issue"></A>
<BR>
Issue
</H1>

<P>
The <TT><FONT SIZE="-1">issue()</FONT></TT> top-level function issues one or more
instructions in each cluster from each issue queue every cycle. This
function consults the <TT><FONT SIZE="-1">clusters[</FONT></TT><I>clusterid</I><TT><FONT SIZE="-1">].issue_width</FONT></TT>
field defined in <TT><FONT SIZE="-1">ooohwdef.h</FONT></TT> to determine the maximum
number of uops to issue from each cluster. The <TT><FONT SIZE="-1">issueq_operation_on_cluster_with_result(cluster,
iqslot, issue())</FONT></TT> macro (Section <A HREF="#sec:Clustering">9.1</A>) is used to
invoke the <TT><FONT SIZE="-1">issue()</FONT></TT> method of the appropriate cluster
to select the earliest ready issue queue slot, as described in Section
<A HREF="#sec:Scheduling">9.3</A>. 

<P>
The <TT><FONT SIZE="-1">ReorderBufferEntry::issue()</FONT></TT> method of the corresponding
ROB entry is then called to actually execute the uop. This method
first makes sure a functional unit is available within the cluster
that's capable of executing the uop; if not, the uop is replayed and
re-issued again on the next cycle. At this point, the uop's three
operands (<TT><FONT SIZE="-1">ra</FONT></TT>, <TT><FONT SIZE="-1">rb</FONT></TT>, <TT><FONT SIZE="-1">rc</FONT></TT>)
are read from the physical register file. If any of the operands are
invalid, the entire uop is marked as invalid with an <TT><FONT SIZE="-1">EXCEPTION_Propagate</FONT></TT>
result and is not further executed. Otherwise, the uop is executed
by calling the synthesized execute function for the uop (see Section
<A HREF="node11.html#sec:FetchStage">7.1</A>).

<P>
Loads and stores are handled specially by calling the <TT><FONT SIZE="-1">issueload()</FONT></TT>
or <TT><FONT SIZE="-1">issuestore()</FONT></TT> method. Since loads and stores can
encounter an mis-speculation (e.g. when a load is erroneously issued
before an earlier store to the same addresses), the <TT><FONT SIZE="-1">issueload()</FONT></TT>
and <TT><FONT SIZE="-1">issuestore()</FONT></TT> functions can return <TT><FONT SIZE="-1">ISSUE_MISSPECULATED</FONT></TT>
to force all uops in program order after the mis-speculated uop to
be annulled and sent through the pipeline again. Similarly, if <TT><FONT SIZE="-1">issueload()</FONT></TT>
or <TT><FONT SIZE="-1">issuestore()</FONT></TT> return <TT><FONT SIZE="-1">ISSUE_NEEDS_REPLAY</FONT></TT>,
issuing from that cluster is aborted since the uop has been replayed
in accordance with Section <A HREF="#sec:Scheduling">9.3</A>. It is important
to note that loads which miss the cache are considered to complete
successfully and do <I>not</I> require a replay; their physical register
is simply marked as waiting until the load arrives. In both the mis-speculation
and replay cases, no further uops from the cluster's issue queue are
dispatched until the next cycle.

<P>
Branches are handled similar to integer and floating point operations,
except that they may cause a mis-speculation in the event of a branch
misprediction; this is discussed below.

<P>
If the uop caused an exception, we force it directly to the commit
stage and not through writeback; this keeps dependencies waiting until
they can be properly annulled by the speculation recovery logic. The
commit stage will detect the exception and take appropriate action.
If the exceptional uop was speculatively executed beyond a branch,
it will never reach commit anyway since the bogus branch would have
to commit before the exception would even become visible.

<P>
<B><I>NOTE:</I></B> In PTLsim, all issued uops put their result
in the uop's assigned physical register at the time of issue, even
though the data technically does not appear there until writeback
(i.e. the physical register enters the <I>written</I> state). This
is done to simplify the simulator implementation; it is assumed that
any data ``read'' from physical registers before writeback is
in fact being read from the bypass network instead.

<P>
<HR>
<!--Navigation Panel-->
<A NAME="tex2html511"
  HREF="node14.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html507"
  HREF="node9.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html501"
  HREF="node12.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html509"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html512"
  HREF="node14.html">Speculation and Recovery</A>
<B> Up:</B> <A NAME="tex2html508"
  HREF="node9.html">Out of Order Processor</A>
<B> Previous:</B> <A NAME="tex2html502"
  HREF="node12.html">Frontend and Key Structures</A>
 &nbsp; <B>  <A NAME="tex2html510"
  HREF="node1.html">Contents</A></B> 
<!--End of Navigation Panel-->
<ADDRESS>
Matt T Yourst
2005-10-03
</ADDRESS>
</BODY>
</HTML>
