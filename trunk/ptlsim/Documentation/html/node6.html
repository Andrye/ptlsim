<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<!--Converted with LaTeX2HTML 2002-2-1 (1.70)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Statistics Collection and Control</TITLE>
<META NAME="description" CONTENT="Statistics Collection and Control">
<META NAME="keywords" CONTENT="PTLsimManual">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<META NAME="Generator" CONTENT="LaTeX2HTML v2002-2-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="PTLsimManual.css">

<LINK REL="next" HREF="node7.html">
<LINK REL="previous" HREF="node5.html">
<LINK REL="up" HREF="node2.html">
<LINK REL="next" HREF="node7.html">
</HEAD>

<BODY >
<!--Navigation Panel-->
<A NAME="tex2html353"
  HREF="node7.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html349"
  HREF="node2.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html343"
  HREF="node5.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html351"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html354"
  HREF="node7.html">x86 Instructions and Micro-Ops</A>
<B> Up:</B> <A NAME="tex2html350"
  HREF="node2.html">PTLsim User's Guide</A>
<B> Previous:</B> <A NAME="tex2html344"
  HREF="node5.html">PTLsim Internals</A>
 &nbsp; <B>  <A NAME="tex2html352"
  HREF="node1.html">Contents</A></B> 
<BR>
<BR>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL>
<LI><A NAME="tex2html355"
  HREF="node6.html#SECTION02410000000000000000">Using PTLstats to Analyze Statistics</A>
<LI><A NAME="tex2html356"
  HREF="node6.html#SECTION02420000000000000000">Statistics support in code</A>
<LI><A NAME="tex2html357"
  HREF="node6.html#SECTION02430000000000000000">PTLsim Calls From User Code</A>
<LI><A NAME="tex2html358"
  HREF="node6.html#SECTION02440000000000000000">Notes on Benchmarking Methodology</A>
<LI><A NAME="tex2html359"
  HREF="node6.html#SECTION02450000000000000000">Simulation Warmup Periods</A>
<LI><A NAME="tex2html360"
  HREF="node6.html#SECTION02460000000000000000">Performance and Statistical Counters</A>
</UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION02400000000000000000"></A><A NAME="sec:StatisticsInfrastructure"></A>
<BR>
Statistics Collection and Control
</H1>

<P>

<H1><A NAME="SECTION02410000000000000000">
Using PTLstats to Analyze Statistics</A>
</H1>

<P>
PTLsim maintains a huge number of statistical counters and data points
during the simulation process, and can optionally save this data to
a statistics data store by using the ``<TT><FONT SIZE="-1">-stats</FONT></TT> <I>filename</I>''
configuration option introduced in Section <A HREF="node4.html#sec:ConfigurationOptions">2.3</A>.
The data store is a binary file format (defined in <TT><FONT SIZE="-1">datastore.cpp</FONT></TT>)
used to efficiently capture large quantities of statistical information
for later analysis. This file format supports storing multiple regular
snapshots of all counters by specifying the ``<TT><FONT SIZE="-1">-snapshot</FONT></TT>
<I>N</I>'' option to save a snapshot of the simulator state every
<I>N</I> cycles in addition to the final state.

<P>
The <I>PTLstats</I> program is used to analyze the statistics data
store files produced by PTLsim. The syntax of this command is ``<TT><FONT SIZE="-1">ptlstats
-</FONT></TT><I>options</I> <I>filename</I>''.

<P>
The following major actions) are supported:

<P>

<UL>
<LI>[(no&nbsp;options)]Print the full PTLsim statistics tree in the textual
format shown below.
</LI>
<LI>[<B>-subtree</B><B><I>&nbsp;</I></B><I>root</I>]Print a subtree of
the statistics tree. For instance, to print just the load unit statistics
in the final snapshot, use ``<TT><FONT SIZE="-1">ptlstats</FONT></TT> <TT><B><FONT SIZE="-1">-subtree
final/dcache/load</FONT></B></TT> <TT><I><FONT SIZE="-1">filename.stats</FONT></I></TT>''.
</LI>
<LI>[<B>-collect</B><B><I>&nbsp;</I></B><I>root</I>]Collect the same
subtree from muliple statistics files and print all the subtrees.
For instance, to print the L1 cache hit rate for two benchmarks, use
``<TT><FONT SIZE="-1">ptlstats</FONT></TT> <TT><B><FONT SIZE="-1">-collect /final/dcache/load/hit/L1</FONT></B></TT>
<TT><FONT SIZE="-1">bench1.stats bench2.stats ...</FONT></TT>''. This option is useful
for taking a cross section from all benchmarks of a specific statistic
(or subtree of statistics).
</LI>
<LI>[<B>-histogram</B><B><I>&nbsp;</I></B><I>root</I>]Generate a histogram
graph, in SVG (Scalable Vector Graphics) format, of the specified
statistics node. The node must be an array of integers previously
marked as a histogram (see the source code examples for details).
Various other options are provided to control the graph size, title,
data percentile cutoff and log scaling. 
</LI>
</UL>Additional options and their descriptions can be found by running
<TT><FONT SIZE="-1">ptlstats</FONT></TT> without any arguments.

<P>
The following is an example of the type of output you can expect from
PTLstats:

<P>

<DL COMPACT>
<DT>
<DD><FONT SIZE="-1">dcache&nbsp;{</FONT>
<P>


<P>
&nbsp;<FONT SIZE="-1">&nbsp;store&nbsp;{</FONT>
<P>


<P>
&nbsp;<FONT SIZE="-1">&nbsp;&nbsp;&nbsp;issue&nbsp;(total&nbsp;134243383)&nbsp;{</FONT>
<P>


<P>
&nbsp;<FONT SIZE="-1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;22%&nbsp;]&nbsp;replay&nbsp;(total&nbsp;29278598)&nbsp;{</FONT>
<P>


<P>
&nbsp;<FONT SIZE="-1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;&nbsp;0%&nbsp;]&nbsp;wait-sfraddr&nbsp;=&nbsp;0;</FONT>
<P>


<P>
&nbsp;<FONT SIZE="-1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;33%&nbsp;]&nbsp;wait-storedata-sfraddr&nbsp;=&nbsp;9755097;</FONT>
<P>


<P>
&nbsp;<FONT SIZE="-1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;33%&nbsp;]&nbsp;wait-storedata-sfraddr-sfrdata&nbsp;=&nbsp;9755097;</FONT>
<P>


<P>
&nbsp;<FONT SIZE="-1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;&nbsp;6%&nbsp;]&nbsp;wait-storedata-sfrdata&nbsp;=&nbsp;1891253;</FONT>
<P>


<P>
&nbsp;<FONT SIZE="-1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;&nbsp;4%&nbsp;]&nbsp;wait-sfrdata&nbsp;=&nbsp;1069751;</FONT>
<P>


<P>
&nbsp;<FONT SIZE="-1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;23%&nbsp;]&nbsp;wait-sfraddr-sfrdata&nbsp;=&nbsp;6807400;</FONT>
<P>


<P>
&nbsp;<FONT SIZE="-1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</FONT>
<P>


<P>
&nbsp;<FONT SIZE="-1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;&nbsp;0%&nbsp;]&nbsp;exception&nbsp;=&nbsp;196094;</FONT>
<P>


<P>
&nbsp;<FONT SIZE="-1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;&nbsp;0%&nbsp;]&nbsp;ordering&nbsp;=&nbsp;55369;</FONT>
<P>


<P>
&nbsp;<FONT SIZE="-1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;78%&nbsp;]&nbsp;complete&nbsp;=&nbsp;104592504;</FONT>
<P>


<P>
&nbsp;<FONT SIZE="-1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;&nbsp;0%&nbsp;]&nbsp;unaligned&nbsp;=&nbsp;120818;</FONT>
<P>


<P>
&nbsp;<FONT SIZE="-1">&nbsp;&nbsp;&nbsp;}</FONT>
<P>


<P>
&nbsp;<FONT SIZE="-1">&nbsp;&nbsp;&nbsp;...</FONT>
<P>

</DD>
</DL>Notice how PTLstats will automatically sum up all entries in certain
branches of the tree to provide the user with a breakdown by percentages
of the total for that subtree in addition to the raw values.

<P>

<H1><A NAME="SECTION02420000000000000000">
Statistics support in code</A>
</H1>

<P>
Internally, PTLsim represents data store nodes in a tree format via
the <TT><FONT SIZE="-1">DataStoreNode</FONT></TT> class defined in <TT><FONT SIZE="-1">datastore.h</FONT></TT>.
Each node can contain other data store nodes as well as a value (64-bit
integer, floating point, character string) or an array of values.
The following example illustrates the proper way to save statistical
counters (typically declared as global variables of type <TT><FONT SIZE="-1">W64</FONT></TT>,
a 64-bit integer) into the data store. In this example, the <TT><I><FONT SIZE="-1">root</FONT></I></TT>
<TT><FONT SIZE="-1">DataStoreNode</FONT></TT> is assumed to be passed in as the parent
of all other nodes:

<P>

<DL COMPACT>
<DT>
<DD><FONT SIZE="-1">DataStoreNode&amp;&nbsp;issue&nbsp;=&nbsp;root(&#34;issue&#34;);&nbsp;{</FONT>
<P>


<P>
&nbsp;<FONT SIZE="-1">&nbsp;DataStoreNode&amp;&nbsp;unit&nbsp;=&nbsp;issue(&#34;unit&#34;);&nbsp;{</FONT>
<P>


<P>
&nbsp;<FONT SIZE="-1">&nbsp;&nbsp;&nbsp;unit.summable&nbsp;=&nbsp;1;</FONT>
<P>


<P>
&nbsp;<FONT SIZE="-1">&nbsp;&nbsp;&nbsp;unit.add(&#34;integer&#34;,&nbsp;issued_integer_uops);</FONT>
<P>


<P>
&nbsp;<FONT SIZE="-1">&nbsp;&nbsp;&nbsp;unit.add(&#34;fp&#34;,&nbsp;issued_fp_uops);</FONT>
<P>


<P>
&nbsp;<FONT SIZE="-1">&nbsp;&nbsp;&nbsp;unit.add(&#34;load&#34;,&nbsp;issued_load_uops);</FONT>
<P>


<P>
&nbsp;<FONT SIZE="-1">&nbsp;&nbsp;&nbsp;unit.add(&#34;store&#34;,&nbsp;issued_store_uops);</FONT>
<P>


<P>
&nbsp;<FONT SIZE="-1">&nbsp;}</FONT>
<P>


<P>
&nbsp;<FONT SIZE="-1">&nbsp;DataStoreNode&amp;&nbsp;histogram&nbsp;=&nbsp;issue(&#34;times&#34;);&nbsp;{</FONT>
<P>


<P>
&nbsp;<FONT SIZE="-1">&nbsp;&nbsp;&nbsp;cluster.summable&nbsp;=&nbsp;1;</FONT>
<P>


<P>
&nbsp;<FONT SIZE="-1">&nbsp;&nbsp;&nbsp;foreach&nbsp;(i,&nbsp;MAX_CLUSTERS)&nbsp;{</FONT>
<P>


<P>
&nbsp;<FONT SIZE="-1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringbuf&nbsp;sb;&nbsp;sb&nbsp;&lt;&lt;&nbsp;i;</FONT>
<P>


<P>
&nbsp;<FONT SIZE="-1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cluster.addfloat(sb,&nbsp;timer_histogram[i]);</FONT>
<P>


<P>
&nbsp;<FONT SIZE="-1">&nbsp;&nbsp;&nbsp;}</FONT>
<P>


<P>
&nbsp;<FONT SIZE="-1">&nbsp;}</FONT>
<P>


<P>
<FONT SIZE="-1">}</FONT>
<P>

</DD>
</DL>In the example above, a statistics tree is created in which all subnodes
under the ``<TT><FONT SIZE="-1">unit</FONT></TT>'' node are integers together
assumed to total 100% of whatever quantity is being measured. Setting
<TT><FONT SIZE="-1">summable = 1</FONT></TT> tells PTLstats to print percentages next
to the raw values in this subtree for easier viewing. The ``<TT><FONT SIZE="-1">times</FONT></TT>''
subnode contains floating point values; the <TT><FONT SIZE="-1">stringbuf</FONT></TT>
utility class is used to convert each slot index of this example histogram
into a proper node name. This is only an example - PTLsim already
contains code to save all statistics it generates.

<P>
PTLsim will by default call <TT><FONT SIZE="-1">ooo_capture_stats()</FONT></TT>
every time a snapshot or final capture is taken, and will pass this
function the top level DataStoreNode for that snapshot. Therefore,
if adding your own statistics and counters, you should start by saving
these counters using code inside <TT><FONT SIZE="-1">ooo_capture_stats()</FONT></TT>
like that shown above. 

<P>
We suggest using the data store mechanism to store <I>all</I> statistics
generated by your additions to PTLsim, since this system has built-in
support for snapshots, checkpointing and structured easy to parse
data (unlike simply writing values to a text file). It is further
suggested that only raw values be saved, rather than doing computations
in the simulator itself - leave the analysis to PTLstats after gathering
the raw data. In particular, try to avoid using floating point within
the simulator if at all possible, since some floating point calculations
may reconfigure the SSE rounding and control flags in ways that break
the assumptions used to execute actual user code.

<P>

<H1><A NAME="SECTION02430000000000000000"></A><A NAME="sec:TriggerMode"></A>
<BR>
PTLsim Calls From User Code
</H1>

<P>
PTLsim optionally allows user code to control the simulator mode through
the <TT><FONT SIZE="-1">ptlcall_xxx()</FONT></TT> family of functions found in <TT><FONT SIZE="-1">ptlcalls.h</FONT></TT>
when trigger mode is enabled (<TT><FONT SIZE="-1">-trigger</FONT></TT> configuration
option). This file should be included by any PTLsim-aware user programs;
these programs must be recompiled to take advantage of these features.
Amongst the functions provided by <TT><FONT SIZE="-1">ptlcalls.h</FONT></TT> are:

<P>

<UL>
<LI><TT><FONT SIZE="-1">ptlcall_switch_to_sim()</FONT></TT> is only available while
the program is executing in native mode. It forces PTLsim to regain
control and begin simulating instructions as soon as this call returns.
</LI>
<LI><TT><FONT SIZE="-1">ptlcall_switch_to_native()</FONT></TT> stops simulation and
returns to native execution, effectively removing PTLsim from the
loop.
</LI>
<LI><TT><FONT SIZE="-1">ptlcall_marker()</FONT></TT> simply places a user-specified marker
number in the PTLsim log file
</LI>
<LI><TT><FONT SIZE="-1">ptlcall_capture_stats()</FONT></TT> adds a new statistics data
store snapshot at the time it is called. 
</LI>
<LI><TT><FONT SIZE="-1">ptlcall_nop()</FONT></TT> does nothing but test the call mechanism.
</LI>
</UL>
These calls work by forcing execution to code on a ``gateway page''
at a specific fixed address (<TT><FONT SIZE="-1">0x1000</FONT></TT> currently); PTLsim
will write the appropriate call gate code to this page depending on
whether the process is in native or simulated mode. In native mode,
the call gate page typically contains a 64-to-64-bit or 32-to-64-bit
far jump into PTLsim, while in simulated mode it contains a reserved
x86 opcode interpreted by the x86 decoder as a special kind of system
call.

<P>
Generally these calls are used to perform ``intelligent benchmarking'':
the <TT><FONT SIZE="-1">ptlcall_switch_to_sim()</FONT></TT> call is made at the
top of the main loop of a benchmark after initialization, while the
<TT><FONT SIZE="-1">ptlcall_switch_to_native()</FONT></TT> call is inserted after
some number of iterations to stop simulation after a representative
subset of the code has completed. This intelligent approach is far
better than the blind ``sample for N million cycles after S million
startup cycles'' approach used by most researchers.

<P>
Fortran programs will have to actually link in the <TT><FONT SIZE="-1">ptlcalls.o</FONT></TT>
object file, since they cannot include C header files. The function
names that should be used in the Fortran code remain the same as those
from the <TT><FONT SIZE="-1">ptlcalls.h</FONT></TT> header file.

<P>

<H1><A NAME="SECTION02440000000000000000">
Notes on Benchmarking Methodology</A>
</H1>

<P>
The x86 instruction set requires some different benchmarking techniques
than classical RISC ISAs. In particular, <B>IPC (Instructions
per Cycle) a NOT a good measure of performance for an x86 processor.</B>
Because one x86 instruction may be broken up into numerous uops, it
is never appropriate to compare IPC figures for committed x86 instructions
per clock with IPC values from a RISC machine. Furthermore, different
x86 implementations use varying numbers of uops per x86 instruction
as a matter of encoding, so even comparing the uop based IPC between
x86 implementations or RISC-like machines is inaccurate.

<P>
Users are strongly advised to use relative performance measures instead.
Comparing the total simulated cycle count required to complete a given
benchmark between different simulator configurations is much more
appropriate than IPC with the x86 instruction set. An example would
be &#34;the baseline took 100M cycles, while our improved system
took 50M cycles, for a 2x improvement.

<P>

<H1><A NAME="SECTION02450000000000000000">
Simulation Warmup Periods</A>
</H1>

<P>
In some simulators, it is possible to quickly skip through a specific
number of instructions before starting to gather statistics, to avoid
including initialization code in the statistics. In PTLsim, this is
neither necessary nor desirable. Because PTLsim directly executes
your program on the host CPU until it switches to cycle accurate simulation
mode, there is no way to count instructions in this manner. 

<P>
Many researchers have gotten in the habit of blindly skipping a large
number of instructions in benchmarks to avoid profiling initialization
code. However, this is not a very intelligent policy: different benchmarks
have different startup times until the top of the main loop is reached,
and it is generally evident from the benchmark source code where that
point should be. Therefore, PTLsim supports <B>trigger points:</B>
by inserting a special function call (<TT><FONT SIZE="-1">ptlcall_switch_to_sim</FONT></TT>)
within the benchmark source code and recompiling, the <TT><FONT SIZE="-1">-trigger</FONT></TT>
PTLsim option can be used to run the code on the host CPU until the
trigger point is reached. If the source code is unavailable, the <TT><FONT SIZE="-1">-startrip</FONT></TT>
<TT><I><FONT SIZE="-1">0xADDRESS</FONT></I></TT> option will start full simulation
only at a specified address (e.g. function entry point). 

<P>
If you want to warm up the cache and branch predictors prior to starting
statistics collection, combine the <TT><FONT SIZE="-1">-trigger</FONT></TT> option
with the <TT><FONT SIZE="-1">-snapshot</FONT></TT> <TT><I><FONT SIZE="-1">N</FONT></I></TT> option,
to start full simulation at the top of the benchmark's main loop (where
the trigger call is), but only start gathering statistics <I>N</I>
cycles later, after the processor is warmed up. Remember, since the
trigger point is placed <I>after</I> all initialization code in the
benchmark, in general it is only necessary to use 10-20 million cycles
of warmup time before taking the first statistics snapshot. In this
time, the caches and branch predictor will almost always be completely
overwritten many times. This approach significantly speeds up the
simulation without any loss of accuracy compared to the &#34;fast
simulation&#34; mode provided by other simulators. 

<P>
In PTLstats, use the <TT><FONT SIZE="-1">-delta</FONT></TT> option to make sure the
final statistics don't include the warmup period before the first
snapshot. To subtract the final snapshot from snapshot 0 (the first
snapshot after the warmup period), use a command similar to the following:

<P>

<DL COMPACT>
<DT>
<DD><FONT SIZE="-1">ptlstats&nbsp;-deltastart&nbsp;0&nbsp;ptlsim.stats&nbsp;&gt;&nbsp;ptlsim.stats.txt</FONT>
<P>

</DD>
</DL>
<P>

<H1><A NAME="SECTION02460000000000000000">
Performance and Statistical Counters</A>
</H1>

<P>
The full list of PTLsim performance and statistical counters is given
in Section <A HREF="node22.html#sec:PerformanceCounters">18</A>.

<P>
<HR>
<!--Navigation Panel-->
<A NAME="tex2html353"
  HREF="node7.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html349"
  HREF="node2.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html343"
  HREF="node5.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html351"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html354"
  HREF="node7.html">x86 Instructions and Micro-Ops</A>
<B> Up:</B> <A NAME="tex2html350"
  HREF="node2.html">PTLsim User's Guide</A>
<B> Previous:</B> <A NAME="tex2html344"
  HREF="node5.html">PTLsim Internals</A>
 &nbsp; <B>  <A NAME="tex2html352"
  HREF="node1.html">Contents</A></B> 
<!--End of Navigation Panel-->
<ADDRESS>
Matt T Yourst
2005-12-02
</ADDRESS>
</BODY>
</HTML>
