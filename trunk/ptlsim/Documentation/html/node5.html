<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<!--Converted with LaTeX2HTML 2002-2-1 (1.70)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>PTLsim Internals</TITLE>
<META NAME="description" CONTENT="PTLsim Internals">
<META NAME="keywords" CONTENT="PTLsimManual">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<META NAME="Generator" CONTENT="LaTeX2HTML v2002-2-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="PTLsimManual.css">

<LINK REL="next" HREF="node6.html">
<LINK REL="previous" HREF="node4.html">
<LINK REL="up" HREF="node2.html">
<LINK REL="next" HREF="node6.html">
</HEAD>

<BODY >
<!--Navigation Panel-->
<A NAME="tex2html330"
  HREF="node6.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html326"
  HREF="node2.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html320"
  HREF="node4.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html328"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html331"
  HREF="node6.html">Statistics Collection and Control</A>
<B> Up:</B> <A NAME="tex2html327"
  HREF="node2.html">PTLsim User's Guide</A>
<B> Previous:</B> <A NAME="tex2html321"
  HREF="node4.html">Getting Started with PTLsim</A>
 &nbsp; <B>  <A NAME="tex2html329"
  HREF="node1.html">Contents</A></B> 
<BR>
<BR>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL>
<LI><A NAME="tex2html332"
  HREF="node5.html#SECTION02310000000000000000">Overview</A>
<LI><A NAME="tex2html333"
  HREF="node5.html#SECTION02320000000000000000">Common Libraries and Logic Design APIs</A>
<UL>
<LI><A NAME="tex2html334"
  HREF="node5.html#SECTION02321000000000000000">General Purpose Macros</A>
<LI><A NAME="tex2html335"
  HREF="node5.html#SECTION02322000000000000000">Super Standard Template Library (SuperSTL)</A>
<LI><A NAME="tex2html336"
  HREF="node5.html#SECTION02323000000000000000">Logic Standard Template Library (LogicSTL)</A>
<LI><A NAME="tex2html337"
  HREF="node5.html#SECTION02324000000000000000">Miscellaneous Code</A>
</UL>
<BR>
<LI><A NAME="tex2html338"
  HREF="node5.html#SECTION02330000000000000000">Low Level Startup and Injection</A>
<LI><A NAME="tex2html339"
  HREF="node5.html#SECTION02340000000000000000">Simulator Startup</A>
<LI><A NAME="tex2html340"
  HREF="node5.html#SECTION02350000000000000000">Address Space Simulation</A>
<LI><A NAME="tex2html341"
  HREF="node5.html#SECTION02360000000000000000">Debugging Hints</A>
<LI><A NAME="tex2html342"
  HREF="node5.html#SECTION02370000000000000000">Timing Issues</A>
</UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION02300000000000000000"></A><A NAME="sec:PTLsimInternals"></A>
<BR>
PTLsim Internals
</H1>

<P>

<H1><A NAME="SECTION02310000000000000000">
Overview</A>
</H1>

<P>
The following is an overview of the source files for PTLsim:

<P>

<UL>
<LI><TT><B><FONT SIZE="-1">ooocore.cpp</FONT></B></TT> is the out of order simulator
itself. The microarchitectural model implemented by this simulator
is the subject of Part <A HREF="node8.html#part:OutOfOrderModel">II</A>.
</LI>
<LI><TT><B><FONT SIZE="-1">ptlhwdef.cpp</FONT></B></TT> and <TT><B><FONT SIZE="-1">ptlhwdef.h</FONT></B></TT>
define the basic uop encodings, flags and registers. The tables of
uops might be interesting to see how a modern x86 processor is designed
at the microcode level. The basic format is discussed in Section <A HREF="node7.html#sec:UopIntro">5.1</A>;
all uops are documented in Section <A HREF="node21.html#sec:UopReference">17</A>.
</LI>
<LI><TT><B><FONT SIZE="-1">ooohwdef.h</FONT></B></TT> defines the parameters of the
out of order processor model not intrinsic to the PTLsim uop instruction
set itself.
</LI>
<LI><TT><B><FONT SIZE="-1">translate-x86.cpp</FONT></B></TT> is where the x86 and x86-64
to uop translation takes place. It is complicated and generally you
shouldn't need to deal with this code to use or modify the simulator.
</LI>
<LI><TT><B><FONT SIZE="-1">dcache.cpp</FONT></B></TT> and <TT><B><FONT SIZE="-1">dcache.h</FONT></B></TT>
and <TT><B><FONT SIZE="-1">dcacheint.h</FONT></B></TT> contain the data cache model.
At present the full L1/L2/L3/mem hierarchy is modeled. Note that the
instruction cache is missing at this point, but will be added back
in very soon. For SPEC this does not matter very much. The cache hierarchy
is very flexible configuration wise; it is described further in Section
<A HREF="node18.html#sec:CacheHierarchy">15</A>.
</LI>
<LI><TT><B><FONT SIZE="-1">kernel.cpp</FONT></B></TT> and <TT><B><FONT SIZE="-1">kernel.h</FONT></B></TT>
is where all the virtual machine &#34;black magic&#34; takes
place to let PTLsim transparently switch between simulation and native
mode and 32-bit/64-bit mode. In general you should not need to touch
this since it is very Linux kernel specific (this version works with
2.6.12 - 2.6.13) and works at a level below the standard C/C++ libraries.
</LI>
<LI><TT><B><FONT SIZE="-1">branchpred.cpp</FONT></B></TT> and <TT><B><FONT SIZE="-1">branchpred.h</FONT></B></TT>
is the branch predictor. Currently this is set up as a hybrid bimodal
and history based predictor with various customizable parameters.
</LI>
<LI><TT><B><FONT SIZE="-1">logic.h</FONT></B></TT> is a library of C++ templates for
implementing synchronous logic structures like associative arrays,
queues, register files, etc. It has some very clever features like
<TT><FONT SIZE="-1">FullyAssociativeArray8bit</FONT></TT>, which uses x86 SSE vector
instructions to associatively match and process ~16
byte-sized tags every cycle. These classes are fully parameterized
and useful for all kinds of simulations.
</LI>
<LI><TT><B><FONT SIZE="-1">globals.h</FONT></B></TT>, <TT><B><FONT SIZE="-1">superstl.h</FONT></B></TT>
and <TT><B><FONT SIZE="-1">superstl.cpp</FONT></B></TT> implement various standard
library functions and classes as an alternative to C++ STL. These
libraries also contain a number of features very useful for bit manipulation.
</LI>
<LI><TT><B><FONT SIZE="-1">uopinterface.cpp</FONT></B></TT> contains code for mapping
uop opcodes and characteristics to their implementation in <TT><FONT SIZE="-1">uopimpl.S</FONT></TT>.
</LI>
<LI><TT><B><FONT SIZE="-1">uopimpl.S</FONT></B></TT> contains x86-64 assembly language
implementations of all uops and their variations. PTLsim implements
most ALU and floating point uops in assembler so as to leverage the
exact semantics and flags generated by real x86 instructions, since
most PTLsim uops are so similar to the equivalent x86 instructions.
</LI>
<LI><TT><B><FONT SIZE="-1">ptlsim.cpp</FONT></B></TT> and <TT><B><FONT SIZE="-1">ptlsim.h</FONT></B></TT>
are responsible for initializing PTLsim and starting the appropriate
simulation core code.
</LI>
<LI><TT><B><FONT SIZE="-1">config.cpp</FONT></B></TT> and <TT><B><FONT SIZE="-1">config.h</FONT></B></TT>
manage the PTLsim configuration options for each user program.
</LI>
<LI><TT><B><FONT SIZE="-1">datastore.cpp</FONT></B></TT> and <TT><B><FONT SIZE="-1">datastore.h</FONT></B></TT>
manage the PTLsim statistics data store file structure.
</LI>
<LI><TT><B><FONT SIZE="-1">lowlevel-64bit.S</FONT></B></TT> contains 64-bit startup
and context switching code. PTLsim execution starts here.
</LI>
<LI><TT><B><FONT SIZE="-1">lowlevel-32bit.S</FONT></B></TT> contains 32-bit startup
and context switching code.
</LI>
<LI><TT><B><FONT SIZE="-1">injectcode.cpp</FONT></B></TT> is compiled into the 32-bit
and 64-bit code injected into the target process to map the <TT><FONT SIZE="-1">ptlsim</FONT></TT>
binary and pass control to it.
</LI>
<LI><TT><B><FONT SIZE="-1">loader.h</FONT></B></TT> is used to pass information to the
injected boot code.
</LI>
<LI><TT><B><FONT SIZE="-1">ptlstats.cpp</FONT></B></TT> is a utility for printing and
analyzing the statistics data store files in various human readable
ways.
</LI>
<LI><TT><B><FONT SIZE="-1">cpuid.cpp</FONT></B></TT> is a utility program to show various
data returned by the x86 <TT><FONT SIZE="-1">cpuid</FONT></TT> instruction. Run it
under PTLsim for a surprise.
</LI>
<LI><TT><B><FONT SIZE="-1">genoffsets.cpp</FONT></B></TT> is a utility program used
during the build process to give the assembly language code the offsets
of various C++ structure fields.
</LI>
<LI><TT><B><FONT SIZE="-1">ptlcalls.c</FONT></B></TT> and <TT><B><FONT SIZE="-1">ptlcalls.h</FONT></B></TT>
are optionally compiled into user programs to let them switch into
and out of simulation mode on their own. The <TT><B><FONT SIZE="-1">ptlcalls.o</FONT></B></TT>
file is typically linked with Fortran programs that can't use regular
C header files.
</LI>
</UL>

<P>

<H1><A NAME="SECTION02320000000000000000">
Common Libraries and Logic Design APIs</A>
</H1>

<P>
PTLsim includes a number of powerful C++ templates, macros and functions
not found anywhere else. This section attempts to provide an overview
of these structures so that users of PTLsim will use them instead
of trying to duplicate work we've already done.

<P>

<H2><A NAME="SECTION02321000000000000000">
General Purpose Macros</A>
</H2>

<P>
The file <TT><FONT SIZE="-1">globals.h</FONT></TT> contains a wide range of very useful
definitions, functions and macros we have accumulated over the years,
including:

<P>

<UL>
<LI>Basic data types used throughout PTLsim (e.g. W64 for 64-bit words
and so on), <TT><FONT SIZE="-1">globals.h</FONT></TT> defines a
</LI>
<LI>Type safe C++ template based functions, including <TT><FONT SIZE="-1">min</FONT></TT>,
<TT><FONT SIZE="-1">max</FONT></TT>, <TT><FONT SIZE="-1">abs</FONT></TT>, <TT><FONT SIZE="-1">mux</FONT></TT>, etc.
</LI>
<LI>Iterator macros (<TT><FONT SIZE="-1">foreach</FONT></TT>) 
</LI>
<LI>Template based metaprogramming functions including <TT><FONT SIZE="-1">lengthof</FONT></TT>
(finds the length of any static array) and <TT><FONT SIZE="-1">log2</FONT></TT> (takes
the base-2 log of any constant at compile time)
</LI>
<LI>Floor, ceiling and masking functions for integers and powers of two
(<TT><FONT SIZE="-1">floor</FONT></TT>, <TT><FONT SIZE="-1">trunc</FONT></TT>, <TT><FONT SIZE="-1">ceil</FONT></TT>,
<TT><FONT SIZE="-1">mask</FONT></TT>, <TT><FONT SIZE="-1">floorptr</FONT></TT>, <TT><FONT SIZE="-1">ceilptr</FONT></TT>,
<TT><FONT SIZE="-1">maskptr</FONT></TT>, <TT><FONT SIZE="-1">signext</FONT></TT>, etc)
</LI>
<LI>Bit manipulation macros (<TT><FONT SIZE="-1">bit</FONT></TT>, <TT><FONT SIZE="-1">bitmask</FONT></TT>,
<TT><FONT SIZE="-1">bits</FONT></TT>, <TT><FONT SIZE="-1">lowbits</FONT></TT>, <TT><FONT SIZE="-1">setbit</FONT></TT>,
<TT><FONT SIZE="-1">clearbit</FONT></TT>, <TT><FONT SIZE="-1">assignbit</FONT></TT>). Note that the
<TT><FONT SIZE="-1">bitvec</FONT></TT> template (see below) should be used in place
of these macros wherever it is more convenient.
</LI>
<LI>Comparison functions (<TT><FONT SIZE="-1">aligned</FONT></TT>, <TT><FONT SIZE="-1">strequal</FONT></TT>,
<TT><FONT SIZE="-1">inrange</FONT></TT>, <TT><FONT SIZE="-1">clipto</FONT></TT>)
</LI>
<LI>Modulo arithmetic (<TT><FONT SIZE="-1">add_index_modulo</FONT></TT>, <TT><FONT SIZE="-1">modulo_span</FONT></TT>,
et al)
</LI>
<LI>Definitions of basic x86 SSE vector functions (e.g. <TT><FONT SIZE="-1">x86_cpu_pcmpeqb</FONT></TT>
et al)
</LI>
<LI>Definitions of basic x86 assembly language functions (e.g. <TT><FONT SIZE="-1">x86_bsf64</FONT></TT>
et al)
</LI>
<LI>A full suite of bit scanning functions (<TT><FONT SIZE="-1">lsbindex</FONT></TT>,
<TT><FONT SIZE="-1">msbindex</FONT></TT>, <TT><FONT SIZE="-1">popcount</FONT></TT> et al)
</LI>
<LI>Miscellaneous functions (<TT><FONT SIZE="-1">arraycopy</FONT></TT>, <TT><FONT SIZE="-1">setzero</FONT></TT>,
etc)
</LI>
</UL>

<P>

<H2><A NAME="SECTION02322000000000000000">
Super Standard Template Library (SuperSTL)</A>
</H2>

<P>
The Super Standard Template Library (SuperSTL) is an internal C++
library we use internally in lieu of the normal C++ STL for various
technical and preferential reasons. While the full documentation is
in the comments of <TT><FONT SIZE="-1">superstl.h</FONT></TT> and <TT><FONT SIZE="-1">superstl.cpp</FONT></TT>,
the following is a brief list of its features:

<P>

<UL>
<LI>I/O stream classes familiar from Standard C++, including <TT><FONT SIZE="-1">istream</FONT></TT>
and <TT><FONT SIZE="-1">ostream</FONT></TT>. Unique to SuperSTL is how the comma operator
(``,'') can be used to separate a list of objects to send to or
from a stream, in addition to the usual C++ insertion operator (``<&lt;'').
</LI>
<LI>To read and write binary data, the <TT><FONT SIZE="-1">idstream</FONT></TT> and <TT><FONT SIZE="-1">odstream</FONT></TT>
classes should be used instead.
</LI>
<LI>String buffer (<TT><FONT SIZE="-1">stringbuf</FONT></TT>) class for composing strings
in memory the same way they would be written to or read from an <TT><FONT SIZE="-1">ostream</FONT></TT>
or <TT><FONT SIZE="-1">istream</FONT></TT>.
</LI>
<LI>String formatting classes (<TT><FONT SIZE="-1">intstring</FONT></TT>, <TT><FONT SIZE="-1">hexstring</FONT></TT>,
<TT><FONT SIZE="-1">padstring</FONT></TT>, <TT><FONT SIZE="-1">bitstring</FONT></TT>, <TT><FONT SIZE="-1">bytemaskstring</FONT></TT>,
<TT><FONT SIZE="-1">floatstring</FONT></TT>) provide a wrapper around objects to exercise
greater control of how they are printed.
</LI>
<LI>Array (<TT><FONT SIZE="-1">array</FONT></TT>) template class represents a fixed size
array of objects. It is essentially a simple but very fast wrapper
for a C-style array.
</LI>
<LI>Bit vector (<TT><FONT SIZE="-1">bitvec</FONT></TT>) is a heavily optimized and rewritten
version of the Standard C++ <TT><FONT SIZE="-1">bitset</FONT></TT> class. It supports
many additional operations well suited to logic design purposes and
emphasizes extremely fast branch free code.
</LI>
<LI>Dynamic Array (<TT><FONT SIZE="-1">dynarray</FONT></TT>) template class provides for
dynamically sized arrays, stacks and other such structures, similar
to the Standard C++ <TT><FONT SIZE="-1">valarray</FONT></TT> class.
</LI>
<LI>Linked list node (<TT><FONT SIZE="-1">listlink</FONT></TT>) template class forms the
basis of double linked list structures in which a single pointer refers
to the head of the list.
</LI>
<LI>Queue list node (<TT><FONT SIZE="-1">queuelink</FONT></TT>) template class supports
more operations than <TT><FONT SIZE="-1">listlink</FONT></TT> and can serve as both
a node in a list and a list head/tail header.
</LI>
<LI>Index reference (<TT><FONT SIZE="-1">indexref</FONT></TT>) is a smart pointer which
compresses a full pointer into an index into a specific structure
(made unique by the template parameters). This class behaves exactly
like a pointer when referenced, but takes up much less space and may
be faster. The <TT><FONT SIZE="-1">indexrefnull</FONT></TT> class adds support for
storing null pointers, which <TT><FONT SIZE="-1">indexref</FONT></TT> lacks.
</LI>
<LI><TT><FONT SIZE="-1">Hashtable</FONT></TT> class is a general purpose chaining based
hash table with user configurable key hashing and management via add-on
template classes.
</LI>
<LI><TT><FONT SIZE="-1">ChunkHashtable</FONT></TT> class is a simplified hash table designed
for small data items, for instance where we simply want to detect
the presence of a key rather than associate data with it. It tries
to pack many keys into cache line sized chunks and does parallel vectorized
matching on each chunk for added speed.
</LI>
<LI><TT><FONT SIZE="-1">CRC32</FONT></TT> calculation class is useful for hashing
</LI>
<LI><TT><FONT SIZE="-1">CycleTimer</FONT></TT> is useful for timing intervals with sub-nanosecond
precision using the CPU cycle counter (discussed in Section <A HREF="#sec:Timing">3.7</A>).
</LI>
</UL>

<P>

<H2><A NAME="SECTION02323000000000000000">
Logic Standard Template Library (LogicSTL)</A>
</H2>

<P>
The Logic Standard Template Library (LogicSTL) is an internally developed
add-on to SuperSTL which supports a variety of structures useful for
modeling sequential logic. Some of its primitives may look familiar
to Verilog or VHDL programmers. While the full documentation is in
the comments of <TT><FONT SIZE="-1">logic.h</FONT></TT>, the following is a brief
list of its features:

<P>

<UL>
<LI><TT><FONT SIZE="-1">latch</FONT></TT> template class works like any other assignable
variable, but the new value only becomes visible after the <TT><FONT SIZE="-1">clock()</FONT></TT>
method is called (potentially from a global clock chain).
</LI>
<LI><TT><FONT SIZE="-1">Queue</FONT></TT> template class implements a general purpose
fixed size queue. The queue supports various operations from both
the head and the tail, and is ideal for modeling queues in microprocessors.
</LI>
<LI>Iterators for <TT><FONT SIZE="-1">Queue</FONT></TT> objects such as <TT><FONT SIZE="-1">foreach_forward</FONT></TT>,
<TT><FONT SIZE="-1">foreach_forward_from</FONT></TT>, <TT><FONT SIZE="-1">foreach_forward_after</FONT></TT>,
<TT><FONT SIZE="-1">foreach_backward</FONT></TT>, <TT><FONT SIZE="-1">foreach_backward_from</FONT></TT>,
<TT><FONT SIZE="-1">foreach_backward_before</FONT></TT>.
</LI>
<LI><TT><FONT SIZE="-1">HistoryBuffer</FONT></TT> maintains a shift register of values,
which when combined with a hash function is useful for implementing
predictor histories and the like.
</LI>
<LI><TT><FONT SIZE="-1">FullyAssociativeTags</FONT></TT> template class is a general purpose
array of associative tags in which each tag must be unique. This class
uses highly efficient matching logic and supports pseudo-LRU eviction,
associative invalidation and direct indexing. It forms the basis for
most associative structures in PTLsim.
</LI>
<LI><TT><FONT SIZE="-1">FullyAssociativeArray</FONT></TT> pairs a <TT><FONT SIZE="-1">FullyAssociativeTags</FONT></TT>
object with actual data values to form the basis of a cache.
</LI>
<LI><TT><FONT SIZE="-1">AssociativeArray</FONT></TT> divides a <TT><FONT SIZE="-1">FullyAssociativeArray</FONT></TT>
into sets. In effect, this class can provide a complete cache implementation
for a processor.
</LI>
<LI><TT><FONT SIZE="-1">LockableFullyAssociativeTags</FONT></TT>, <TT><FONT SIZE="-1">LockableFullyAssociativeArray</FONT></TT>
and <TT><FONT SIZE="-1">LockableAssociativeArray</FONT></TT> provide the same services
as the classes above, but support locking lines into the cache.
</LI>
<LI><TT><FONT SIZE="-1">CommitRollbackCache</FONT></TT> leverages the <TT><FONT SIZE="-1">LockableFullyAssociativeArray</FONT></TT>
class to provide a cache structure with the ability to roll back all
changes made to memory (not just within this object, but everywhere)
after a checkpoint is made.
</LI>
<LI><TT><FONT SIZE="-1">FullyAssociativeTags8bit</FONT></TT> and <TT><FONT SIZE="-1">FullyAssociativeTags16bit</FONT></TT>
work just like <TT><FONT SIZE="-1">FullyAssociativeTags</FONT></TT>, except that these
classes are dramatically faster when using small 8-bit and 16-bit
tags. This is possible through the clever use of x86 SSE vector instructions
to associatively match and process 16 8-bit tags or 8 16-bit tags
every cycle. In addition, these classes support features like removing
an entry from the middle of the array while compacting entries around
it in constant time. These classes should be used in place of <TT><FONT SIZE="-1">FullyAssociativeTags</FONT></TT>
whenever the tags are small enough (i.e. almost all tags except for
memory addresses).
</LI>
</UL>

<P>

<H2><A NAME="SECTION02324000000000000000">
Miscellaneous Code</A>
</H2>

<P>
The out of order simulator, ooocore.cpp, contains several reusable
classes, including:

<P>

<UL>
<LI><TT><FONT SIZE="-1">IssueQueue</FONT></TT> template class can be used to implement
all kinds of broadcast based issue queues
</LI>
<LI><TT><FONT SIZE="-1">StateList</FONT></TT> and <TT><FONT SIZE="-1">ListOfStateLists</FONT></TT> is
useful for collecting various lists that objects can be on into one
structure.
</LI>
</UL>

<P>

<H1><A NAME="SECTION02330000000000000000"></A><A NAME="sec:Injection"></A>
<BR>
Low Level Startup and Injection
</H1>

<P>
<I>Note:</I> This section deals with the internal operation of the
PTLsim virtual machine manager, independent of the out of order simulation
engine. If you are only interested in modifying the simulator itself,
you can skip this section.

<P>
PTLsim is a very unusual Linux program. It does its own internal memory
management and threading without help from the standard libraries,
injects itself into other processes to take control of them, and switches
between 32-bit and 64-bit mode within a single process image. For
these reasons, it is very closely tied to the Linux kernel and uses
a number of undocumented system calls and features only available
in late 2.6 series kernels. 

<P>
PTLsim always starts and runs as a 64-bit process even when running
32-bit threads; it context switches between modes as needed. The statically
linked <TT><FONT SIZE="-1">ptlsim</FONT></TT> executable begins executing at <TT><FONT SIZE="-1">ptlsim_preinit_entry</FONT></TT>
in <TT><FONT SIZE="-1">lowlevel-64bit.S</FONT></TT>. This code calls <TT><FONT SIZE="-1">ptlsim_preinit()</FONT></TT>
in <TT><FONT SIZE="-1">kernel.cpp</FONT></TT> to set up our custom memory manager
and threading environment before any standard C/C++ functions are
used. After doing so, the normal <TT><FONT SIZE="-1">main()</FONT></TT> function is
invoked.

<P>
The <TT><FONT SIZE="-1">ptlsim</FONT></TT> binary can run in two modes. If executed
from the command line as a normal program, it starts up in <I>inject</I>
mode. Specifically, <TT><FONT SIZE="-1">main()</FONT></TT> in <TT><FONT SIZE="-1">ptlsim.cpp</FONT></TT>
checks if the <TT><FONT SIZE="-1">inside_ptlsim</FONT></TT> variable has been set
by <TT><FONT SIZE="-1">ptlsim_preinit_entry</FONT></TT>, and if not, PTLsim enters
inject mode. In this mode, <TT><FONT SIZE="-1">ptlsim_inject()</FONT></TT> in <TT><FONT SIZE="-1">kernel.cpp</FONT></TT>
is called to effectively inject the <TT><FONT SIZE="-1">ptlsim</FONT></TT> binary
into another process and pass control to it before even the dynamic
linker gets to load the program. In <TT><FONT SIZE="-1">ptlsim_inject()</FONT></TT>,
the PTLsim process is forked and the child is placed under the parent's
control using <TT><FONT SIZE="-1">ptrace()</FONT></TT>. The child process then uses
<TT><FONT SIZE="-1">exec()</FONT></TT> to start the user program to simulate (this
can be either a 32-bit or 64-bit program). 

<P>
However, the user program starts in the stopped state, allowing <TT><FONT SIZE="-1">ptlsim_inject()</FONT></TT>
to use <TT><FONT SIZE="-1">ptrace()</FONT></TT> and related functions to inject either
32-bit or 64-bit boot loader code directly into the user program address
space, overwriting the entry point of the dynamic linker. This code,
derived from <TT><FONT SIZE="-1">injectcode.cpp</FONT></TT> (specifically compiled
as <TT><FONT SIZE="-1">injectcode-32bit.o</FONT></TT> and <TT><FONT SIZE="-1">injectcode-64bit.o</FONT></TT>)
is completely position independent. Its sole function is to map the
rest of <TT><FONT SIZE="-1">ptlsim</FONT></TT> into the user process address space
at virtual address <TT><FONT SIZE="-1">0x70000000</FONT></TT> and set up a special
<TT><FONT SIZE="-1">LoaderInfo</FONT></TT> structure to allow the master PTLsim process
and the user process to communicate. The boot code also restores the
old code at the dynamic linker entry point after relocating itself.
Finally, <TT><FONT SIZE="-1">ptlsim_inject()</FONT></TT> adjusts the user process
registers to start executing the boot code instead of the normal program
entry point, and resumes the user process.

<P>
At this point, the PTLsim image injected into the user process exists
in a bizarre environment: if the user program is 32 bit, the boot
code will need to switch to 64-bit mode before calling the 64-bit
PTLsim entrypoint. Fortunately x86-64 and the Linux kernel make this
process easy, despite never being used by normal programs: a regular
far jump switches the current code segment descriptor to <TT><FONT SIZE="-1">0x33</FONT></TT>,
effectively switching the instruction set to x86-64. For the most
part, the kernel cannot tell the difference between a 32-bit and 64-bit
process: as long as the code uses 64-bit system calls (i.e. <TT><FONT SIZE="-1">syscall</FONT></TT>
instruction instead of <TT><FONT SIZE="-1">int 0x80</FONT></TT> as with 32-bit system
calls), Linux assumes the process is 64-bit. There are some subtle
issues related to signal handling and memory allocation when performing
this trick, but PTLsim implements workarounds to these issues.

<P>
After entering 64-bit mode if needed, the boot code passes control
to PTLsim at <TT><FONT SIZE="-1">ptlsim_preinit_entry</FONT></TT>. The <TT><FONT SIZE="-1">ptlsim_preinit()</FONT></TT>
function checks for the special <TT><FONT SIZE="-1">LoaderInfo</FONT></TT> structure
on the stack and in the ELF header of PTLsim as modified by the boot
code; if these structures are found, PTLsim knows it is running inside
the user program address space. After setting up memory management
and threading, it captures any state the user process was initialized
with. This state is used to fill in fields in the global <TT><FONT SIZE="-1">ctx</FONT></TT>
structure of class <TT><FONT SIZE="-1">CoreContext</FONT></TT>: various floating point
related fields and the user program entry point and original stack
pointer are saved away at this point. If PTLsim is running inside
a 32-bit process, the 32-bit arguments, environment and kernel auxiliary
vector array (auxv) need to be converted to their 64-bit format for
PTLsim to be able to parse them from normal C/C++ code. Finally, control
is returned to <TT><FONT SIZE="-1">main()</FONT></TT> to allow the simulator to start
up normally.

<P>

<H1><A NAME="SECTION02340000000000000000">
Simulator Startup</A>
</H1>

<P>
In <TT><FONT SIZE="-1">ptlsim.cpp</FONT></TT>, the <TT><FONT SIZE="-1">main()</FONT></TT> function
calls <TT><FONT SIZE="-1">init_config()</FONT></TT> to read in the user program specific
configuration as described in Sections <A HREF="node4.html#sec:RunningPTLsim">2.2</A> and
<A HREF="node4.html#sec:ConfigurationOptions">2.3</A>, then starts up the various other
simulator subsystems. If one of the <TT><FONT SIZE="-1">-excludeld</FONT></TT> or
<TT><FONT SIZE="-1">-startrip</FONT></TT> options were given, a breakpoint is inserted
at the RIP address where the user process should switch from native
mode to simulation mode (this may be at the dynamic linker entry point
by default).

<P>
Finally, <TT><FONT SIZE="-1">switch_to_native_restore_context()</FONT></TT> is
called to restore the state that existed before PTLsim was injected
into the process and return to the dynamic linker entry point. This
may involve switching from 64-bit back to 32-bit mode to start executing
the user process natively as discussed in Section <A HREF="#sec:Injection">3.3</A>.

<P>
After native execution reaches the inserted breakpoint thunk code,
the code performs a 32-to-64-bit long jump back into PTLsim, which
promptly restores the code underneath the inserted breakpoint thunk.
At this point, the <TT><FONT SIZE="-1">switch_to_sim()</FONT></TT> function in <TT><FONT SIZE="-1">ptlsim.cpp</FONT></TT>
is invoked to actually begin the simulation. This is done by calling
<TT><FONT SIZE="-1">out_of_order_core_toplevel_loop()</FONT></TT> in ooocore.cpp.

<P>
At some point during simulation, the user program or the configuration
file may request a switch back to native mode for the remainder of
the program. In this case, the <TT><FONT SIZE="-1">show_stats_and_switch_to_native()</FONT></TT>
function gets called to save the statistics data store, map the PTLsim
internal state back to the x86 compatible external state and return
to the 32-bit or 64-bit user code, effectively removing PTLsim from
the loop.

<P>
While the real PTLsim user process is running, the original PTLsim
injector process simply waits in the background for the real user
program with PTLsim inside it to terminate, then returns its exit
code.

<P>

<H1><A NAME="SECTION02350000000000000000"></A><A NAME="sec:AddressSpaceSimulation"></A>
<BR>
Address Space Simulation
</H1>

<P>
PTLsim maintains the <TT><FONT SIZE="-1">AddressSpace</FONT></TT> class as global
variable <TT><FONT SIZE="-1">asp</FONT></TT> (see <TT><FONT SIZE="-1">kernel.cpp</FONT></TT>) to track
the attributes of each page within the virtual address space. To do
this, PTLsim uses Shadow Page Access Tables (SPATs), which are essentially
large two-level bitmaps. Since pages are 4096 bytes in size, each
64 kilobyte chunk of the bitmap can track 2 GB of virtual address
space. In each SPAT, each top level array entry points to a chunk
mapping 2 GB, such that with 131072 top level pointers, the full 48
bit virtual address space can typically be mapped with under a megabyte
of SPAT chunks, assuming the address space is sparse.

<P>
In the AddressSpace structure, there are separate SPAT tables for
readable pages (<TT><FONT SIZE="-1">readmap</FONT></TT> field), writable pages (<TT><FONT SIZE="-1">writemap</FONT></TT>
field) and executable pages (<TT><FONT SIZE="-1">execmap</FONT></TT> field). Two additional
SPATs, <TT><FONT SIZE="-1">dtlbmap</FONT></TT> and <TT><FONT SIZE="-1">itlbmap</FONT></TT>, are used
to track which pages are currently mapped by the simulated translation
lookaside buffers (TLBs); this is discussed further in Section <A HREF="node18.html#sec:TranslationLookasideBuffers">15.4</A>.

<P>
When running in native mode, PTLsim cannot track changes to the process
memory map made by native calls to <TT><FONT SIZE="-1">mmap()</FONT></TT>, <TT><FONT SIZE="-1">munmap()</FONT></TT>,
etc. Therefore, at every switch from native to simulation mode, the
<TT><FONT SIZE="-1">resync_with_process_maps()</FONT></TT> function is called.
This function parses the <TT><FONT SIZE="-1">/proc/self/maps</FONT></TT> metafile
maintained by the kernel to build a list of all regions mapped by
the current process. Using this list, the SPATs are rebuilt to reflect
the current memory map. This is absolutely critical for correct operation,
since during simulation, speculative loads and stores will only read
and write memory if the appropriate SPAT indicates the address is
accessible to user code. If the SPATs become out of sync with the
real memory map, PTLsim itself may crash rather than simply marking
the offending load or store as invalid. The <TT><FONT SIZE="-1">resync_with_process_maps()</FONT></TT>
function (or more specifically, the <TT><FONT SIZE="-1">mqueryall()</FONT></TT> helper
function) is fairly kernel version specific since the format of <TT><FONT SIZE="-1">/proc/self/maps</FONT></TT>
has changed between Linux 2.6.x kernels. New kernels may require updating
this function.

<P>
PTLsim does not use the normal C library implementations of <TT><FONT SIZE="-1">malloc()</FONT></TT>,
<TT><FONT SIZE="-1">free()</FONT></TT>, <TT><FONT SIZE="-1">mmap()</FONT></TT>, <TT><FONT SIZE="-1">new</FONT></TT>,
<TT><FONT SIZE="-1">delete</FONT></TT> and so on. Instead, PTLsim code should always
use the <TT><FONT SIZE="-1">ptl_alloc_private_pages()</FONT></TT> family of functions
defined in <TT><FONT SIZE="-1">kernel.cpp</FONT></TT> to ensure that PTLsim memory
remains completely invisible to user code (except, of course, within
PTLsim generated microcode sequences). This is done by clearing the
bits in the read, write and execute SPATs corresponding to the allocated
pages. The <TT><FONT SIZE="-1">new</FONT></TT>, <TT><FONT SIZE="-1">delete</FONT></TT>, <TT><FONT SIZE="-1">malloc()</FONT></TT>
and <TT><FONT SIZE="-1">free()</FONT></TT> functions can still be used since PTLsim
overrides these. Note that memory allocated in this way will <I>not</I>
be accessible to user code.

<P>

<H1><A NAME="SECTION02360000000000000000"></A><A NAME="sec:DebuggingHints"></A>
<BR>
Debugging Hints
</H1>

<P>
When adding or modifying PTLsim, bugs will invariably crop up. Fortunately,
PTLsim provides a trivial way to find the location of bugs which silently
corrupt program execution. Since PTLsim can transparently switch between
simulation and native mode, isolating the divergence point between
the simulated behavior and what a real reference machine would do
can be done through binary search. The <TT><FONT SIZE="-1">-stopinsns</FONT></TT>
configuration option can be set to stop simulation before the problem
occurs, then incremented until the first x86 instruction to break
the program is determined.

<P>
The out of order simulator (<TT><FONT SIZE="-1">ooocore.cpp</FONT></TT>) includes
extensive debugging and integrity checking assertions. These may be
turned off by default for improved performance, but they can be easily
re-enabled by defining the <TT><FONT SIZE="-1">ENABLE_CHECKS</FONT></TT> symbol at
the top of <TT><FONT SIZE="-1">ooocore.cpp</FONT></TT>. Additional check functions
are in the code but commented out; these may be used as well.

<P>
You can also debug PTLsim with <TT><FONT SIZE="-1">gdb</FONT></TT>, although the process
is non-standard due to PTLsim's co-simulation architecture:

<P>

<UL>
<LI>Start PTLsim on the target program like normal. Notice the <TT><FONT SIZE="-1">Thread</FONT></TT>
<TT><I><FONT SIZE="-1">N</FONT></I></TT> <TT><FONT SIZE="-1">is running in XX-bit mode</FONT></TT>
message printed at startup: this is the PID you will be debugging,
not the ``<TT><FONT SIZE="-1">ptlsim</FONT></TT>'' process that may also be running.
</LI>
<LI>Start GDB and type ``<TT><FONT SIZE="-1">attach 12345</FONT></TT>'' if <I>12345</I>
was the PID listed above
</LI>
<LI>Type ``<TT><FONT SIZE="-1">symbol-file ptlsim</FONT></TT>'' to load the PTLsim
internal symbols (otherwise gdb only knows about the benchmark code
itself). You should specify the full path to the PTLsim executable
here.
</LI>
<LI>You're now debugging PTLsim. If you run the ``<TT><FONT SIZE="-1">bt</FONT></TT>''
command to get a backtrace, it should show the PTLsim functions starting
at address 0x70000000.
</LI>
</UL>
If the backtrace does not display enough information, go to the <TT><FONT SIZE="-1">Makefile</FONT></TT>
and enable the &#34;no optimization&#34; options (the &#34;-O0&#34;
line instead of &#34;-O99&#34;) since that will make more
debugging information available to you.

<P>
The ``<TT><FONT SIZE="-1">-pause-at-startup</FONT></TT> <I>seconds</I>'' configuration
option may be useful here, to give you time to attach with a debugger
before starting the simulation.

<P>

<H1><A NAME="SECTION02370000000000000000"></A><A NAME="sec:Timing"></A>
<BR>
Timing Issues
</H1>

<P>
PTLsim uses the <TT><FONT SIZE="-1">CycleTimer</FONT></TT> class extensively to gather
data about its own performance using the CPU's timestamp counter.
At startup in <TT><FONT SIZE="-1">superstl.cpp</FONT></TT>, the CPU's maximum frequency
is queried from the appropriate Linux kernel sysfs node (if available)
or from <TT><FONT SIZE="-1">/proc/cpuinfo</FONT></TT> if not. Processors which dynamically
scale their frequency and voltage in response to load (like all Athlon
64 and K8 based AMD processors) require special handling. It is assumed
that the processor will be running at its maximum frequency (as reported
by sysfs) or a fixed frequency (as reported by <TT><FONT SIZE="-1">/proc/cpuinfo</FONT></TT>)
throughout the majority of the simulation time; otherwise the timing
results will be bogus.

<P>
<HR>
<!--Navigation Panel-->
<A NAME="tex2html330"
  HREF="node6.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html326"
  HREF="node2.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html320"
  HREF="node4.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html328"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html331"
  HREF="node6.html">Statistics Collection and Control</A>
<B> Up:</B> <A NAME="tex2html327"
  HREF="node2.html">PTLsim User's Guide</A>
<B> Previous:</B> <A NAME="tex2html321"
  HREF="node4.html">Getting Started with PTLsim</A>
 &nbsp; <B>  <A NAME="tex2html329"
  HREF="node1.html">Contents</A></B> 
<!--End of Navigation Panel-->
<ADDRESS>
Matt T Yourst
2005-12-02
</ADDRESS>
</BODY>
</HTML>
