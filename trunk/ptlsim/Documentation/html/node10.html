<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<!--Converted with LaTeX2HTML 2002-2-1 (1.70)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Fetch Stage</TITLE>
<META NAME="description" CONTENT="Fetch Stage">
<META NAME="keywords" CONTENT="PTLsimManual">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<META NAME="Generator" CONTENT="LaTeX2HTML v2002-2-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="PTLsimManual.css">

<LINK REL="next" HREF="node11.html">
<LINK REL="previous" HREF="node9.html">
<LINK REL="up" HREF="node8.html">
<LINK REL="next" HREF="node11.html">
</HEAD>

<BODY >
<!--Navigation Panel-->
<A NAME="tex2html477"
  HREF="node11.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html473"
  HREF="node8.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html467"
  HREF="node9.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html475"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html478"
  HREF="node11.html">Frontend and Key Structures</A>
<B> Up:</B> <A NAME="tex2html474"
  HREF="node8.html">Out of Order Processor</A>
<B> Previous:</B> <A NAME="tex2html468"
  HREF="node9.html">Introduction</A>
 &nbsp; <B>  <A NAME="tex2html476"
  HREF="node1.html">Contents</A></B> 
<BR>
<BR>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL>
<LI><A NAME="tex2html479"
  HREF="node10.html#SECTION03210000000000000000">Instruction Fetching and the Basic Block Cache</A>
<LI><A NAME="tex2html480"
  HREF="node10.html#SECTION03220000000000000000">Fetch Queue</A>
</UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION03200000000000000000">
Fetch Stage</A>
</H1>

<P>

<H1><A NAME="SECTION03210000000000000000"></A><A NAME="sec:FetchStage"></A>
<BR>
Instruction Fetching and the Basic Block Cache
</H1>

<P>
As described in Section <A HREF="node7.html#sec:UopIntro">5.1</A>, x86 instructions are
decoded into transops prior to actual execution by the out of order
core. Some processors do this translation as x86 instructions are
fetched from an L1 instruction cache, while others use a trace cache
to store pre-decoded uops. PTLsim takes a middle ground to allow maximum
simulation flexibility. Specifically, the Fetch stage accesses the
L1 instruction cache and stalls on cache misses as if it were fetching
several variable length x86 instructions per cycle. However, actually
decoding x86 instructions into uops over and over again during simulation
would be extraordinarily slow. 

<P>
Therefore, for <I>simulation purposes only</I>, PTLsim maintains a
<I>basic block cache</I> containing the program ordered translated
uop (<I>transop</I>) sequence for previously decoded basic blocks
in the program. Each basic block (<TT><FONT SIZE="-1">BasicBlock</FONT></TT> structure)
consists of up to 64 transops and is terminated by either a control
flow operation (conditional, unconditional, indirect branch) or a
barrier operation (e.g. system call, synchronizing instruction, etc).
During the fetch process (implemented in the <TT><FONT SIZE="-1">fetch()</FONT></TT>
function), PTLsim looks up the current RIP to fetch from and uses
the basic block cache to map that RIP to a BasicBlock structure. The
transop stream is then read from that decoded basic block in lieu
of decoding the x86 instructions again. As execution runs off the
end of each decoded basic block, the fetch unit checks if the next
RIP exists in the basic block cache. If so, the next block is streamed
into the fetch queue. Otherwise, the x86-to-transop translator is
called via <TT><FONT SIZE="-1">translate_basic_block()</FONT></TT> to translate
an entire basic block at the current RIP before resuming execution.
Since the basic block cache is for simulation purposes only, this
adds no additional cycles to the simulated program.

<P>
An additional optimization, called <I>synthesis</I>, is also used:
each uop in the basic block is mapped to the address of a native PTLsim
function implementing the semantics of that uop. This saves us from
having to use a large jump table later on, and can map uops to pre-compiled
templates that avoid nearly all further decoding of the uop during
execution.

<P>

<H1><A NAME="SECTION03220000000000000000">
Fetch Queue</A>
</H1>

<P>
Each transop fetched into the pipeline is immediately assigned a monotonically
increasing <I>uuid</I> (universally unique identifier) to uniquely
track it for debugging and statistical purposes. The fetch unit attaches
additional information to each transop (such as the uop's uuid and
the RIP of the corresponding x86 instruction) to form a <TT><FONT SIZE="-1">FetchBufferEntry</FONT></TT>
structure. This fetch buffer is then placed into the fetch queue (<TT><FONT SIZE="-1">fetchq</FONT></TT>)
assuming it isn't full (if it is, the fetch stage stalls). As the
fetch unit encounters transops with their EOM (end of macro-op) bit
set, the fetch RIP is advanced to the next x86 instruction according
to the instruction length stored in the SOM transop.

<P>
Branch uops trigger the branch prediction mechanism used to select
the next fetch RIP. Based on various information encoded in the branch
transop and the next RIP <I>after</I> the x86 instruction containing
the branch, the <TT><FONT SIZE="-1">branchpred.predict()</FONT></TT> function is used
to redirect fetching. If the branch is predicted not taken, the sense
of the branch's condition code is inverted and the transop's <TT><FONT SIZE="-1">riptaken</FONT></TT>
and <TT><FONT SIZE="-1">ripseq</FONT></TT> fields are swapped; this ensures all branches
are considered correct only if taken. Indirect branches (jumps) have
their <TT><FONT SIZE="-1">riptaken</FONT></TT> field overwritten by the predicted
target address.

<P>
<HR>
<!--Navigation Panel-->
<A NAME="tex2html477"
  HREF="node11.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html473"
  HREF="node8.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html467"
  HREF="node9.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html475"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html478"
  HREF="node11.html">Frontend and Key Structures</A>
<B> Up:</B> <A NAME="tex2html474"
  HREF="node8.html">Out of Order Processor</A>
<B> Previous:</B> <A NAME="tex2html468"
  HREF="node9.html">Introduction</A>
 &nbsp; <B>  <A NAME="tex2html476"
  HREF="node1.html">Contents</A></B> 
<!--End of Navigation Panel-->
<ADDRESS>
Matt T Yourst
2005-12-02
</ADDRESS>
</BODY>
</HTML>
