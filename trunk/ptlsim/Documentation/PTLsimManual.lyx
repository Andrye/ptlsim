#LyX 1.3 created this file. For more info see http://www.lyx.org/
\lyxformat 221
\textclass report
\begin_preamble
\usepackage[pdftitle={PTLsim User's Guide and Reference},colorlinks=true,linkcolor=blue]{hyperref}
\end_preamble
\language english
\inputencoding auto
\fontscheme times
\graphics default
\paperfontsize 11
\spacing single 
\papersize letterpaper
\paperpackage a4
\use_geometry 1
\use_amsmath 0
\use_natbib 0
\use_numerical_citations 0
\paperorientation portrait
\leftmargin 0.75in
\topmargin 0.75in
\rightmargin 0.75in
\bottommargin 0.75in
\headheight 0in
\headsep 0in
\footskip 0in
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\quotes_language english
\quotes_times 2
\papercolumns 1
\papersides 1
\paperpagestyle default

\layout Standard
\noindent \align center 

\series bold 
\size huge 
\SpecialChar ~

\layout Standard
\added_space_top vfill \noindent \align center 

\family sans 
\series bold 
\size giant 
PTLsim User's Guide and Reference
\layout Standard
\added_space_bottom bigskip \noindent \align center 

\size huge 
\emph on 
The Anatomy of an x86-64 Out of Order Microprocessor
\layout Standard
\noindent \align center 

\size largest 
Matt T.
 Yourst
\newline 

\family typewriter 
\size large 
<yourst@yourst.com>
\layout Standard
\noindent \align center 
Revision 20060226
\layout Standard
\added_space_top vfill \noindent \align center 
The latest version of PTLsim and this document are always available at:
\family sans 
\series bold 
\size largest 

\newline 

\newline 
www.ptlsim.org
\layout Standard
\added_space_top bigskip \noindent \align center 

\begin_inset Formula $\copyright$
\end_inset 

 1999-2006 Matt T.
 Yourst 
\family typewriter 
\size small 
<yourst@yourst.com>
\family default 
\size default 
.
\layout Standard
\noindent \align center 
The PTLsim software and manual are free software;
\newline 
they are licensed under the GNU General Public License version 2.
\layout Standard


\begin_inset LatexCommand \tableofcontents{}

\end_inset 


\layout Part


\begin_inset LatexCommand \label{part:Introduction}

\end_inset 

PTLsim User's Guide
\layout Chapter

Introducing PTLsim
\layout Section

Introducing PTLsim
\layout Standard


\series bold 
PTLsim
\series default 
 is a state of the art cycle accurate microprocessor simulator and virtual
 machine for the x86 and x86-64 instruction sets.
 This release of PTLsim models a modern speculative out of order x86-64
 compatible processor core, cache hierarchy and supporting hardware.
\layout Standard

PTLsim is very different from most cycle accurate simulators used in research
 applications.
 It runs directly on the same platform it is simulating (an x86 machine
 running Linux) and is able to switch in and out of full out of order simulation
 mode and native x86 or x86-64 mode at any time completely transparent to
 the running user code.
 This lets users quickly profile a small section of the user code without
 the overhead of emulating the uninteresting parts.
 It is also capable of switching between 32-bit and 64-bit threads on the
 fly.
\layout Standard

Compared to competing simulators, PTLsim provides extremely high performance
 even when running in full cycle accurate out of order simulation mode.
 Through extensive tuning, cache profiling and the use of x86 specific accelerat
ed vector operations and instructions, PTLsim significantly cuts simulation
 time compared to traditional research simulators.
 Even with its optimized core, PTLsim still allows a significant amount
 of flexibility for easy experimentation through the use of optimized C++
 template classes and libraries suited to synchronous logic design.
 We have successfully run a wide array of programs under PTLsim, from typical
 benchmarks to graphical applications and network servers.
\layout Section

History
\layout Standard

PTLsim was designed and developed by Matt T.
 Yourst 
\family typewriter 
\size small 
<yourst@yourst.com>
\family default 
\size default 
 with its beginnings dating back to 2001.
 The main PTLsim code base, including the out of order processor model,
 has been in active development since 2003 and has been used extensively
 by our processor design research group at the State University of New York
 at Binghamton in addition to many other academic and industry organizations.
\layout Standard

PTLsim is not related to other widely used simulators.
 It is our hope that PTLsim will help microprocessor researchers move to
 a contemporary and widely used instruction set (x86 and x86-64) with readily
 available hardware implementations.
 This will provide a new option for researchers stuck with simulation tools
 supporting only the Alpha or MIPS based instruction sets, both of which
 have since been discontinued on real commercially available hardware (making
 co-simulation impossible) with an uncertain future in up to date compiler
 toolchains.
\layout Standard

The PTLsim software and this manual are free software, licensed under the
 GNU General Public License version 2.
\layout Section

Documentation Roadmap
\layout Standard

This manual has been divided into several parts:
\layout Itemize

Part 
\begin_inset LatexCommand \ref{part:Introduction}

\end_inset 

 introduces PTLsim and describes its structure and operation
\layout Itemize

Part 
\begin_inset LatexCommand \ref{part:OutOfOrderModel}

\end_inset 

 details the design and implementation of the PTLsim out of order core model
\layout Itemize

Part 
\begin_inset LatexCommand \ref{part:Appendices}

\end_inset 

 is a reference manual for the PTLsim internal uop instruction set, the
 performance monitoring events the simulator supports and a variety of other
 technical information.
\layout Section

Additional Resources
\layout Standard

The latest version of PTLsim and this document are always available at the
 PTLsim web site:
\layout Quote


\family sans 
\series bold 
\size large 
http://www.ptlsim.org
\layout Chapter

Getting Started with PTLsim
\layout Section

Building PTLsim
\layout Standard

PTLsim is written in C++ with extensive use of x86 and x86-64 inline assembly
 code for performance and virtualization purposes.
 In its present release, it is designed for use on both x86 and x86-64 host
 systems running Linux 2.6.
\layout Itemize

PTLsim can be built on 
\series bold 
both 64-bit x86-64 machines
\series default 
 (AMD Athlon 64 / Opteron / Turion, Intel Pentium 4 with EM64T and future
 Pentium M models) 
\series bold 
as well as ordinary 32-bit x86 systems
\series default 
.
 If built for x86-64, PTLsim will run both 64-bit and 32-bit programs automatica
lly.
 If built on a 32-bit Linux distribution and compiler, PTLsim only supports
 ordinary x86 programs and will typically be 
\series bold 
slower than the 64-bit build
\series default 
, even on 32-bit user programs.
\layout Itemize

PTLsim is very sensitive to the 
\series bold 
Linux kernel
\series default 
 version it is running on.
 We have tested this version of PTLsim on stock 2.6.12 to 2.6.15 kernels (SMP
 and uniprocessor), but it may break on earlier versions due to changes
 in certain undocumented system calls and structures we use for virtualization
 purposes.
 Section 
\begin_inset LatexCommand \ref{sec:PTLsimInternals}

\end_inset 

 gives more information on this.
 
\layout Itemize


\series bold 
gcc 3.4.x
\series default 
 should be used to compile the code, as this is the only version we have
 tested.
 Initial versions of gcc 4.0 mis-compile PTLsim, although later versions
 may work.
 Earlier gcc versions (prior to 3.3) may not accept certain low level extensions
 (C++ and inline assembly constructs) used within PTLsim.
\layout Itemize

PTLsim should also work on 
\series bold 
Intel based x86-64
\series default 
 (a.k.a.
 EM64T) capable processors, although we have not tried this.
 You will need to adjust the Makefile options to specify this (i.e.
 to use 
\family typewriter 
\size small 
-march=nocona
\family default 
\size default 
 instead of 
\family typewriter 
\size small 
-march=k8
\family default 
\size default 
).
\layout Standard

To build PTLsim, unpack the sources (or obtain them via CVS checkout) and
 just run 
\family typewriter 
\size small 
make
\family default 
\size default 
 (on a multiprocessor machine, you may wish to use 
\family typewriter 
\size small 
make -j2
\family default 
\size default 
).
 By default, the 
\family typewriter 
\size small 
Makefile
\family default 
\size default 
 specifies maximum optimization for an AMD x86-64 machine, so compilation
 may be slow.
 For debugging purposes only, the 
\family typewriter 
\size small 
Makefile
\family default 
\size default 
 line specifying 
\begin_inset Quotes eld
\end_inset 


\family typewriter 
\size small 
-O0 -g3
\family default 
\size default 

\begin_inset Quotes erd
\end_inset 

 (no optimization, all debugging info) may be used, but this will make PTLsim
 
\emph on 
very
\emph default 
 slow.
\layout Section


\begin_inset LatexCommand \label{sec:RunningPTLsim}

\end_inset 

Running PTLsim
\layout Standard

PTLsim invocation is very simple: after compiling the simulator and making
 sure the 
\family typewriter 
\size small 
ptlsim
\family default 
\size default 
 executable is in your path, simply run:
\layout Quote


\family typewriter 
\size small 
ptlsim\SpecialChar ~

\family default 
\size default 
 
\emph on 
full-path-to-executable
\emph default 
 
\emph on 
arguments...
\layout Standard

PTLsim reads configuration options for running various user programs by
 looking for a configuration file named 
\family typewriter 
\size small 
/home/
\family default 
\size default 
\emph on 
username
\family typewriter 
\size small 
\emph default 
/.ptlsim/
\family default 
\size default 
\emph on 
path/to/program/executablename
\family typewriter 
\size small 
\emph default 
.conf
\family default 
\size default 
.
 To set options for each program, you'll need to create a directory of the
 form 
\family typewriter 
\size small 
/home/
\family default 
\size default 
\emph on 
username
\family typewriter 
\size small 
\emph default 
/.ptlsim
\family default 
\size default 
 and make sub-directories under it corresponding to the full path to the
 program.
 For example, to configure 
\family typewriter 
\size small 
/bin/ls
\family default 
\size default 
 you'll need to run "
\family typewriter 
\size small 
mkdir /home/
\family default 
\size default 
\emph on 
username
\family typewriter 
\size small 
\emph default 
/.ptlsim/bin
\family default 
\size default 

\begin_inset Quotes erd
\end_inset 

 and then edit "
\family typewriter 
\size small 
/home/
\family default 
\size default 
\emph on 
username
\family typewriter 
\size small 
\emph default 
/.ptlsim/bin/ls.conf
\family default 
\size default 
" with the appropriate options.
 For example, try putting the following in 
\family typewriter 
\size small 
ls.conf
\family default 
\size default 
 as described:
\layout Quote


\family typewriter 
\size small 
-logfile ls.ptlsim -loglevel 9 -stats ls.stats -stopinsns 10000
\layout Standard

Then run:
\layout Quote


\family typewriter 
\size small 
ptlsim /bin/ls -la
\layout Standard

PTLsim should display its system information banner, then the output of
 simulating the directory listing.
 With the options above, PTLsim will simulate 
\family typewriter 
\size small 
/bin/ls
\family default 
\size default 
 starting at the first x86 instruction in the dynamic linker's entry point,
 run until 10000 x86 instructions have been committed, and will then switch
 back to native mode (i.e.
 the user code will run directly on the real processor) until the program
 exits.
 During this time, it will compile an extensive log of the state of every
 micro-operation executed by the processor and will save it to 
\begin_inset Quotes eld
\end_inset 


\family typewriter 
\size small 
ls.ptlsim
\family default 
\size default 

\begin_inset Quotes erd
\end_inset 

 in the current directory.
 It will also create 
\begin_inset Quotes eld
\end_inset 


\family typewriter 
\size small 
ls.stats
\family default 
\size default 

\begin_inset Quotes erd
\end_inset 

, a binary file containing snapshots of PTLsim's internal performance counters.
 The 
\family typewriter 
\size small 
ptlstats
\family default 
\size default 
 program can be used to print and analyze these statistics by running 
\begin_inset Quotes eld
\end_inset 


\family typewriter 
\size small 
ptlstats ls.stats
\family default 
\size default 

\begin_inset Quotes erd
\end_inset 

.
\layout Section


\begin_inset LatexCommand \label{sec:ConfigurationOptions}

\end_inset 

Configuration Options
\layout Standard

PTLsim supports a variety of options in the configuration file of each program;
 you can run "ptlsim" without arguments to get a full list of these options.
 The options described below are used to control which code PTLsim executes
 and how it profiles it.
 The default value for each option is shown in [brackets] at the end of
 the description.
\layout List
\labelwidthstring WWWWWWWW


\series bold 
\emph on 
Logging:
\layout List
\labelwidthstring WWWWWWWW


\series bold 
-quiet
\series default 
 Do not print PTLsim system information banner [disabled]
\layout List
\labelwidthstring WWWWWWWW


\series bold 
-logfile\SpecialChar ~

\series default 
\emph on 
file
\emph default 
 Log filename 
\emph on 
file
\emph default 
 (use /dev/fd/1 for stdout, /dev/fd/2 for stderr) [(none)]
\layout List
\labelwidthstring WWWWWWWW


\series bold 
-loglevel\SpecialChar ~

\series default 
\emph on 
N
\emph default 
 Log level 
\emph on 
N
\emph default 
.
 Higher levels provide a breakdown of every operation in every stage of
 the pipeline; 
\begin_inset Quotes eld
\end_inset 

0
\begin_inset Quotes erd
\end_inset 

 disables all logging except startup messages and system call tracing [0]
\layout List
\labelwidthstring WWWWWWWW


\series bold 
-startlog\SpecialChar ~

\series default 
\emph on 
N
\emph default 
 Start logging after cycle 
\emph on 
N
\emph default 
 [infinity]
\layout List
\labelwidthstring WWWWWWWW


\series bold 
\emph on 
Statistics\SpecialChar ~
Collection:
\layout List
\labelwidthstring WWWWWWWW


\series bold 
-stats\SpecialChar ~

\series default 
\emph on 
file
\emph default 
 Statistics filename 
\emph on 
file
\emph default 
 [(none)]
\layout List
\labelwidthstring WWWWWWWW


\series bold 
-snapshot\SpecialChar ~

\series default 
\emph on 
N
\emph default 
 Take statistical snapshot and reset counters every 
\emph on 
N
\emph default 
 cycles [infinite]
\layout List
\labelwidthstring WWWWWWWW


\series bold 
\emph on 
Simulation\SpecialChar ~
Start\SpecialChar ~
Point:
\layout List
\labelwidthstring WWWWWWWW


\series bold 
-startrip
\series default 
\SpecialChar ~

\emph on 
addr
\emph default 
 Start at RIP address 
\emph on 
startrip
\emph default 
 [(none)]
\layout List
\labelwidthstring WWWWWWWW


\series bold 
-startrepeat
\series default 
\SpecialChar ~

\emph on 
N
\emph default 
 Start after passing start RIP at least 
\emph on 
N
\emph default 
 times [(none)]
\layout List
\labelwidthstring WWWWWWWW


\series bold 
-excludeld
\series default 
 Exclude dynamic linker execution (start at 
\family typewriter 
\size small 
main()
\family default 
\size default 
 instead) [disabled]
\layout List
\labelwidthstring WWWWWWWW


\series bold 
-trigger
\series default 
 Trigger mode: wait for user process to use special function 
\family typewriter 
\size small 
ptlcall_switch_to_sim()
\family default 
\size default 
 before entering simulation mode [disabled].
 This is described in Section 
\begin_inset LatexCommand \ref{sec:TriggerMode}

\end_inset 

.
\layout List
\labelwidthstring WWWWWWWW


\series bold 
\emph on 
Simulation\SpecialChar ~
Stop\SpecialChar ~
Point:
\layout List
\labelwidthstring WWWWWWWW


\series bold 
-stop\SpecialChar ~

\series default 
\emph on 
N
\emph default 
 Stop after 
\emph on 
N
\emph default 
 instructions [infinity]
\layout List
\labelwidthstring WWWWWWWW


\series bold 
-stoprip
\series default 
\SpecialChar ~

\emph on 
addr
\emph default 
 Stop before basic block RIP 
\emph on 
addr
\emph default 
 is translated for the first time [0]
\layout List
\labelwidthstring WWWWWWWW


\series bold 
-bbinsns\SpecialChar ~

\series default 
\emph on 
N
\emph default 
 In final basic block, only translate 
\emph on 
N
\emph default 
 user instructions [infinity]
\layout List
\labelwidthstring WWWWWWWW


\series bold 
-stopinsns\SpecialChar ~

\series default 
\emph on 
N
\emph default 
 Stop after committing 
\emph on 
N
\emph default 
 user instructions [infinity]
\layout List
\labelwidthstring WWWWWWWW


\series bold 
-flushevery\SpecialChar ~

\series default 
\emph on 
N
\emph default 
 Flush pipeline after every 
\emph on 
N
\emph default 
 user instructions commit [infinity]
\layout List
\labelwidthstring WWWWWWWW


\series bold 
\emph on 
Sequential\SpecialChar ~
and\SpecialChar ~
Native\SpecialChar ~
Control:
\layout List
\labelwidthstring WWWWWWWW


\series bold 
-seq\SpecialChar ~

\series default 
\emph on 
N
\emph default 
 Run 
\emph on 
N
\emph default 
 x86 instructions on the sequential simulator prior to switching to the
 out of order core [0] (see Section 
\begin_inset LatexCommand \ref{sec:SequentialMode}

\end_inset 

)
\layout List
\labelwidthstring WWWWWWWW


\series bold 
-profonly
\series default 
 Profile user code in native mode only using CPU performance counters; don't
 simulate anything [disabled]
\layout List
\labelwidthstring WWWWWWWW


\series bold 
-exitend
\series default 
 Kill the thread after full simulation completes rather than going native
 [disabled]
\layout List
\labelwidthstring WWWWWWWW


\series bold 
\emph on 
Debugging:
\layout List
\labelwidthstring WWWWWWWW


\series bold 
-dumpcode\SpecialChar ~

\series default 
\emph on 
file
\emph default 
 Save page of user code at final RIP to 
\emph on 
file
\emph default 
 [(none)]
\layout List
\labelwidthstring WWWWWWWW


\series bold 
-overshoot-and-dump
\series default 
 Set breakpoint and dump core after first instruction executed on return
 to native mode (to debug translation against real machine)
\layout List
\labelwidthstring WWWWWWWW


\series bold 
-pause-at-startup
\series default 
 Pause for N seconds at startup to let a debugger attach [disabled] (see
 Section 
\begin_inset LatexCommand \ref{sec:DebuggingHints}

\end_inset 

)
\layout List
\labelwidthstring WWWWWWWW


\series bold 
-perfect-cache
\series default 
 Perfect cache hit rate [disabled]
\layout List
\labelwidthstring WWWWWWWW


\series bold 
-ooo
\series default 
 Use out of order core [always enabled]
\layout Standard


\series bold 
\emph on 
NOTE: 
\series default 
\emph default 
If you use the "
\family typewriter 
\size small 
-logfile
\family default 
\size default 
" option, 
\series bold 
do not run it forever by accident
\series default 
 since the log files will go on for gigabytes! Use 
\family typewriter 
\size small 
-startlog
\family default 
\size default 
 and 
\family typewriter 
\size small 
-stop
\family default 
\size default 
 to limit the logged range.
 
\layout Standard


\series bold 
\emph on 
NOTE:
\series default 
\emph default 
 To actually modify the microarchitecture of the simulated processor, you
 will need to edit the source code and recompile.
\layout Chapter


\begin_inset LatexCommand \label{sec:PTLsimInternals}

\end_inset 

PTLsim Internals
\layout Section

Overview
\layout Standard

The following is an overview of the source files for PTLsim:
\layout Itemize


\family typewriter 
\series bold 
\size small 
ooocore.cpp
\family default 
\series default 
\size default 
 is the out of order simulator itself.
 The microarchitectural model implemented by this simulator is the subject
 of Part 
\begin_inset LatexCommand \ref{part:OutOfOrderModel}

\end_inset 

.
\layout Itemize


\family typewriter 
\series bold 
\size small 
ptlhwdef.cpp
\family default 
\series default 
\size default 
 and 
\family typewriter 
\series bold 
\size small 
ptlhwdef.h
\family default 
\series default 
\size default 
 define the basic uop encodings, flags and registers.
 The tables of uops might be interesting to see how a modern x86 processor
 is designed at the microcode level.
 The basic format is discussed in Section 
\begin_inset LatexCommand \ref{sec:UopIntro}

\end_inset 

; all uops are documented in Section 
\begin_inset LatexCommand \ref{sec:UopReference}

\end_inset 

.
\layout Itemize


\family typewriter 
\series bold 
\size small 
ooohwdef.h
\family default 
\series default 
\size default 
 defines the parameters of the out of order processor model not intrinsic
 to the PTLsim uop instruction set itself.
\layout Itemize


\family typewriter 
\series bold 
\size small 
translate-x86.cpp
\family default 
\series default 
\size default 
 is where the x86 and x86-64 to uop translation takes place.
 It is complicated and generally you shouldn't need to deal with this code
 to use or modify the simulator.
\layout Itemize


\family typewriter 
\series bold 
\size small 
dcache.cpp
\family default 
\series default 
\size default 
 and 
\family typewriter 
\series bold 
\size small 
dcache.h
\family default 
\series default 
\size default 
 and 
\family typewriter 
\series bold 
\size small 
dcacheint.h
\family default 
\series default 
\size default 
 contain the data cache model.
 At present the full L1/L2/L3/mem hierarchy is modeled.
 Note that the instruction cache is missing at this point, but will be added
 back in very soon.
 For SPEC this does not matter very much.
 The cache hierarchy is very flexible configuration wise; it is described
 further in Section 
\begin_inset LatexCommand \ref{sec:CacheHierarchy}

\end_inset 

.
\layout Itemize


\family typewriter 
\series bold 
\size small 
kernel.cpp
\family default 
\series default 
\size default 
 and 
\family typewriter 
\series bold 
\size small 
kernel.h
\family default 
\series default 
\size default 
 is where all the virtual machine "black magic" takes place to let PTLsim
 transparently switch between simulation and native mode and 32-bit/64-bit
 mode (or only 32-bit mode on a 32-bit x86 machine).
 In general you should not need to touch this since it is very Linux kernel
 specific (this version works with 2.6.12 - 2.6.14) and works at a level below
 the standard C/C++ libraries.
\layout Itemize


\family typewriter 
\series bold 
\size small 
branchpred.cpp
\family default 
\series default 
\size default 
 and 
\family typewriter 
\series bold 
\size small 
branchpred.h
\family default 
\series default 
\size default 
 is the branch predictor.
 Currently this is set up as a hybrid bimodal and history based predictor
 with various customizable parameters.
\layout Itemize


\family typewriter 
\series bold 
\size small 
logic.h
\family default 
\series default 
\size default 
 is a library of C++ templates for implementing synchronous logic structures
 like associative arrays, queues, register files, etc.
 It has some very clever features like 
\family typewriter 
\size small 
FullyAssociativeArray8bit
\family default 
\size default 
, which uses x86 SSE vector instructions to associatively match and process
 ~16 byte-sized tags every cycle.
 These classes are fully parameterized and useful for all kinds of simulations.
\layout Itemize


\family typewriter 
\series bold 
\size small 
globals.h
\family default 
\series default 
\size default 
, 
\family typewriter 
\series bold 
\size small 
superstl.h
\family default 
\series default 
\size default 
 and 
\family typewriter 
\series bold 
\size small 
superstl.cpp
\family default 
\series default 
\size default 
 implement various standard library functions and classes as an alternative
 to C++ STL.
 These libraries also contain a number of features very useful for bit manipulat
ion.
\layout Itemize


\family typewriter 
\series bold 
\size small 
uopimpl.cpp
\family default 
\series default 
\size default 
 contains implementations of all uops and their variations.
 PTLsim implements most ALU and floating point uops in assembly language
 so as to leverage the exact semantics and flags generated by real x86 instructi
ons, since most PTLsim uops are so similar to the equivalent x86 instructions.
 When compiled on a 32-bit system, some of the 64-bit uops must be emulated
 using slower C++ code.
\layout Itemize


\family typewriter 
\series bold 
\size small 
ptlsim.cpp
\family default 
\series default 
\size default 
 and 
\family typewriter 
\series bold 
\size small 
ptlsim.h
\family default 
\series default 
\size default 
 are responsible for initializing PTLsim and starting the appropriate simulation
 core code.
\layout Itemize


\family typewriter 
\series bold 
\size small 
config.cpp
\family default 
\series default 
\size default 
 and 
\family typewriter 
\series bold 
\size small 
config.h
\family default 
\series default 
\size default 
 manage the PTLsim configuration options for each user program.
\layout Itemize


\family typewriter 
\series bold 
\size small 
datastore.cpp
\family default 
\series default 
\size default 
 and 
\family typewriter 
\series bold 
\size small 
datastore.h
\family default 
\series default 
\size default 
 manage the PTLsim statistics data store file structure.
\layout Itemize


\family typewriter 
\series bold 
\size small 
lowlevel-64bit.S
\family default 
\series default 
\size default 
 contains 64-bit startup and context switching code.
 PTLsim execution starts here if run on an x86-64 system.
\layout Itemize


\family typewriter 
\series bold 
\size small 
lowlevel-32bit.S
\family default 
\series default 
\size default 
 contains 32-bit startup and context switching code.
 PTLsim execution starts here if run on a 32-bit x86 system.
\layout Itemize


\family typewriter 
\series bold 
\size small 
injectcode.cpp
\family default 
\series default 
\size default 
 is compiled into the 32-bit and 64-bit code injected into the target process
 to map the 
\family typewriter 
\size small 
ptlsim
\family default 
\size default 
 binary and pass control to it.
\layout Itemize


\family typewriter 
\series bold 
\size small 
loader.h
\family default 
\series default 
\size default 
 is used to pass information to the injected boot code.
\layout Itemize


\family typewriter 
\series bold 
\size small 
ptlstats.cpp
\family default 
\series default 
\size default 
 is a utility for printing and analyzing the statistics data store files
 in various human readable ways.
\layout Itemize


\family typewriter 
\series bold 
\size small 
cpuid.cpp
\family default 
\series default 
\size default 
 is a utility program to show various data returned by the x86 
\family typewriter 
\size small 
cpuid
\family default 
\size default 
 instruction.
 Run it under PTLsim for a surprise.
\layout Itemize


\family typewriter 
\series bold 
\size small 
genoffsets.cpp
\family default 
\series default 
\size default 
 is a utility program used during the build process to give the assembly
 language code the offsets of various C++ structure fields.
\layout Itemize


\family typewriter 
\series bold 
\size small 
ptlcalls.c
\family default 
\series default 
\size default 
 and 
\family typewriter 
\series bold 
\size small 
ptlcalls.h
\family default 
\series default 
\size default 
 are optionally compiled into user programs to let them switch into and
 out of simulation mode on their own.
 The 
\family typewriter 
\series bold 
\size small 
ptlcalls.o
\family default 
\series default 
\size default 
 file is typically linked with Fortran programs that can't use regular C
 header files.
\layout Section

Common Libraries and Logic Design APIs
\layout Standard

PTLsim includes a number of powerful C++ templates, macros and functions
 not found anywhere else.
 This section attempts to provide an overview of these structures so that
 users of PTLsim will use them instead of trying to duplicate work we've
 already done.
\layout Subsection

General Purpose Macros
\layout Standard

The file 
\family typewriter 
\size small 
globals.h
\family default 
\size default 
 contains a wide range of very useful definitions, functions and macros
 we have accumulated over the years, including:
\layout Itemize

Basic data types used throughout PTLsim (e.g.
 W64 for 64-bit words and so on), 
\family typewriter 
\size small 
globals.h
\family default 
\size default 
 defines a
\layout Itemize

Type safe C++ template based functions, including 
\family typewriter 
\size small 
min
\family default 
\size default 
, 
\family typewriter 
\size small 
max
\family default 
\size default 
, 
\family typewriter 
\size small 
abs
\family default 
\size default 
, 
\family typewriter 
\size small 
mux
\family default 
\size default 
, etc.
\layout Itemize

Iterator macros (
\family typewriter 
\size small 
foreach
\family default 
\size default 
) 
\layout Itemize

Template based metaprogramming functions including 
\family typewriter 
\size small 
lengthof
\family default 
\size default 
 (finds the length of any static array) and 
\family typewriter 
\size small 
log2
\family default 
\size default 
 (takes the base-2 log of any constant at compile time)
\layout Itemize

Floor, ceiling and masking functions for integers and powers of two (
\family typewriter 
\size small 
floor
\family default 
\size default 
, 
\family typewriter 
\size small 
trunc
\family default 
\size default 
, 
\family typewriter 
\size small 
ceil
\family default 
\size default 
, 
\family typewriter 
\size small 
mask
\family default 
\size default 
, 
\family typewriter 
\size small 
floorptr
\family default 
\size default 
, 
\family typewriter 
\size small 
ceilptr
\family default 
\size default 
, 
\family typewriter 
\size small 
maskptr
\family default 
\size default 
, 
\family typewriter 
\size small 
signext
\family default 
\size default 
, etc)
\layout Itemize

Bit manipulation macros (
\family typewriter 
\size small 
bit
\family default 
\size default 
, 
\family typewriter 
\size small 
bitmask
\family default 
\size default 
, 
\family typewriter 
\size small 
bits
\family default 
\size default 
, 
\family typewriter 
\size small 
lowbits
\family default 
\size default 
, 
\family typewriter 
\size small 
setbit
\family default 
\size default 
, 
\family typewriter 
\size small 
clearbit
\family default 
\size default 
, 
\family typewriter 
\size small 
assignbit
\family default 
\size default 
).
 Note that the 
\family typewriter 
\size small 
bitvec
\family default 
\size default 
 template (see below) should be used in place of these macros wherever it
 is more convenient.
\layout Itemize

Comparison functions (
\family typewriter 
\size small 
aligned
\family default 
\size default 
, 
\family typewriter 
\size small 
strequal
\family default 
\size default 
, 
\family typewriter 
\size small 
inrange
\family default 
\size default 
, 
\family typewriter 
\size small 
clipto
\family default 
\size default 
)
\layout Itemize

Modulo arithmetic (
\family typewriter 
\size small 
add_index_modulo
\family default 
\size default 
, 
\family typewriter 
\size small 
modulo_span
\family default 
\size default 
, et al)
\layout Itemize

Definitions of basic x86 SSE vector functions (e.g.
 
\family typewriter 
\size small 
x86_cpu_pcmpeqb
\family default 
\size default 
 et al)
\layout Itemize

Definitions of basic x86 assembly language functions (e.g.
 
\family typewriter 
\size small 
x86_bsf64
\family default 
\size default 
 et al)
\layout Itemize

A full suite of bit scanning functions (
\family typewriter 
\size small 
lsbindex
\family default 
\size default 
, 
\family typewriter 
\size small 
msbindex
\family default 
\size default 
, 
\family typewriter 
\size small 
popcount
\family default 
\size default 
 et al)
\layout Itemize

Miscellaneous functions (
\family typewriter 
\size small 
arraycopy
\family default 
\size default 
, 
\family typewriter 
\size small 
setzero
\family default 
\size default 
, etc)
\layout Subsection

Super Standard Template Library (SuperSTL)
\layout Standard

The Super Standard Template Library (SuperSTL) is an internal C++ library
 we use internally in lieu of the normal C++ STL for various technical and
 preferential reasons.
 While the full documentation is in the comments of 
\family typewriter 
\size small 
superstl.h
\family default 
\size default 
 and 
\family typewriter 
\size small 
superstl.cpp
\family default 
\size default 
, the following is a brief list of its features:
\layout Itemize

I/O stream classes familiar from Standard C++, including 
\family typewriter 
\size small 
istream
\family default 
\size default 
 and 
\family typewriter 
\size small 
ostream
\family default 
\size default 
.
 Unique to SuperSTL is how the comma operator (
\begin_inset Quotes eld
\end_inset 

,
\begin_inset Quotes erd
\end_inset 

) can be used to separate a list of objects to send to or from a stream,
 in addition to the usual C++ insertion operator (
\begin_inset Quotes eld
\end_inset 

<<
\begin_inset Quotes erd
\end_inset 

).
\layout Itemize

To read and write binary data, the 
\family typewriter 
\size small 
idstream
\family default 
\size default 
 and 
\family typewriter 
\size small 
odstream
\family default 
\size default 
 classes should be used instead.
\layout Itemize

String buffer (
\family typewriter 
\size small 
stringbuf
\family default 
\size default 
) class for composing strings in memory the same way they would be written
 to or read from an 
\family typewriter 
\size small 
ostream
\family default 
\size default 
 or 
\family typewriter 
\size small 
istream
\family default 
\size default 
.
\layout Itemize

String formatting classes (
\family typewriter 
\size small 
intstring
\family default 
\size default 
, 
\family typewriter 
\size small 
hexstring
\family default 
\size default 
, 
\family typewriter 
\size small 
padstring
\family default 
\size default 
, 
\family typewriter 
\size small 
bitstring
\family default 
\size default 
, 
\family typewriter 
\size small 
bytemaskstring
\family default 
\size default 
, 
\family typewriter 
\size small 
floatstring
\family default 
\size default 
) provide a wrapper around objects to exercise greater control of how they
 are printed.
\layout Itemize

Array (
\family typewriter 
\size small 
array
\family default 
\size default 
) template class represents a fixed size array of objects.
 It is essentially a simple but very fast wrapper for a C-style array.
\layout Itemize

Bit vector (
\family typewriter 
\size small 
bitvec
\family default 
\size default 
) is a heavily optimized and rewritten version of the Standard C++ 
\family typewriter 
\size small 
bitset
\family default 
\size default 
 class.
 It supports many additional operations well suited to logic design purposes
 and emphasizes extremely fast branch free code.
\layout Itemize

Dynamic Array (
\family typewriter 
\size small 
dynarray
\family default 
\size default 
) template class provides for dynamically sized arrays, stacks and other
 such structures, similar to the Standard C++ 
\family typewriter 
\size small 
valarray
\family default 
\size default 
 class.
\layout Itemize

Linked list node (
\family typewriter 
\size small 
listlink
\family default 
\size default 
) template class forms the basis of double linked list structures in which
 a single pointer refers to the head of the list.
\layout Itemize

Queue list node (
\family typewriter 
\size small 
queuelink
\family default 
\size default 
) template class supports more operations than 
\family typewriter 
\size small 
listlink
\family default 
\size default 
 and can serve as both a node in a list and a list head/tail header.
\layout Itemize

Index reference (
\family typewriter 
\size small 
indexref
\family default 
\size default 
) is a smart pointer which compresses a full pointer into an index into
 a specific structure (made unique by the template parameters).
 This class behaves exactly like a pointer when referenced, but takes up
 much less space and may be faster.
 The 
\family typewriter 
\size small 
indexrefnull
\family default 
\size default 
 class adds support for storing null pointers, which 
\family typewriter 
\size small 
indexref
\family default 
\size default 
 lacks.
\layout Itemize


\family typewriter 
\size small 
Hashtable
\family default 
\size default 
 class is a general purpose chaining based hash table with user configurable
 key hashing and management via add-on template classes.
\layout Itemize


\family typewriter 
\size small 
ChunkHashtable
\family default 
\size default 
 class is a simplified hash table designed for small data items, for instance
 where we simply want to detect the presence of a key rather than associate
 data with it.
 It tries to pack many keys into cache line sized chunks and does parallel
 vectorized matching on each chunk for added speed.
\layout Itemize


\family typewriter 
\size small 
CRC32
\family default 
\size default 
 calculation class is useful for hashing
\layout Itemize


\family typewriter 
\size small 
CycleTimer
\family default 
\size default 
 is useful for timing intervals with sub-nanosecond precision using the
 CPU cycle counter (discussed in Section 
\begin_inset LatexCommand \ref{sec:Timing}

\end_inset 

).
\layout Subsection

Logic Standard Template Library (LogicSTL)
\layout Standard

The Logic Standard Template Library (LogicSTL) is an internally developed
 add-on to SuperSTL which supports a variety of structures useful for modeling
 sequential logic.
 Some of its primitives may look familiar to Verilog or VHDL programmers.
 While the full documentation is in the comments of 
\family typewriter 
\size small 
logic.h
\family default 
\size default 
, the following is a brief list of its features:
\layout Itemize


\family typewriter 
\size small 
latch
\family default 
\size default 
 template class works like any other assignable variable, but the new value
 only becomes visible after the 
\family typewriter 
\size small 
clock()
\family default 
\size default 
 method is called (potentially from a global clock chain).
\layout Itemize


\family typewriter 
\size small 
Queue
\family default 
\size default 
 template class implements a general purpose fixed size queue.
 The queue supports various operations from both the head and the tail,
 and is ideal for modeling queues in microprocessors.
\layout Itemize

Iterators for 
\family typewriter 
\size small 
Queue
\family default 
\size default 
 objects such as 
\family typewriter 
\size small 
foreach_forward
\family default 
\size default 
, 
\family typewriter 
\size small 
foreach_forward_from
\family default 
\size default 
, 
\family typewriter 
\size small 
foreach_forward_after
\family default 
\size default 
, 
\family typewriter 
\size small 
foreach_backward
\family default 
\size default 
, 
\family typewriter 
\size small 
foreach_backward_from
\family default 
\size default 
, 
\family typewriter 
\size small 
foreach_backward_before
\family default 
\size default 
.
\layout Itemize


\family typewriter 
\size small 
HistoryBuffer
\family default 
\size default 
 maintains a shift register of values, which when combined with a hash function
 is useful for implementing predictor histories and the like.
\layout Itemize


\family typewriter 
\size small 
FullyAssociativeTags
\family default 
\size default 
 template class is a general purpose array of associative tags in which
 each tag must be unique.
 This class uses highly efficient matching logic and supports pseudo-LRU
 eviction, associative invalidation and direct indexing.
 It forms the basis for most associative structures in PTLsim.
\layout Itemize


\family typewriter 
\size small 
FullyAssociativeArray
\family default 
\size default 
 pairs a 
\family typewriter 
\size small 
FullyAssociativeTags
\family default 
\size default 
 object with actual data values to form the basis of a cache.
\layout Itemize


\family typewriter 
\size small 
AssociativeArray
\family default 
\size default 
 divides a 
\family typewriter 
\size small 
FullyAssociativeArray
\family default 
\size default 
 into sets.
 In effect, this class can provide a complete cache implementation for a
 processor.
\layout Itemize


\family typewriter 
\size small 
LockableFullyAssociativeTags
\family default 
\size default 
, 
\family typewriter 
\size small 
LockableFullyAssociativeArray
\family default 
\size default 
 and 
\family typewriter 
\size small 
LockableAssociativeArray
\family default 
\size default 
 provide the same services as the classes above, but support locking lines
 into the cache.
\layout Itemize


\family typewriter 
\size small 
CommitRollbackCache
\family default 
\size default 
 leverages the 
\family typewriter 
\size small 
LockableFullyAssociativeArray
\family default 
\size default 
 class to provide a cache structure with the ability to roll back all changes
 made to memory (not just within this object, but everywhere) after a checkpoint
 is made.
\layout Itemize


\family typewriter 
\size small 
FullyAssociativeTags8bit
\family default 
\size default 
 and 
\family typewriter 
\size small 
FullyAssociativeTags16bit
\family default 
\size default 
 work just like 
\family typewriter 
\size small 
FullyAssociativeTags
\family default 
\size default 
, except that these classes are dramatically faster when using small 8-bit
 and 16-bit tags.
 This is possible through the clever use of x86 SSE vector instructions
 to associatively match and process 16 8-bit tags or 8 16-bit tags every
 cycle.
 In addition, these classes support features like removing an entry from
 the middle of the array while compacting entries around it in constant
 time.
 These classes should be used in place of 
\family typewriter 
\size small 
FullyAssociativeTags
\family default 
\size default 
 whenever the tags are small enough (i.e.
 almost all tags except for memory addresses).
\layout Subsection

Miscellaneous Code
\layout Standard

The out of order simulator, ooocore.cpp, contains several reusable classes,
 including:
\layout Itemize


\family typewriter 
\size small 
IssueQueue
\family default 
\size default 
 template class can be used to implement all kinds of broadcast based issue
 queues
\layout Itemize


\family typewriter 
\size small 
StateList
\family default 
\size default 
 and 
\family typewriter 
\size small 
ListOfStateLists
\family default 
\size default 
 is useful for collecting various lists that objects can be on into one
 structure.
\layout Section


\begin_inset LatexCommand \label{sec:Injection}

\end_inset 

Low Level Startup and Injection
\layout Standard


\emph on 
Note:
\emph default 
 This section deals with the internal operation of the PTLsim virtual machine
 manager, independent of the out of order simulation engine.
 If you are only interested in modifying the simulator itself, you can skip
 this section.
\layout Subsection


\begin_inset LatexCommand \label{sub:Injection-On-x86-64}

\end_inset 

Startup on x86-64
\layout Standard

PTLsim is a very unusual Linux program.
 It does its own internal memory management and threading without help from
 the standard libraries, injects itself into other processes to take control
 of them, and switches between 32-bit and 64-bit mode within a single process
 image.
 For these reasons, it is very closely tied to the Linux kernel and uses
 a number of undocumented system calls and features only available in late
 2.6 series kernels.
 
\layout Standard

PTLsim always starts and runs as a 64-bit process even when running 32-bit
 threads; it context switches between modes as needed.
 The statically linked 
\family typewriter 
\size small 
ptlsim
\family default 
\size default 
 executable begins executing at 
\family typewriter 
\size small 
ptlsim_preinit_entry
\family default 
\size default 
 in 
\family typewriter 
\size small 
lowlevel-64bit.S
\family default 
\size default 
.
 This code calls 
\family typewriter 
\size small 
ptlsim_preinit()
\family default 
\size default 
 in 
\family typewriter 
\size small 
kernel.cpp
\family default 
\size default 
 to set up our custom memory manager and threading environment before any
 standard C/C++ functions are used.
 After doing so, the normal 
\family typewriter 
\size small 
main()
\family default 
\size default 
 function is invoked.
\layout Standard

The 
\family typewriter 
\size small 
ptlsim
\family default 
\size default 
 binary can run in two modes.
 If executed from the command line as a normal program, it starts up in
 
\emph on 
inject
\emph default 
 mode.
 Specifically, 
\family typewriter 
\size small 
main()
\family default 
\size default 
 in 
\family typewriter 
\size small 
ptlsim.cpp
\family default 
\size default 
 checks if the 
\family typewriter 
\size small 
inside_ptlsim
\family default 
\size default 
 variable has been set by 
\family typewriter 
\size small 
ptlsim_preinit_entry
\family default 
\size default 
, and if not, PTLsim enters inject mode.
 In this mode, 
\family typewriter 
\size small 
ptlsim_inject()
\family default 
\size default 
 in 
\family typewriter 
\size small 
kernel.cpp
\family default 
\size default 
 is called to effectively inject the 
\family typewriter 
\size small 
ptlsim
\family default 
\size default 
 binary into another process and pass control to it before even the dynamic
 linker gets to load the program.
 In 
\family typewriter 
\size small 
ptlsim_inject()
\family default 
\size default 
, the PTLsim process is forked and the child is placed under the parent's
 control using 
\family typewriter 
\size small 
ptrace()
\family default 
\size default 
.
 The child process then uses 
\family typewriter 
\size small 
exec()
\family default 
\size default 
 to start the user program to simulate (this can be either a 32-bit or 64-bit
 program).
 
\layout Standard

However, the user program starts in the stopped state, allowing 
\family typewriter 
\size small 
ptlsim_inject()
\family default 
\size default 
 to use 
\family typewriter 
\size small 
ptrace()
\family default 
\size default 
 and related functions to inject either 32-bit or 64-bit boot loader code
 directly into the user program address space, overwriting the entry point
 of the dynamic linker.
 This code, derived from 
\family typewriter 
\size small 
injectcode.cpp
\family default 
\size default 
 (specifically compiled as 
\family typewriter 
\size small 
injectcode-32bit.o
\family default 
\size default 
 and 
\family typewriter 
\size small 
injectcode-64bit.o
\family default 
\size default 
) is completely position independent.
 Its sole function is to map the rest of 
\family typewriter 
\size small 
ptlsim
\family default 
\size default 
 into the user process address space at virtual address 
\family typewriter 
\size small 
0x70000000
\family default 
\size default 
 and set up a special 
\family typewriter 
\size small 
LoaderInfo
\family default 
\size default 
 structure to allow the master PTLsim process and the user process to communicat
e.
 The boot code also restores the old code at the dynamic linker entry point
 after relocating itself.
 Finally, 
\family typewriter 
\size small 
ptlsim_inject()
\family default 
\size default 
 adjusts the user process registers to start executing the boot code instead
 of the normal program entry point, and resumes the user process.
\layout Standard

At this point, the PTLsim image injected into the user process exists in
 a bizarre environment: if the user program is 32 bit, the boot code will
 need to switch to 64-bit mode before calling the 64-bit PTLsim entrypoint.
 Fortunately x86-64 and the Linux kernel make this process easy, despite
 never being used by normal programs: a regular far jump switches the current
 code segment descriptor to 
\family typewriter 
\size small 
0x33
\family default 
\size default 
, effectively switching the instruction set to x86-64.
 For the most part, the kernel cannot tell the difference between a 32-bit
 and 64-bit process: as long as the code uses 64-bit system calls (i.e.
 
\family typewriter 
\size small 
syscall
\family default 
\size default 
 instruction instead of 
\family typewriter 
\size small 
int 0x80
\family default 
\size default 
 as with 32-bit system calls), Linux assumes the process is 64-bit.
 There are some subtle issues related to signal handling and memory allocation
 when performing this trick, but PTLsim implements workarounds to these
 issues.
\layout Standard

After entering 64-bit mode if needed, the boot code passes control to PTLsim
 at 
\family typewriter 
\size small 
ptlsim_preinit_entry
\family default 
\size default 
.
 The 
\family typewriter 
\size small 
ptlsim_preinit()
\family default 
\size default 
 function checks for the special 
\family typewriter 
\size small 
LoaderInfo
\family default 
\size default 
 structure on the stack and in the ELF header of PTLsim as modified by the
 boot code; if these structures are found, PTLsim knows it is running inside
 the user program address space.
 After setting up memory management and threading, it captures any state
 the user process was initialized with.
 This state is used to fill in fields in the global 
\family typewriter 
\size small 
ctx
\family default 
\size default 
 structure of class 
\family typewriter 
\size small 
CoreContext
\family default 
\size default 
: various floating point related fields and the user program entry point
 and original stack pointer are saved away at this point.
 If PTLsim is running inside a 32-bit process, the 32-bit arguments, environment
 and kernel auxiliary vector array (auxv) need to be converted to their
 64-bit format for PTLsim to be able to parse them from normal C/C++ code.
 Finally, control is returned to 
\family typewriter 
\size small 
main()
\family default 
\size default 
 to allow the simulator to start up normally.
\layout Subsection

Startup on 32-bit x86
\layout Standard

The PTLsim startup process on a 32-bit x86 system is essentially a streamlined
 version of the process above (Section 
\begin_inset LatexCommand \ref{sub:Injection-On-x86-64}

\end_inset 

), since there is no need for the same PTLsim binary to support both 32-bit
 and 64-bit user programs.
 The injection process is very similar to the case where the user program
 is always a 32-bit program.
\layout Section

Simulator Startup
\layout Standard

In 
\family typewriter 
\size small 
ptlsim.cpp
\family default 
\size default 
, the 
\family typewriter 
\size small 
main()
\family default 
\size default 
 function calls 
\family typewriter 
\size small 
init_config()
\family default 
\size default 
 to read in the user program specific configuration as described in Sections
 
\begin_inset LatexCommand \ref{sec:RunningPTLsim}

\end_inset 

 and 
\begin_inset LatexCommand \ref{sec:ConfigurationOptions}

\end_inset 

, then starts up the various other simulator subsystems.
 If one of the 
\family typewriter 
\size small 
-excludeld
\family default 
\size default 
 or 
\family typewriter 
\size small 
-startrip
\family default 
\size default 
 options were given, a breakpoint is inserted at the RIP address where the
 user process should switch from native mode to simulation mode (this may
 be at the dynamic linker entry point by default).
\layout Standard

Finally, 
\family typewriter 
\size small 
switch_to_native_restore_context()
\family default 
\size default 
 is called to restore the state that existed before PTLsim was injected
 into the process and return to the dynamic linker entry point.
 This may involve switching from 64-bit back to 32-bit mode to start executing
 the user process natively as discussed in Section 
\begin_inset LatexCommand \ref{sec:Injection}

\end_inset 

.
\layout Standard

After native execution reaches the inserted breakpoint thunk code, the code
 performs a 32-to-64-bit long jump back into PTLsim, which promptly restores
 the code underneath the inserted breakpoint thunk.
 At this point, the 
\family typewriter 
\size small 
switch_to_sim()
\family default 
\size default 
 function in 
\family typewriter 
\size small 
ptlsim.cpp
\family default 
\size default 
 is invoked to actually begin the simulation.
 This is done by calling 
\family typewriter 
\size small 
out_of_order_core_toplevel_loop()
\family default 
\size default 
 in ooocore.cpp.
\layout Standard

At some point during simulation, the user program or the configuration file
 may request a switch back to native mode for the remainder of the program.
 In this case, the 
\family typewriter 
\size small 
show_stats_and_switch_to_native()
\family default 
\size default 
 function gets called to save the statistics data store, map the PTLsim
 internal state back to the x86 compatible external state and return to
 the 32-bit or 64-bit user code, effectively removing PTLsim from the loop.
\layout Standard

While the real PTLsim user process is running, the original PTLsim injector
 process simply waits in the background for the real user program with PTLsim
 inside it to terminate, then returns its exit code.
\layout Section


\begin_inset LatexCommand \label{sec:AddressSpaceSimulation}

\end_inset 

Address Space Simulation
\layout Standard

PTLsim maintains the 
\family typewriter 
\size small 
AddressSpace
\family default 
\size default 
 class as global variable 
\family typewriter 
\size small 
asp
\family default 
\size default 
 (see 
\family typewriter 
\size small 
kernel.cpp
\family default 
\size default 
) to track the attributes of each page within the virtual address space.
 When compiled for x86-64 systems, PTLsim uses Shadow Page Access Tables
 (SPATs), which are essentially large two-level bitmaps.
 Since pages are 4096 bytes in size, each 64 kilobyte chunk of the bitmap
 can track 2 GB of virtual address space.
 In each SPAT, each top level array entry points to a chunk mapping 2 GB,
 such that with 131072 top level pointers, the full 48 bit virtual address
 space can typically be mapped with under a megabyte of SPAT chunks, assuming
 the address space is sparse.
\layout Standard

When compiled for 32-bit x86 systems, each SPAT is just a 128 KByte bitmap,
 with one bit for each of the 1048576 4 KB pages in the 4 GB address space.
\layout Standard

In the AddressSpace structure, there are separate SPAT tables for readable
 pages (
\family typewriter 
\size small 
readmap
\family default 
\size default 
 field), writable pages (
\family typewriter 
\size small 
writemap
\family default 
\size default 
 field) and executable pages (
\family typewriter 
\size small 
execmap
\family default 
\size default 
 field).
 Two additional SPATs, 
\family typewriter 
\size small 
dtlbmap
\family default 
\size default 
 and 
\family typewriter 
\size small 
itlbmap
\family default 
\size default 
, are used to track which pages are currently mapped by the simulated translatio
n lookaside buffers (TLBs); this is discussed further in Section 
\begin_inset LatexCommand \ref{sec:TranslationLookasideBuffers}

\end_inset 

.
\layout Standard

When running in native mode, PTLsim cannot track changes to the process
 memory map made by native calls to 
\family typewriter 
\size small 
mmap()
\family default 
\size default 
, 
\family typewriter 
\size small 
munmap()
\family default 
\size default 
, etc.
 Therefore, at every switch from native to simulation mode, the 
\family typewriter 
\size small 
resync_with_process_maps()
\family default 
\size default 
 function is called.
 This function parses the 
\family typewriter 
\size small 
/proc/self/maps
\family default 
\size default 
 metafile maintained by the kernel to build a list of all regions mapped
 by the current process.
 Using this list, the SPATs are rebuilt to reflect the current memory map.
 This is absolutely critical for correct operation, since during simulation,
 speculative loads and stores will only read and write memory if the appropriate
 SPAT indicates the address is accessible to user code.
 If the SPATs become out of sync with the real memory map, PTLsim itself
 may crash rather than simply marking the offending load or store as invalid.
 The 
\family typewriter 
\size small 
resync_with_process_maps()
\family default 
\size default 
 function (or more specifically, the 
\family typewriter 
\size small 
mqueryall()
\family default 
\size default 
 helper function) is fairly kernel version specific since the format of
 
\family typewriter 
\size small 
/proc/self/maps
\family default 
\size default 
 has changed between Linux 2.6.x kernels.
 New kernels may require updating this function.
\layout Standard

PTLsim does not use the normal C library implementations of 
\family typewriter 
\size small 
malloc()
\family default 
\size default 
, 
\family typewriter 
\size small 
free()
\family default 
\size default 
, 
\family typewriter 
\size small 
mmap()
\family default 
\size default 
, 
\family typewriter 
\size small 
new
\family default 
\size default 
, 
\family typewriter 
\size small 
delete
\family default 
\size default 
 and so on.
 Instead, PTLsim code should always use the 
\family typewriter 
\size small 
ptl_alloc_private_pages()
\family default 
\size default 
 family of functions defined in 
\family typewriter 
\size small 
kernel.cpp
\family default 
\size default 
 to ensure that PTLsim memory remains completely invisible to user code
 (except, of course, within PTLsim generated microcode sequences).
 This is done by clearing the bits in the read, write and execute SPATs
 corresponding to the allocated pages.
 The 
\family typewriter 
\size small 
new
\family default 
\size default 
, 
\family typewriter 
\size small 
delete
\family default 
\size default 
, 
\family typewriter 
\size small 
malloc()
\family default 
\size default 
 and 
\family typewriter 
\size small 
free()
\family default 
\size default 
 functions can still be used since PTLsim overrides these.
 Note that memory allocated in this way will 
\emph on 
not
\emph default 
 be accessible to user code.
\layout Section

Implementation of uops
\layout Standard

PTLsim provides implementations for all micro-operations (uops) in the 
\family typewriter 
\size small 
uopimpl.cpp
\family default 
\size default 
 file.
 C++ templates are combined with gcc's smart inline assembler type selection
 constraints to translate all possible permutations (sizes, condition codes,
 etc) of each uop into highly optimized code.
 In many cases, a real x86 instruction is used at the core of each corresponding
 uop's implementation; code after the instruction just captures the generated
 x86 condition code flags, rather than having to manually emulate the same
 condition codes ourselves.
 The code implementing each uop is then called from elsewhere in the simulator
 whenever that uop must be executed.
 Note that loads and stores are implemented elsewhere, since they are too
 dependent on the specific core model to be expressed in this generic manner.
\layout Section


\begin_inset LatexCommand \label{sec:DebuggingHints}

\end_inset 

Debugging Hints
\layout Standard

When adding or modifying PTLsim, bugs will invariably crop up.
 Fortunately, PTLsim provides a trivial way to find the location of bugs
 which silently corrupt program execution.
 Since PTLsim can transparently switch between simulation and native mode,
 isolating the divergence point between the simulated behavior and what
 a real reference machine would do can be done through binary search.
 The 
\family typewriter 
\size small 
-stopinsns
\family default 
\size default 
 configuration option can be set to stop simulation before the problem occurs,
 then incremented until the first x86 instruction to break the program is
 determined.
\layout Standard

The out of order simulator (
\family typewriter 
\size small 
ooocore.cpp
\family default 
\size default 
) includes extensive debugging and integrity checking assertions.
 These may be turned off by default for improved performance, but they can
 be easily re-enabled by defining the 
\family typewriter 
\size small 
ENABLE_CHECKS
\family default 
\size default 
 symbol at the top of 
\family typewriter 
\size small 
ooocore.cpp
\family default 
\size default 
.
 Additional check functions are in the code but commented out; these may
 be used as well.
\layout Standard

You can also debug PTLsim with 
\family typewriter 
\size small 
gdb
\family default 
\size default 
, although the process is non-standard due to PTLsim's co-simulation architectur
e:
\layout Itemize

Start PTLsim on the target program like normal.
 Notice the 
\family typewriter 
\size small 
Thread 
\emph on 
N
\emph default 
 is running in XX-bit mode
\family default 
\size default 
 message printed at startup: this is the PID you will be debugging, not
 the 
\begin_inset Quotes eld
\end_inset 


\family typewriter 
\size small 
ptlsim
\family default 
\size default 

\begin_inset Quotes erd
\end_inset 

 process that may also be running.
\layout Itemize

Start GDB and type 
\begin_inset Quotes eld
\end_inset 


\family typewriter 
\size small 
attach 12345
\family default 
\size default 

\begin_inset Quotes erd
\end_inset 

 if 
\emph on 
12345
\emph default 
 was the PID listed above
\layout Itemize

Type 
\begin_inset Quotes eld
\end_inset 


\family typewriter 
\size small 
symbol-file ptlsim
\family default 
\size default 

\begin_inset Quotes erd
\end_inset 

 to load the PTLsim internal symbols (otherwise gdb only knows about the
 benchmark code itself).
 You should specify the full path to the PTLsim executable here.
\layout Itemize

You're now debugging PTLsim.
 If you run the 
\begin_inset Quotes eld
\end_inset 


\family typewriter 
\size small 
bt
\family default 
\size default 

\begin_inset Quotes erd
\end_inset 

 command to get a backtrace, it should show the PTLsim functions starting
 at address 0x70000000.
\layout Standard

If the backtrace does not display enough information, go to the 
\family typewriter 
\size small 
Makefile
\family default 
\size default 
 and enable the "no optimization" options (the "-O0" line instead of "-O99")
 since that will make more debugging information available to you.
\layout Standard

The 
\begin_inset Quotes eld
\end_inset 


\family typewriter 
\size small 
-pause-at-startup
\family default 
\size default 
 
\emph on 
seconds
\emph default 

\begin_inset Quotes erd
\end_inset 

 configuration option may be useful here, to give you time to attach with
 a debugger before starting the simulation.
\layout Section


\begin_inset LatexCommand \label{sec:Timing}

\end_inset 

Timing Issues
\layout Standard

PTLsim uses the 
\family typewriter 
\size small 
CycleTimer
\family default 
\size default 
 class extensively to gather data about its own performance using the CPU's
 timestamp counter.
 At startup in 
\family typewriter 
\size small 
superstl.cpp
\family default 
\size default 
, the CPU's maximum frequency is queried from the appropriate Linux kernel
 sysfs node (if available) or from 
\family typewriter 
\size small 
/proc/cpuinfo
\family default 
\size default 
 if not.
 Processors which dynamically scale their frequency and voltage in response
 to load (like all Athlon 64 and K8 based AMD processors) require special
 handling.
 It is assumed that the processor will be running at its maximum frequency
 (as reported by sysfs) or a fixed frequency (as reported by 
\family typewriter 
\size small 
/proc/cpuinfo
\family default 
\size default 
) throughout the majority of the simulation time; otherwise the timing results
 will be bogus.
\layout Chapter


\begin_inset LatexCommand \label{sec:StatisticsInfrastructure}

\end_inset 

Using PTLstats
\layout Section

Introducing PTLstats
\layout Standard

PTLsim maintains a huge number of statistical counters and data points during
 the simulation process; the specific data are documented in Section 
\begin_inset LatexCommand \ref{sec:PerformanceCounters}

\end_inset 

.
 PTLsim can optionally save this data to a statistics data store by using
 the 
\begin_inset Quotes eld
\end_inset 


\family typewriter 
\size small 
-stats
\family default 
\size default 
 
\emph on 
filename
\emph default 

\begin_inset Quotes erd
\end_inset 

 configuration option introduced in Section 
\begin_inset LatexCommand \ref{sec:ConfigurationOptions}

\end_inset 

.
 The data store is a binary file format (defined in 
\family typewriter 
\size small 
datastore.cpp
\family default 
\size default 
) used to efficiently capture large quantities of statistical information
 for later analysis.
 This file format supports storing multiple regular snapshots of all counters
 by specifying the 
\begin_inset Quotes eld
\end_inset 


\family typewriter 
\size small 
-snapshot
\family default 
\size default 
 
\emph on 
N
\emph default 

\begin_inset Quotes erd
\end_inset 

 option to save a snapshot of the simulator state every 
\emph on 
N
\emph default 
 cycles in addition to the final state.
\layout Standard

The 
\series bold 
\emph on 
PTLstats
\series default 
\emph default 
 program is used to analyze the statistics data store files produced by
 PTLsim.
 Internally, PTLsim and PTLstats represent statistics data store nodes in
 a tree format.
 Each node can contain other data store nodes as well as a value (64-bit
 integer, floating point, character string) or an array of values.
 The following is an example of one node in the statistics tree, as printed
 by PTLstats:
\layout LyX-Code


\size small 
dcache {
\layout LyX-Code


\size small 
  store {
\layout LyX-Code


\size small 
    issue (total 134243383) {
\layout LyX-Code


\size small 
      [  22% ] replay (total 29278598) {
\layout LyX-Code


\size small 
        [   0% ] wait-sfraddr = 0;
\layout LyX-Code


\size small 
        [  33% ] wait-storedata-sfraddr = 9755097;
\layout LyX-Code


\size small 
        [  33% ] wait-storedata-sfraddr-sfrdata = 9755097;
\layout LyX-Code


\size small 
        [   6% ] wait-storedata-sfrdata = 1891253;
\layout LyX-Code


\size small 
        [   4% ] wait-sfrdata = 1069751;
\layout LyX-Code


\size small 
        [  23% ] wait-sfraddr-sfrdata = 6807400;
\layout LyX-Code


\size small 
      }
\layout LyX-Code


\size small 
      [   0% ] exception = 196094;
\layout LyX-Code


\size small 
      [   0% ] ordering = 55369;
\layout LyX-Code


\size small 
      [  78% ] complete = 104592504;
\layout LyX-Code


\size small 
      [   0% ] unaligned = 120818;
\layout LyX-Code


\size small 
    }
\layout LyX-Code


\size small 
    ...
\layout Standard

Notice how PTLstats will automatically sum up all entries in certain branches
 of the tree to provide the user with a breakdown by percentages of the
 total for that subtree in addition to the raw values.
 Many other node attributes can be specified to help format the data in
 similar ways, as is described in the following sections.
\layout Section

Working with Statistics Trees: Collection, Averaging and Summing
\layout Standard

The basic syntax of the PTLstats command is 
\begin_inset Quotes eld
\end_inset 


\family typewriter 
\size small 
ptlstats -
\family default 
\size default 
\emph on 
options
\emph default 
 
\emph on 
filename
\emph default 

\begin_inset Quotes erd
\end_inset 

.
 If no options are specified, PTLstats prints out the entire statistics
 tree from its root, including all snapshots.
\layout Standard

To select a specific subtree of interest (for instance, a specific snapshot
 or a node within a snapshot), use the syntax of the following example:
\layout LyX-Code


\size small 
ptlstats 
\series bold 
-collect
\series default 
 /final/dcache/load example1.stats example2.stats ...
\layout Standard

This will print out the subtree 
\family typewriter 
\size small 
dcache/load
\family default 
\size default 
 in the snapshot named 
\family typewriter 
\size small 
final
\family default 
\size default 
 for each of the named statistics files 
\family typewriter 
\size small 
example1.stats
\family default 
\size default 
, 
\family typewriter 
\size small 
example2.stats
\family default 
\size default 
 and so on.
 Multiple files are generally used to examine a specific subnode across
 several benchmarks.
\layout Standard

Subtrees can also be summed and averaged across many files, using the 
\family typewriter 
\series bold 
\size small 
-collectsum
\family default 
\series default 
\size default 
 or 
\family typewriter 
\series bold 
\size small 
-collectaverage
\family default 
\series default 
\size default 
 commands in place of 
\family typewriter 
\size small 
-collect
\family default 
\size default 
.
 The subtrees must be identical in structure (but not in their data) across
 all files for these two options to work.
\layout Section

Traversal and Printing Options
\layout Standard

The 
\family typewriter 
\series bold 
\size small 
-maxdepth
\family default 
\series default 
\size default 
 option is useful for limiting the depth (in nodes) PTLstats will descend
 into the specified subtree.
 This is appropriate when you want to summarize certain classes of statistics
 printed as percentages of the whole, yet don't want a breakdown of every
 sub-statistic.
\layout Standard

The 
\family typewriter 
\size small 
-percent-of-toplevel
\family default 
\size default 
 option changes the way percentages are displayed.
 By default, percentages are calculated by dividing the total value of each
 node by the total of its immediate parent node.
 When 
\family typewriter 
\size small 
-percent-of-toplevel
\family default 
\size default 
 is enabled, the divisor becomes the total of the entire subtree, possibly
 going back several levels (i.e.
 back to the highest level node marked with the 
\emph on 
summable
\emph default 
 attribute), rather than each node's immediate parent.
\layout Section

Table Generation
\layout Standard

PTLstats provides a facility to easily generate R-row by C-column data tables
 from a set of R benchmarks run with C different sets of parameters.
 Tables can be output in a variety of formats, including plain text with
 tab or space delimiters (suitable for import into a spreadsheet), LaTeX
 (for direct insertion into research reports) or HTML.
 To generate a table, use the following syntax:
\layout LyX-Code


\size small 
ptlstats 
\series bold 
-table 
\series default 
/final/summary/cycles -rows gzip,gcc,perlbmk,mesa -cols small,large,huge
 -table-pattern "%row/ptlsim.stats.%col"
\layout Standard

In this example, the benchmarks (
\begin_inset Quotes eld
\end_inset 

gzip
\begin_inset Quotes erd
\end_inset 

, 
\begin_inset Quotes eld
\end_inset 

gcc
\begin_inset Quotes erd
\end_inset 

, 
\begin_inset Quotes eld
\end_inset 

perlbmk
\begin_inset Quotes erd
\end_inset 

, 
\begin_inset Quotes eld
\end_inset 

mesa
\begin_inset Quotes erd
\end_inset 

) will form the rows of the table, while three trials done for each benchmark
 (
\begin_inset Quotes eld
\end_inset 

small
\begin_inset Quotes erd
\end_inset 

, 
\begin_inset Quotes eld
\end_inset 

large
\begin_inset Quotes erd
\end_inset 

, 
\begin_inset Quotes eld
\end_inset 

huge
\begin_inset Quotes erd
\end_inset 

) will be listed in the columns.
 The row and column names will be combined using the pattern 
\begin_inset Quotes eld
\end_inset 


\family typewriter 
\size small 
%row/ptlsim.stats.%col
\family default 
\size default 

\begin_inset Quotes eld
\end_inset 

 to generate statistics data store filenames like 
\begin_inset Quotes eld
\end_inset 


\family typewriter 
\size small 
gzip/ptlsim.stats.small
\family default 
\size default 

\begin_inset Quotes erd
\end_inset 

.
 PTLstats will then load the data store for each benchmark and trial combination
 to create the table.
\layout Standard

Notice that you must create your own scripts, or manually run each benchmark
 and trial with the desired PTLsim options, plus 
\begin_inset Quotes eld
\end_inset 


\family typewriter 
\size small 
-stats ptlsim.stats.
\emph on 
trialname
\family default 
\size default 
\emph default 

\begin_inset Quotes erd
\end_inset 

.
 PTLstats will only report these results in table form; it will not actually
 run any benchmarks.
\layout Standard

The 
\family typewriter 
\series bold 
\size small 
-tabletype
\family default 
\series default 
\size default 
 option specifies the data format of the table: 
\begin_inset Quotes eld
\end_inset 


\family typewriter 
\size small 
text
\family default 
\size default 

\begin_inset Quotes erd
\end_inset 

 (plain text with space delimiters, suitable for import into a spreadsheet),
 
\begin_inset Quotes eld
\end_inset 


\family typewriter 
\size small 
latex
\family default 
\size default 

\begin_inset Quotes erd
\end_inset 

 (LaTeX format, useful for directly inserting into research reports), or
 
\begin_inset Quotes eld
\end_inset 


\family typewriter 
\size small 
html
\family default 
\size default 

\begin_inset Quotes erd
\end_inset 

 (HTML format for web pages).
\layout Standard

The 
\begin_inset Quotes eld
\end_inset 


\family typewriter 
\series bold 
\size small 
-scale-relative-to-col
\series default 
 
\emph on 
N
\family default 
\size default 
\emph default 

\begin_inset Quotes erd
\end_inset 

 option forces PTLstats to compute the percentage of increase or decrease
 for each cell relative to the corresponding row in some other reference
 column 
\emph on 
N
\emph default 
.
 This is useful when running a 
\begin_inset Quotes eld
\end_inset 

baseline
\begin_inset Quotes erd
\end_inset 

 case, to be displayed as a raw value (usually the cycle count, 
\family typewriter 
\size small 
/final/summary/cycles
\family default 
\size default 
) in column 0, while all other experimental cases are displayed as a percentage
 increase (fewer cycles, for a positive percentage) or percentage decrease
 (negative value) relative to this first column (
\emph on 
N
\emph default 
 = 0).
\layout Section

Histogram Generation
\layout Standard

Certain nodes in the statistics tree can be tagged as 
\begin_inset Quotes eld
\end_inset 

histogram
\begin_inset Quotes erd
\end_inset 

 nodes when they are generated, meaning that they comprise an array of raw
 values, plus a lower bound, upper bound, scale and bucket size.
 For instance, the 
\family typewriter 
\size small 
frontend/consumer-count
\family default 
\size default 
 node in the out-of-order core is a histogram node.
 PTLstats can directly create graphs (in Scalable Vector Graphics (SVG)
 format) for these special nodes, using the 
\family typewriter 
\series bold 
\size small 
-histogram
\family default 
\series default 
\size default 
 option:
\layout LyX-Code


\size small 
ptlstats 
\series bold 
-histogram 
\series default 
/final/frontend/consumer-count > example.svg
\layout Standard

The histogram's layout can be extensively customized using the options 
\family typewriter 
\size small 
-title
\family default 
\size default 
, 
\family typewriter 
\size small 
-width
\family default 
\size default 
, 
\family typewriter 
\size small 
-height
\family default 
\size default 
.
 In addition, the 
\family typewriter 
\size small 
-percentile
\family default 
\size default 
 option is useful for controlling the displayed data range by excluding
 data under the Nth percentile.
 The 
\family typewriter 
\size small 
-logscale
\family default 
\size default 
 and 
\family typewriter 
\size small 
-logk
\family default 
\size default 
 options can be used to apply a log scale (instead of a linear scale) to
 the histogram bars.
 The syntax of these options can be obtained by running 
\family typewriter 
\size small 
ptlstats
\family default 
\size default 
 without arguments.
\layout Chapter

Statistics Collection and Control
\layout Section

Statistics support in code
\layout Standard

Internally, PTLsim represents data store nodes in its statistics tree format
 via the 
\family typewriter 
\size small 
DataStoreNode
\family default 
\size default 
 class defined in 
\family typewriter 
\size small 
datastore.h
\family default 
\size default 
.
 Each node can contain other data store nodes as well as a value (64-bit
 integer, floating point, character string) or an array of values.
 The following example illustrates the proper way to save statistical counters
 (typically declared as global variables of type 
\family typewriter 
\size small 
W64
\family default 
\size default 
, a 64-bit integer) into the data store.
 In this example, the 
\family typewriter 
\size small 
\emph on 
root
\family default 
\size default 
\emph default 
 
\family typewriter 
\size small 
DataStoreNode
\family default 
\size default 
 is assumed to be passed in as the parent of all other nodes:
\layout LyX-Code


\size small 
DataStoreNode& issue = root("issue"); {
\layout LyX-Code


\size small 
  DataStoreNode& unit = issue("unit"); {
\layout LyX-Code


\size small 
    unit.summable = 1;
\layout LyX-Code


\size small 
    unit.add("integer", issued_integer_uops);
\layout LyX-Code


\size small 
    unit.add("fp", issued_fp_uops);
\layout LyX-Code


\size small 
    unit.add("load", issued_load_uops);
\layout LyX-Code


\size small 
    unit.add("store", issued_store_uops);
\layout LyX-Code


\size small 
  }
\layout LyX-Code


\size small 
  DataStoreNode& timers = issue("times"); {
\layout LyX-Code


\size small 
    timers.summable = 1;
\layout LyX-Code


\size small 
    foreach (i, MAX_CLUSTERS) {
\layout LyX-Code


\size small 
      stringbuf sb; sb << i;
\layout LyX-Code


\size small 
      timers(clusters[i].name).addfloat(sb, timer_histogram[i]);
\layout LyX-Code


\size small 
    }
\layout LyX-Code


\size small 
  }
\layout LyX-Code

  // issue_width is declared as W64 issue_width_histogram[4+1];
\layout LyX-Code

  issue.histogram("width", issue_width_histogram, 4+1, 0, 4, 1);
\layout LyX-Code


\size small 
}
\layout Standard

In the example above, a statistics tree is created in which all subnodes
 under the 
\begin_inset Quotes eld
\end_inset 


\family typewriter 
\size small 
unit
\family default 
\size default 

\begin_inset Quotes erd
\end_inset 

 node are integers together assumed to total 100% of whatever quantity is
 being measured.
 Setting 
\family typewriter 
\size small 
summable = 1
\family default 
\size default 
 tells PTLstats to print percentages next to the raw values in this subtree
 for easier viewing.
 The 
\begin_inset Quotes eld
\end_inset 


\family typewriter 
\size small 
times
\family default 
\size default 

\begin_inset Quotes erd
\end_inset 

 subnode contains floating point values; the 
\family typewriter 
\size small 
stringbuf
\family default 
\size default 
 utility class is used to convert each slot index of this example histogram
 into a proper node name.
 This is only an example - PTLsim already contains code to save all statistics
 it generates.
\layout Standard

Histograms can be easily added through the 
\family typewriter 
\size small 
histogram()
\family default 
\size default 
 method shown above.
 You can specify an array of 
\family typewriter 
\size small 
W64
\family default 
\size default 
 values (64-bit unsigned integers) and the total number of values, along
 with optional low, high and stride values for the histogram data.
 More information is contained in 
\family typewriter 
\size small 
datastore.h
\family default 
\size default 
 and 
\family typewriter 
\size small 
datastore.cpp
\family default 
\size default 
.
 Histograms with text labels for each element can also be created, as demonstrat
ed in 
\family typewriter 
\size small 
ooocore.cpp
\family default 
\size default 
.
 
\layout Standard

PTLsim will by default call 
\family typewriter 
\size small 
ooo_capture_stats()
\family default 
\size default 
 every time a snapshot or final capture is taken, and will pass this function
 the top level DataStoreNode for that snapshot.
 Therefore, if adding your own statistics and counters, you should start
 by saving these counters using code inside 
\family typewriter 
\size small 
ooo_capture_stats()
\family default 
\size default 
 like that shown above.
\layout Standard

We suggest using the data store mechanism to store 
\emph on 
all
\emph default 
 statistics generated by your additions to PTLsim, since this system has
 built-in support for snapshots, checkpointing and structured easy to parse
 data (unlike simply writing values to a text file).
 It is further suggested that only raw values be saved, rather than doing
 computations in the simulator itself - leave the analysis to PTLstats after
 gathering the raw data.
 In particular, try to avoid using floating point within the simulator if
 at all possible, since some floating point calculations may reconfigure
 the SSE rounding and control flags in ways that break the assumptions used
 to execute actual user code.
\layout Section


\begin_inset LatexCommand \label{sec:TriggerMode}

\end_inset 

PTLsim Calls From User Code
\layout Standard

PTLsim optionally allows user code to control the simulator mode through
 the 
\family typewriter 
\size small 
ptlcall_xxx()
\family default 
\size default 
 family of functions found in 
\family typewriter 
\size small 
ptlcalls.h
\family default 
\size default 
 when trigger mode is enabled (
\family typewriter 
\size small 
-trigger
\family default 
\size default 
 configuration option).
 This file should be included by any PTLsim-aware user programs; these programs
 must be recompiled to take advantage of these features.
 Amongst the functions provided by 
\family typewriter 
\size small 
ptlcalls.h
\family default 
\size default 
 are:
\layout Itemize


\family typewriter 
\size small 
ptlcall_switch_to_sim()
\family default 
\size default 
 is only available while the program is executing in native mode.
 It forces PTLsim to regain control and begin simulating instructions as
 soon as this call returns.
\layout Itemize


\family typewriter 
\size small 
ptlcall_switch_to_native()
\family default 
\size default 
 stops simulation and returns to native execution, effectively removing
 PTLsim from the loop.
\layout Itemize


\family typewriter 
\size small 
ptlcall_marker()
\family default 
\size default 
 simply places a user-specified marker number in the PTLsim log file
\layout Itemize


\family typewriter 
\size small 
ptlcall_capture_stats()
\family default 
\size default 
 adds a new statistics data store snapshot at the time it is called.
 You can pass a string to this function to name your snapshot, but all names
 must be unique.
\layout Itemize


\family typewriter 
\size small 
ptlcall_nop()
\family default 
\size default 
 does nothing but test the call mechanism.
\layout Standard

These calls work by forcing execution to code on a 
\begin_inset Quotes eld
\end_inset 

gateway page
\begin_inset Quotes erd
\end_inset 

 at a specific fixed address (
\family typewriter 
\size small 
0x1000
\family default 
\size default 
 currently); PTLsim will write the appropriate call gate code to this page
 depending on whether the process is in native or simulated mode.
 In native mode, the call gate page typically contains a 64-to-64-bit or
 32-to-64-bit far jump into PTLsim, while in simulated mode it contains
 a reserved x86 opcode interpreted by the x86 decoder as a special kind
 of system call.
 If PTLsim is built on a 32-bit only system, no mode switch is required.
\layout Standard

Generally these calls are used to perform 
\begin_inset Quotes eld
\end_inset 

intelligent benchmarking
\begin_inset Quotes erd
\end_inset 

: the 
\family typewriter 
\size small 
ptlcall_switch_to_sim()
\family default 
\size default 
 call is made at the top of the main loop of a benchmark after initialization,
 while the 
\family typewriter 
\size small 
ptlcall_switch_to_native()
\family default 
\size default 
 call is inserted after some number of iterations to stop simulation after
 a representative subset of the code has completed.
 This intelligent approach is far better than the blind 
\begin_inset Quotes eld
\end_inset 

sample for N million cycles after S million startup cycles
\begin_inset Quotes erd
\end_inset 

 approach used by most researchers.
\layout Standard

Fortran programs will have to actually link in the 
\family typewriter 
\size small 
ptlcalls.o
\family default 
\size default 
 object file, since they cannot include C header files.
 The function names that should be used in the Fortran code remain the same
 as those from the 
\family typewriter 
\size small 
ptlcalls.h
\family default 
\size default 
 header file.
\layout Section

External Signals and PTLsim
\layout Standard

PTLsim can be forced to switch between native mode and sequential mode by
 sending it standard Linux-style signals from the command line.
 If your program is called 
\begin_inset Quotes eld
\end_inset 

myprogram
\begin_inset Quotes erd
\end_inset 

, start it under PTLsim and run this command from another terminal:
\layout LyX-Code


\size small 
killall -XCPU 
\emph on 
myprogram
\layout Standard

This will force PTLsim to switch between native mode and simulation mode,
 depending on its current mode.
 It will print a message to the console and the logfile when you do this.
 The initial mode (native or simulation) is determined by the presence of
 the 
\family typewriter 
\size small 
-trigger
\family default 
\size default 
 option: with 
\family typewriter 
\size small 
-trigger
\family default 
\size default 
, the program starts in native mode until the trigger point (if any) is
 reached.
\layout Section

Notes on Benchmarking Methodology
\layout Standard

The x86 instruction set requires some different benchmarking techniques
 than classical RISC ISAs.
 In particular, 
\series bold 
IPC (Instructions per Cycle) a NOT a good measure of performance for an
 x86 processor.

\series default 
 Because one x86 instruction may be broken up into numerous uops, it is
 never appropriate to compare IPC figures for committed x86 instructions
 per clock with IPC values from a RISC machine.
 Furthermore, different x86 implementations use varying numbers of uops
 per x86 instruction as a matter of encoding, so even comparing the uop
 based IPC between x86 implementations or RISC-like machines is inaccurate.
\layout Standard

Users are strongly advised to use relative performance measures instead.
 Comparing the total simulated cycle count required to complete a given
 benchmark between different simulator configurations is much more appropriate
 than IPC with the x86 instruction set.
 An example would be "the baseline took 100M cycles, while our improved
 system took 50M cycles, for a 2x improvement.
\layout Section

Simulation Warmup Periods
\layout Standard

In some simulators, it is possible to quickly skip through a specific number
 of instructions before starting to gather statistics, to avoid including
 initialization code in the statistics.
 In PTLsim, this is neither necessary nor desirable.
 Because PTLsim directly executes your program on the host CPU until it
 switches to cycle accurate simulation mode, there is no way to count instructio
ns in this manner.
 
\layout Standard

Many researchers have gotten in the habit of blindly skipping a large number
 of instructions in benchmarks to avoid profiling initialization code.
 However, this is not a very intelligent policy: different benchmarks have
 different startup times until the top of the main loop is reached, and
 it is generally evident from the benchmark source code where that point
 should be.
 Therefore, PTLsim supports 
\series bold 
trigger points:
\series default 
 by inserting a special function call (
\family typewriter 
\size small 
ptlcall_switch_to_sim
\family default 
\size default 
) within the benchmark source code and recompiling, the 
\family typewriter 
\size small 
-trigger
\family default 
\size default 
 PTLsim option can be used to run the code on the host CPU until the trigger
 point is reached.
 If the source code is unavailable, the 
\family typewriter 
\size small 
-startrip 
\emph on 
0xADDRESS
\family default 
\size default 
\emph default 
 option will start full simulation only at a specified address (e.g.
 function entry point).
 
\layout Standard

If you want to warm up the cache and branch predictors prior to starting
 statistics collection, combine the 
\family typewriter 
\size small 
-trigger
\family default 
\size default 
 option with the 
\family typewriter 
\size small 
-snapshot 
\emph on 
N
\family default 
\size default 
\emph default 
 option, to start full simulation at the top of the benchmark's main loop
 (where the trigger call is), but only start gathering statistics 
\emph on 
N
\emph default 
 cycles later, after the processor is warmed up.
 Remember, since the trigger point is placed 
\emph on 
after
\emph default 
 all initialization code in the benchmark, in general it is only necessary
 to use 10-20 million cycles of warmup time before taking the first statistics
 snapshot.
 In this time, the caches and branch predictor will almost always be completely
 overwritten many times.
 This approach significantly speeds up the simulation without any loss of
 accuracy compared to the "fast simulation" mode provided by other simulators.
 
\layout Standard

In PTLstats, use the 
\family typewriter 
\size small 
-delta
\family default 
\size default 
 option to make sure the final statistics don't include the warmup period
 before the first snapshot.
 To subtract the final snapshot from snapshot 0 (the first snapshot after
 the warmup period), use a command similar to the following:
\layout LyX-Code


\size small 
ptlstats -deltastart 0 ptlsim.stats > ptlsim.stats.txt
\layout Section


\begin_inset LatexCommand \label{sec:SequentialMode}

\end_inset 

Sequential Mode
\layout Standard

PTLsim also supports 
\emph on 
sequential mode
\emph default 
, in which instructions are run on a simple, in-order processor model (in
 
\family typewriter 
\size small 
seqcore.cpp
\family default 
\size default 
) without accounting for cache misses, branch mispredicts and so forth.
 This is several times faster than the out of order model, but is obviously
 far slower than native execution.
 The purpose of sequential mode is mainly to aid in testing the x86 to uop
 decoding pipeline and uop implementation code.
 It may also be useful for gathering certain statistics on the instruction
 mix and count without running a full simulation.
 In the future we will extend sequential mode to optionally update the same
 data caches and branch predictor used by the out of order core so as to
 warm them up before starting the more detailed out of order simulation.
\layout Standard

If enabled, sequential mode always runs the processor for the specified
 number of committed instructions.
 At that point, execution switches to the out of order core for the remainder
 of the simulation.
 The specific configuration file symtax is:
\layout LyX-Code


\size small 
-seq 
\emph on 
N
\layout Standard

where 
\emph on 
N
\emph default 
 is the number of x86 instructions to commit.
 These 
\emph on 
N
\emph default 
 instructions are 
\emph on 
included
\emph default 
 in the total number of instructions to simulate (
\family typewriter 
\size small 
-stopinsns
\family default 
\size default 
 parameter).
 However, the cycle counter is reset to zero whenever out of order mode
 is entered, so it does not count against any 
\family typewriter 
\size small 
-stop 
\emph on 
cycles
\family default 
\size default 
\emph default 
 parameter.
 If the program exits while in sequential mode, the out of order core is
 never enabled.
 Therefore, to execute the entire program in sequential mode (for instance,
 for testing or profiling only), use the following:
\layout LyX-Code


\size small 
-seq inf -stopinsns 0
\layout Section

Performance and Statistical Counters
\layout Standard

The full list of PTLsim performance and statistical counters is given in
 Section 
\begin_inset LatexCommand \ref{sec:PerformanceCounters}

\end_inset 

.
\layout Chapter


\begin_inset LatexCommand \label{part:x86andUops}

\end_inset 

x86 Instructions and Micro-Ops (uops)
\layout Section


\begin_inset LatexCommand \label{sec:UopIntro}

\end_inset 

Micro-Ops (uops) and TransOps
\layout Standard

PTLsim presents to user code a full implementation of the x86 and x86-64
 instruction set (both 32-bit and 64-bit modes), including most user level
 instructions supported by the Intel Pentium 4 and AMD K8 microprocessors
 (i.e.
 all standard instructions, SSE/SSE2, x86-64 and most of x87 FP).
 At the present stage of development, the vast majority of all userspace
 instructions are implemented.
 
\layout Standard

The x86 instruction set is based on the two-operand CISC concept of load-and-com
pute and load-compute-store.
 However, modern x86 processors (including PTLsim) do not directly execute
 complex x86 instructions.
 Instead, these processors translate each x86 instruction into a series
 of micro-operations (
\emph on 
uops
\emph default 
) very similar to classical load-store RISC instructions.
 Uops can be executed very efficiently on an out of order core, unlike x86
 instructions.
 In PTLsim, uops have three source registers and one destination register.
 They may generate a 64-bit result and various x86 status flags, or may
 be loads, stores or branches.
\layout Standard

The x86 instruction decoding process initially generates translated uops
 (
\emph on 
transops
\emph default 
), which have a slightly different structure than the true uops used in
 the processor core.
 Specifically, sources and destinations are represented as un-renamed architectu
ral registers (or special temporary register numbers), and a variety of
 additional information is attached to each uop only needed during the renaming
 and retirement process.
 TransOps (represented by the 
\family typewriter 
\size small 
TransOp
\family default 
\size default 
 structure) consist of the following:
\layout Itemize


\family typewriter 
\size small 
som
\family default 
\size default 
: Start of Macro-Op.
 Since x86 instructions may consist of multiple transops, the first transop
 in the sequence has its 
\family typewriter 
\size small 
som
\family default 
\size default 
 bit set to indicate this.
\layout Itemize


\family typewriter 
\size small 
eom
\family default 
\size default 
: End of Macro-Op.
 This bit is set for the last transop in a given x86 instruction (which
 may also be the first uop for single-uop instructions)
\layout Itemize


\family typewriter 
\size small 
bytes
\family default 
\size default 
: Number of bytes in the corresponding x86 instruction (1-15).
 This is only valid for a SOM uop.
\layout Itemize


\family typewriter 
\size small 
opcode
\family default 
\size default 
: the uop (not x86) opcode
\layout Itemize


\family typewriter 
\size small 
size
\family default 
\size default 
: the effective operation size (0-3, for 1/2/4/8 bytes)
\layout Itemize


\family typewriter 
\size small 
cond:
\family default 
\size default 
 the x86 condition code for branches, selects, sets, etc.
 For loads and stores, this field is reused to specify unaligned access
 information as described later.
\layout Itemize


\family typewriter 
\size small 
setflags
\family default 
\size default 
: subset of the x86 flags set by this uop (see Section 
\begin_inset LatexCommand \ref{sub:FlagsManagement}

\end_inset 

)
\layout Itemize


\family typewriter 
\size small 
internal
\family default 
\size default 
: set for certain microcode operations.
 For instance, loads and stores marked internal access on-chip registers
 or buffers invisible to x86 code (e.g.
 machine state registers, segmentation caches, floating point constant tables,
 etc).
\layout Itemize


\family typewriter 
\size small 
rd
\family default 
\size default 
, 
\family typewriter 
\size small 
ra
\family default 
\size default 
, 
\family typewriter 
\size small 
rb
\family default 
\size default 
, 
\family typewriter 
\size small 
rc
\family default 
\size default 
: the architectural source and destination registers (see Section 
\begin_inset LatexCommand \ref{sub:RegisterRenaming}

\end_inset 

)
\layout Itemize


\family typewriter 
\size small 
extshift
\family default 
\size default 
: shift amount (0-3 bits) used for shifted adds (x86 memory addressing and
 LEA).
 The 
\family typewriter 
\size small 
rc
\family default 
\size default 
 operand is shifted left by this amount.
\layout Itemize


\family typewriter 
\size small 
cachelevel
\family default 
\size default 
: used for prefetching and non-temporal loads and stores
\layout Itemize


\family typewriter 
\size small 
rbimm
\family default 
\size default 
 and 
\family typewriter 
\size small 
rcimm
\family default 
\size default 
: signed 64-bit immediates for the rb and rc operands.
 These are selected by specifying the special constant 
\family typewriter 
\size small 
REG_imm
\family default 
\size default 
 in the 
\family typewriter 
\size small 
rb
\family default 
\size default 
 and 
\family typewriter 
\size small 
rc
\family default 
\size default 
 fields, respectively.
\layout Itemize


\family typewriter 
\size small 
riptaken
\family default 
\size default 
: for branches only, the 64-bit target RIP of the branch if it were taken.
\layout Itemize


\family typewriter 
\size small 
ripseq
\family default 
\size default 
: for branches only, the 64-bit sequential RIP of the branch if it were
 not taken.
\layout Standard

There may be other fields used for debugging or not relevant to the out
 of order version of the simulator; these should be ignored.
\layout Section

Descriptions of uops
\layout Standard

Section 
\begin_inset LatexCommand \ref{sec:UopReference}

\end_inset 

 describes the semantics and encoding of all uops supported by the PTLsim
 processor model.
 The following is an overview of these uops.
\layout Section

Simple Fast Path Instructions
\layout Standard

Simple integer and floating point operations are fairly straightforward
 to decode into loads, stores and ALU operations; a typical load-op-store
 ALU operation will consist of a load to fetch one operand, the ALU operation
 itself, and a store to write the result.
 The instruction set also implements a number of important but complex instructi
ons with bizarre semantics; typically the translator will synthesize and
 inject into the uop stream up to 8 uops for more complex instructions.
 
\layout Section

x86-64
\layout Standard

The 64-bit x86-64 instruction set is a fairly straightforward extension
 of the 32-bit IA-32 (x86) instruction set.
 The x86-64 ISA was introduced by AMD in 2000 with its K8 microarchitecture;
 the same instructions were subsequently plagiarized by Intel under a different
 name several years later.
 In addition to extending all integer registers and ALU datapaths to 64
 bits, x86-64 also provides a total of 16 integer general purpose registers
 and 16 SSE (vector floating and fixed point) registers.
 It also introduced several 64-bit address space simplifications, including
 RIP-relative addressing and corresponding new addressing modes, and eliminated
 a number of legacy features from 64-bit mode, including segmentation, BCD
 arithmetic, some byte register manipulation, etc.
 Limited forms of segmentation are still present to allow thread local storage
 and mark code segments as 64-bit.
 In general, the encoding of x86-64 and x86 are very similar, with 64-bit
 mode adding a one byte REX prefix to specify additional bits for source
 and destination register indexes and effective address size.
 As a result, both variants can be decoded by similar decoding logic into
 a common set of uops.
\layout Section


\begin_inset LatexCommand \label{sec:OperationSizes}

\end_inset 

Operation Sizes
\layout Standard

Most x86-64 instructions can operate on 8, 16, 32 or 64 bits of a given
 register.
 For 8-bit and 16-bit operations, only the low 8 or 16 bits of the destination
 register are actually updated; 32-bit and 64-bit operations are zero extended
 as with RISC architectures.
 As a result, a dependency on the old destination register may be introduced
 so merging can be performed.
 Fortunately, since x86 features destructive overwrites of the destination
 register (i.e.
 the 
\family typewriter 
\size small 
rd
\family default 
\size default 
 and 
\family typewriter 
\size small 
ra
\family default 
\size default 
 operands are the same), the 
\family typewriter 
\size small 
ra
\family default 
\size default 
 operand is generally already a dependency.
 Thus, the PT2x uop encoding reserves 2 bits to specify the operation size;
 the low bits of the new result are automatically merged with the old destinatio
n value (in 
\family typewriter 
\size small 
ra
\family default 
\size default 
) as part of the ALU logic.
 This applies to the 
\family typewriter 
\size small 
mov
\family default 
\size default 
 uop as well, allowing operations like 
\begin_inset Quotes eld
\end_inset 


\family typewriter 
\size small 
mov al,bl
\family default 
\size default 

\begin_inset Quotes erd
\end_inset 

 in one uop.
 Loads do not support this mode, so loads into 8-bit and 16-bit registers
 must be followed by a separate 
\family typewriter 
\size small 
mov
\family default 
\size default 
 uop to truncate and merge the loaded value into the old destination properly.
\layout Standard

The x86 ISA defines some bizarre byte operations as a carryover from the
 ancient 8086 architecture; for instance, it is possible to address the
 second byte of many integer registers as a separate register (i.e.
 as 
\family typewriter 
\size small 
ah
\family default 
\size default 
, 
\family typewriter 
\size small 
bh
\family default 
\size default 
, 
\family typewriter 
\size small 
ch
\family default 
\size default 
, 
\family typewriter 
\size small 
dh
\family default 
\size default 
).
 The 
\family typewriter 
\size small 
mask
\family default 
\size default 
 uop is used for handling this rare but important set of operations.
\layout Section


\begin_inset LatexCommand \label{sub:FlagsManagement}

\end_inset 

Flags Management and Register Renaming
\layout Standard

Many x86 arithmetic instructions modify some or all of the processor's numerous
 status and condition flag bits, but only 5 are relevant to normal execution:
 Zero, Parity, Sign, Overflow, Carry.
 In accordance with the well-known 
\begin_inset Quotes eld
\end_inset 

ZAPS rule
\begin_inset Quotes erd
\end_inset 

, any instruction that updates any of the Z/P/S flags updates all three
 flags, so in reality only three flag entities need to be tracked: ZPS,
 O, F (
\begin_inset Quotes eld
\end_inset 

ZAPS
\begin_inset Quotes erd
\end_inset 

 also includes an Auxiliary flag not accessible by most modern user instructions
; it is irrelevant to the discussion below).
\layout Standard

The x86 flag update semantics can hamper out of order execution, so we use
 a simple and well known solution.
 The 5 flag bits are attached to each result and physical register (along
 with the invalid and waiting bits described in Section 
\begin_inset LatexCommand \ref{sec:PhysicalRegisters}

\end_inset 

); these bits are then consumed along with the actual result value by any
 consumers that also need to access the flags.
 It should be noted that not all uops generate all the flags as well as
 a 64-bit result, and some uops only generate flags and no result data.
 
\layout Standard

The register renaming mechanism is aware of these semantics, and tracks
 the latest x86 instruction in program order to update each set of flags
 (ZAPS, C, O); this allows branches and other flag consumers to directly
 access the result with the most recent program-ordered flag updates yet
 still allows full out of order scheduling.
 To do this, x86 processors maintain three separate rename table entries
 for the ZAPS, CF, OF flags in addition to the register rename table entry,
 any or all of which may be updated when uops are renamed.
 The 
\family typewriter 
\size small 
TransOp
\family default 
\size default 
 structure for each uop has a 3-bit 
\family typewriter 
\size small 
setflags
\family default 
\size default 
 field filled out during decoding in accordance with x86 semantics; the
 
\family typewriter 
\size small 
SETFLAG_ZF
\family default 
\size default 
, 
\family typewriter 
\size small 
SETFLAG_CF
\family default 
\size default 
, 
\family typewriter 
\size small 
SETFLAG_OF
\family default 
\size default 
 bits in this field are used to determine which of the ZPS, O, F flag subsets
 to rename.
\layout Standard

As mentioned above, any consumer of the flags needs to consult at most three
 distinct sources: the last ZAPS producer, the Carry producer and the Overflow
 producer.
 This conveniently fits into PTLsim's three-operand uop semantics.
 Various special uops access the flags associated with an operand rather
 than the 64-bit operand data itself.
 Branches always take two flag sources, since in x86 this is enough to evaluate
 any possible condition code combination (the 
\family typewriter 
\size small 
cond_code_to_flag_regs
\family default 
\size default 
 array provides this mapping).
 Various ALU instructions consume only the flags part of a source physical
 register; these include 
\family typewriter 
\size small 
addc
\family default 
\size default 
 (add with carry), 
\family typewriter 
\size small 
rcl/rcr
\family default 
\size default 
 (rotate carry), 
\family typewriter 
\size small 
sel.
\emph on 
cc
\family default 
\size default 
\emph default 
 (select for conditional moves) and so on.
 Finally, the 
\family typewriter 
\size small 
collcc
\family default 
\size default 
 uop takes three operands (the latest producer of the ZAPS, CF and OF flags)
 and merges the flag components of each operand into a single flag set as
 its result.
 These uops are all documented in Section 
\begin_inset LatexCommand \ref{sec:UopReference}

\end_inset 

.
\layout Section


\begin_inset LatexCommand \label{sub:UnalignedLoadsAndStores}

\end_inset 

Unaligned Loads and Stores
\layout Standard

Compared to RISC architectures, the x86 architecture is infamous for its
 relatively widespread use of unaligned memory operations; any implementation
 must efficiently handle this scenario.
 Fortunately, analysis shows that unaligned accesses are rarely in the performan
ce intensive parts of a modern program, so we can aggressively eliminate
 them on contact through rescheduling.
 PTLsim does this by initially causing all unaligned loads and stores to
 raise an 
\family typewriter 
\size small 
UnalignedAccess
\family default 
\size default 
 internal exception, forcing a pipeline flush.
 At this point, a special 
\begin_inset Quotes eld
\end_inset 

unaligned
\begin_inset Quotes erd
\end_inset 

 bit is set for the problem load or store in its translated basic block
 representation.
 The sequential basic block is then retranslated such that when the x86
 instruction with the problem RIP is encountered, the offending load or
 store is split into two aligned loads or stores.
\layout Standard

PTLsim includes special uops to handle loads and stores split into two in
 this manner.
 The 
\family typewriter 
\size small 
ld.lo
\family default 
\size default 
 uop rounds down its effective address 
\begin_inset Formula $\left\lfloor A\right\rfloor $
\end_inset 

 to the nearest 64-bit boundary and performs the load.
 The 
\family typewriter 
\size small 
ld.hi
\family default 
\size default 
 uop rounds up to 
\begin_inset Formula $\left\lceil A+8\right\rceil $
\end_inset 

, performs another load, then takes as its third rc operand the first (
\family typewriter 
\size small 
ld.lo
\family default 
\size default 
) load's result.
 The two loads are concatenated into a 128-bit word and the final unaligned
 data is extracted.
 Stores are handled in a similar manner, with 
\family typewriter 
\size small 
st.lo
\family default 
\size default 
 and 
\family typewriter 
\size small 
st.hi
\family default 
\size default 
 rounding down and up to store parts of the unaligned value in adjacent
 64-bit blocks.
 Just as with normal loads and stores, these unaligned load or store pairs
 access separate store buffers for each half as if they were independent.
\layout Section

Repeated String Operations
\layout Standard

The x86 architecture allows for repeated string operations, including block
 moves, stores, compares and scans.
 The iteration count of these repeated operations depends on a combination
 of the 
\family typewriter 
\size small 
rcx
\family default 
\size default 
 register and the flags set by the repeated operation (e.g.
 compare).
 To translate these instructions, PTL treats the 
\family typewriter 
\size small 
rep xxx
\family default 
\size default 
 instruction as a single basic block; any basic block in progress before
 the repeat instruction is capped and the repeat is translated as a separate
 basic block.
 This conveniently lets us unroll and optimize the repeated loop just like
 any other basic block.
 To handle the unusual case where the repeat count is zero, a check instruction
 is inserted at the top of the loop to protect against this case; PTL simply
 bypasses the offending block if the check fails.
\layout Section


\begin_inset LatexCommand \label{sec:ShiftRotateProblems}

\end_inset 

Problem Instructions
\layout Standard

The shift and rotate instructions have some of the most bizarre semantics
 in the entire x86 instruction set: they may or may not modify a subset
 of the flags depending on the rotation count operand, which we may not
 even know until the instruction issues.
 For fixed shifts and rotates, these semantics can be preserved by the uops
 generated, however variable rotations are more complex.
 The 
\family typewriter 
\size small 
collcc
\family default 
\size default 
 uop is put to use here to collect all flags; the collected result is then
 fed into the shift or rotate uop as its 
\family typewriter 
\size small 
rc
\family default 
\size default 
 operand; the uop then replicates the precise x86 behavior (including rotates
 using the carry flag) according to its input operands.
\layout Section

SSE Support
\layout Standard

PTLsim provides full support for SSE and SSE2 vector floating point and
 fixed point, in both scalar and vector mode.
 As is done in the AMD K8, each SSE operation on a 128-bit vector is split
 into two 64-bit halves; each half (possibly consisting of a 64-bit load
 and one or more FPU operations) is scheduled independently.
 Because SSE instructions do not set flags like x86 integer instructions,
 architectural state management can be restricted to the 16 128-bit SSE
 registers (represented as 32 paired 64-bit registers) and a single 
\family typewriter 
\size small 
mxcsr
\family default 
\size default 
 architectural register containing sticky exception bits, which has no effect
 on out of order execution).
 The processor's floating point units can operate in either 64-bit IEEE
 double precision mode or on two parallel 32-bit single precision values.
\layout Section


\begin_inset LatexCommand \label{sub:x87-Floating-Point}

\end_inset 

x87 Floating Point
\layout Standard

The legacy x87 floating point architecture is the bane of all x86 processor
 vendors' existence, largely because its stack based nature makes out of
 order processing so difficult.
 While there are certainly ways of translating stack based instruction sets
 into flat addressing for scheduling purposes, we do not do this.
 Fortunately, following the Pentium III and AMD Athlon's introduction, x87
 is rapidly headed for planned obsolescence; most major applications released
 within the last three years now use SSE instructions for their floating
 point needs either exclusively or in all performance critical parts.
 To this end, even Intel has relegated x86 support on the Pentium 4 to a
 separate low performance in-order legacy unit, and AMD has severely restricted
 its use in 64-bit mode.
 For this reason, PTLsim translates legacy x87 instructions into a serialized,
 program ordered and emulated form; the hardware does not contain any x87-style
 80-bit floating point registers (all floating point hardware is 32-bit
 and 64-bit IEEE compliant).
 We have noticed little to no performance problem from this approach when
 examining typical binaries, which rarely if ever still use x87 instructions
 in compute-intensive code.
\layout Section

Assists
\layout Standard

Some operations are too complex to inline directly into the uop stream.
 To perform these instructions, a special uop (
\family typewriter 
\size small 
brp
\family default 
\size default 
: branch private) is executed to branch to an 
\emph on 
assist
\emph default 
 function implemented in microcode.
 In PTLsim, some assist functions are implemented as regular C/C++ or assembly
 language code when they interact with the rest of the virtual machine.
 Examples of instructions requiring assists include system calls, interrupts,
 some forms of integer division, handling of rare floating point conditions,
 CPUID, MSR reads/writes, etc.
 These are listed in the 
\family typewriter 
\size small 
ASSIST_xxx
\family default 
\size default 
 enum found in 
\family typewriter 
\size small 
translate-x86.cpp
\family default 
\size default 
 and 
\family typewriter 
\size small 
ptlhwdef.h
\family default 
\size default 
.
\layout Standard

When the processor issues an assist (
\family typewriter 
\size small 
brp
\family default 
\size default 
 uop), the frontend pipeline is stalled and execution waits until the 
\family typewriter 
\size small 
brp
\family default 
\size default 
 commits, at which point an assist function within PTLsim is called.
 In a real processor there are more efficient ways of doing this without
 flushing the pipeline, however in PTLsim assists are sufficiently rare
 that the performance impact is negligible and this approach significantly
 reduces complexity.
 The exact mechanism used is described in Section 
\begin_inset LatexCommand \ref{sec:PipelineFlushesAndBarriers}

\end_inset 

.
\layout Part


\begin_inset LatexCommand \label{part:OutOfOrderModel}

\end_inset 

Out of Order Processor Model
\layout Chapter


\begin_inset LatexCommand \label{sec:OutOfOrderFeatures}

\end_inset 

Introduction
\layout Standard

PTLsim completely models a modern out of order x86-64 compatible processor
 and cache hierarchy with cycle accurate simulation.
 The basic microarchitecture of this model is most similar to the Intel
 Pentium 4 processor, but incorporates some ideas from AMD K8, IBM Power4/Power5
 and Alpha EV8.
 The following is a summary of the characteristics of this processor model:
\layout Itemize

The simulator directly fetches pre-decoded micro-operations (Section 
\begin_inset LatexCommand \ref{sec:FetchStage}

\end_inset 

) but can simulate cache accesses as if x86 instructions were being decoded
 on fetch
\layout Itemize

Branch prediction is configurable; PTLsim currently includes various models
 including a hybrid g-share based predictor, bimodal predictors, saturating
 counters, etc.
\layout Itemize

Register renaming takes into account x86 quirks such as flags renaming (Section
 
\begin_inset LatexCommand \ref{sub:FlagsManagement}

\end_inset 

)
\layout Itemize

Front end pipeline has configurable number of cycles to simulate x86 decoding
 or other tasks; this is used for adjusting the branch mispredict penalty
\layout Itemize

Unified physical and architectural register file maps both in-flight uops
 as well as committed architectural register values.
 Two rename tables (speculative and committed register rename tables) are
 used to track which physical registers are currently mapped to architectural
 registers.
\layout Itemize

Unified physical register file for both integer and floating point values.
\layout Itemize

Operands are read from the physical register file immediately before issue.
 Unlike in some microprocessors, PTLsim does not do speculative scheduling:
 the schedule and register read loop is assumed to take one cycle.
\layout Itemize

Issue queues based on a collapsing design use broadcast based matching to
 wake up instructions.
\layout Itemize

Clustered microarchitecture is highly configurable, allowing multi-cycle
 latencies between clusters and multiple issue queues within the same logical
 cluster.
\layout Itemize

Functional units, mapping of functional units to clusters, issue ports and
 issue queues and uop latencies are all configurable.
\layout Itemize

Speculation recovery from branch mispredictions and load/store aliasing
 uses the forward walk method to recover the rename tables, then annuls
 all uops after and optionally including the mis-speculated uop.
\layout Itemize

Replay of loads and stores after store to load forwarding and store to store
 merging dependencies are discovered.
\layout Itemize

Stores may issue even before data to store is known; the store uop is replayed
 when all operands arrive.
\layout Itemize

Load and store queues use partial chunk address matching and store merging
 for high performance and easy circuit implementation.
\layout Itemize

Prediction of load/store aliasing to avoid mis-speculation recovery overhead.
\layout Itemize

Prediction and splitting of unaligned loads and stores to avoid mis-speculation
 overhead
\layout Itemize

Commit unit supports stalling until all uops in an x86 instruction are complete,
 to make x86 instruction commitment atomic
\layout Standard

The PTLsim model is fully configurable in terms of the sizes of key structures,
 pipeline widths, latency and bandwidth and numerous other features.
\layout Chapter

Fetch Stage
\layout Section


\begin_inset LatexCommand \label{sec:FetchStage}

\end_inset 

Instruction Fetching and the Basic Block Cache
\layout Standard

As described in Section 
\begin_inset LatexCommand \ref{sec:UopIntro}

\end_inset 

, x86 instructions are decoded into transops prior to actual execution by
 the out of order core.
 Some processors do this translation as x86 instructions are fetched from
 an L1 instruction cache, while others use a trace cache to store pre-decoded
 uops.
 PTLsim takes a middle ground to allow maximum simulation flexibility.
 Specifically, the Fetch stage accesses the L1 instruction cache and stalls
 on cache misses as if it were fetching several variable length x86 instructions
 per cycle.
 However, actually decoding x86 instructions into uops over and over again
 during simulation would be extraordinarily slow.
 
\layout Standard

Therefore, for 
\emph on 
simulation purposes only
\emph default 
, PTLsim maintains a 
\emph on 
basic block cache
\emph default 
 containing the program ordered translated uop (
\emph on 
transop
\emph default 
) sequence for previously decoded basic blocks in the program.
 Each basic block (
\family typewriter 
\size small 
BasicBlock
\family default 
\size default 
 structure) consists of up to 64 transops and is terminated by either a
 control flow operation (conditional, unconditional, indirect branch) or
 a barrier operation (e.g.
 system call, synchronizing instruction, etc).
 During the fetch process (implemented in the 
\family typewriter 
\size small 
fetch()
\family default 
\size default 
 function), PTLsim looks up the current RIP to fetch from and uses the basic
 block cache to map that RIP to a BasicBlock structure.
 The transop stream is then read from that decoded basic block in lieu of
 decoding the x86 instructions again.
 As execution runs off the end of each decoded basic block, the fetch unit
 checks if the next RIP exists in the basic block cache.
 If so, the next block is streamed into the fetch queue.
 Otherwise, the x86-to-transop translator is called via 
\family typewriter 
\size small 
translate_basic_block()
\family default 
\size default 
 to translate an entire basic block at the current RIP before resuming execution.
 Since the basic block cache is for simulation purposes only, this adds
 no additional cycles to the simulated program.
\layout Standard

An additional optimization, called 
\emph on 
synthesis
\emph default 
, is also used: each uop in the basic block is mapped to the address of
 a native PTLsim function implementing the semantics of that uop.
 This saves us from having to use a large jump table later on, and can map
 uops to pre-compiled templates that avoid nearly all further decoding of
 the uop during execution.
\layout Section

Fetch Queue
\layout Standard

Each transop fetched into the pipeline is immediately assigned a monotonically
 increasing 
\emph on 
uuid
\emph default 
 (universally unique identifier) to uniquely track it for debugging and
 statistical purposes.
 The fetch unit attaches additional information to each transop (such as
 the uop's uuid and the RIP of the corresponding x86 instruction) to form
 a 
\family typewriter 
\size small 
FetchBufferEntry
\family default 
\size default 
 structure.
 This fetch buffer is then placed into the fetch queue (
\family typewriter 
\size small 
fetchq
\family default 
\size default 
) assuming it isn't full (if it is, the fetch stage stalls).
 As the fetch unit encounters transops with their EOM (end of macro-op)
 bit set, the fetch RIP is advanced to the next x86 instruction according
 to the instruction length stored in the SOM transop.
\layout Standard

Branch uops trigger the branch prediction mechanism used to select the next
 fetch RIP.
 Based on various information encoded in the branch transop and the next
 RIP 
\emph on 
after
\emph default 
 the x86 instruction containing the branch, the 
\family typewriter 
\size small 
branchpred.predict()
\family default 
\size default 
 function is used to redirect fetching.
 If the branch is predicted not taken, the sense of the branch's condition
 code is inverted and the transop's 
\family typewriter 
\size small 
riptaken
\family default 
\size default 
 and 
\family typewriter 
\size small 
ripseq
\family default 
\size default 
 fields are swapped; this ensures all branches are considered correct only
 if taken.
 Indirect branches (jumps) have their 
\family typewriter 
\size small 
riptaken
\family default 
\size default 
 field overwritten by the predicted target address.
\layout Chapter

Frontend and Key Structures
\layout Section

Resource Allocation
\layout Standard

During the Allocate stage, PTLsim dequeues uops from the fetch queue, ensures
 all resources needed by those uops are free, and assigns resources to each
 uop as needed.
 These resources include Reorder Buffer (ROB) slots, physical registers
 and load store queue (LSQ) entries.
 In the event that the fetch queue is empty or any of the ROB, physical
 register file, load queue or store queue is full, the allocation stage
 stalls until some resources become available.
\layout Section

Reorder Buffer Entries
\layout Standard

The Reorder Buffer (ROB) in the PTLsim out of order model works exactly
 like a traditional ROB: as a queue, entries are allocated from the tail
 and committed from the head.
 Each 
\family typewriter 
\size small 
ReorderBufferEntry
\family default 
\size default 
 structure is the central tracking structure for uops in the pipeline.
 This structure contains a variety of fields including:
\layout Itemize

The decoded uop (
\family typewriter 
\size small 
uop
\family default 
\size default 
 field).
 This is the fully decoded 
\family typewriter 
\size small 
TransOp
\family default 
\size default 
 augmented with fetch-related information like the uop's UUID, RIP and branch
 predictor information as described in the Fetch stage (Section 
\begin_inset LatexCommand \ref{sec:FetchStage}

\end_inset 

).
\layout Itemize

Current state of the ROB entry and uop (
\family typewriter 
\size small 
current_state_list
\family default 
\size default 
; see below)
\layout Itemize

Pointers to the physical register (
\family typewriter 
\size small 
physreg
\family default 
\size default 
), LSQ entry (
\family typewriter 
\size small 
lsq
\family default 
\size default 
) and other resources allocated to the uop
\layout Itemize

Pointers to the three physical register operands to the uop, as well as
 a possible store dependency used in replay scheduling (described later)
\layout Itemize

Various cycle counters and related fields for simulating progress through
 the pipeline
\layout Subsection

ROB States
\layout Standard

Each ROB entry and corresponding uop can be in one of a number of states
 describing its progress through the simulator state machine.
 ROBs are linked into linked lists according to their current state; these
 lists are named 
\family typewriter 
\size small 
rob_
\family default 
\size default 
\emph on 
statename
\family typewriter 
\size small 
\emph default 
_list
\family default 
\size default 
.
 The 
\family typewriter 
\size small 
current_state_list
\family default 
\size default 
 field specifies the list the ROB is currently on.
 ROBs can be moved between states using the 
\family typewriter 
\size small 
ROB::changestate(
\emph on 
statelist
\emph default 
)
\family default 
\size default 
 method.
 The specific states will be described below as they are encountered.
\layout Standard


\series bold 
\emph on 
NOTE:
\series default 
\emph default 
 the terms 
\begin_inset Quotes eld
\end_inset 

ROB entry
\begin_inset Quotes erd
\end_inset 

 (singular) and 
\begin_inset Quotes eld
\end_inset 

uop
\begin_inset Quotes erd
\end_inset 

 are used interchangeably from now on unless otherwise stated, since there
 is a 1:1 mapping between the two.
\layout Section


\begin_inset LatexCommand \label{sec:PhysicalRegisters}

\end_inset 

Physical Registers
\layout Subsection

Physical Registers
\layout Standard

Physical registers are represented in PTLsim by the 
\family typewriter 
\size small 
PhysicalRegister
\family default 
\size default 
 structure.
 Physical registers store several components:
\layout Itemize

Index of the physical register (
\family typewriter 
\size small 
idx
\family default 
\size default 
) and the physical register file id (
\family typewriter 
\size small 
rfid
\family default 
\size default 
) to which it belongs
\layout Itemize

The actual 64-bit register data
\layout Itemize

x86 flags: Z, P, S, O, C.
 These are discussed below in Section 
\begin_inset LatexCommand \ref{sub:FlagsManagement}

\end_inset 

.
\layout Itemize

Waiting flag (
\family typewriter 
\size small 
FLAG_WAIT
\family default 
\size default 
) for results not yet ready
\layout Itemize

Invalid flag (
\family typewriter 
\size small 
FLAG_INVAL
\family default 
\size default 
) for ready results which encountered an exception.
 The exception code is written to the data field in lieu of the real result
\layout Itemize

Current state of the physical register (
\family typewriter 
\size small 
state
\family default 
\size default 
)
\layout Itemize

ROB currently owning this physical register, or architectural register mapping
 this physical register
\layout Itemize

Reference counter for the physical register.
 This is required for reasons described in Section 
\begin_inset LatexCommand \ref{sub:PhysicalRegisterRecyclingComplications}

\end_inset 

.
\layout Subsection

Physical Register File
\layout Standard

PTLsim uses a flexible physical register file model in which multiple physical
 register files with different sizes and properties can optionally be defined.
 Each physical register file in the 
\family typewriter 
\size small 
physregfiles[]
\family default 
\size default 
 array can be made accessible from one or more clusters.
 For instance, uops which execute on floating point clusters can be forced
 to always allocate a register in the floating point register file, or each
 cluster can have a dedicated register file.
\layout Standard

Various heuristics can also be used for selecting the register file into
 which a result is placed.
 The default heuristic simply finds the first acceptable physical register
 file with a free register.
 Acceptable physical register files are those register files in which the
 uop being allocated is allowed to write its result; this is configurable
 based on clustering as described below.
 Other allocation policies, such as alternation between available register
 files and dependency based register allocation, are all possible by modifying
 the 
\family typewriter 
\size small 
rename()
\family default 
\size default 
 function where physical registers are allocated..
\layout Standard

In each physical register file, physical register number 0 is defined as
 the 
\emph on 
null register:
\emph default 
 it always contains the value zero and is used as an operand anywhere the
 zero value (or no value at all) is required.
\layout Standard

Physical register files are configured in 
\family typewriter 
\size small 
ooohwdef.h
\family default 
\size default 
.
 The 
\family typewriter 
\size small 
PhysicalRegisterFile[]
\family default 
\size default 
 array is defined to declare each register file by name, register file ID
 (RFID, from 0 to the number of register files) and size.
 The 
\family typewriter 
\size small 
MAX_PHYS_REG_FILE_SIZE
\family default 
\size default 
 parameter must be greater than the largest physical register in the processor.
\layout Subsection

Physical Register States
\layout Standard

Each physical register can be in one of several states at any given time.
 For each physical register file, PTLsim maintains linked lists (the 
\family typewriter 
\size small 
PhysicalRegisterFile.states[
\family default 
\size default 
\emph on 
statename
\family typewriter 
\size small 
\emph default 
]
\family default 
\size default 
 lists) to track which registers are in each state.
 The 
\family typewriter 
\size small 
state
\family default 
\size default 
 field in each physical register specifies its state, and implies that the
 physical register is on the list 
\family typewriter 
\size small 
physregfiles[physreg.
\series bold 
rfid
\series default 
].states[physreg.
\series bold 
state
\series default 
]
\family default 
\size default 
.
 The valid states are:
\layout Itemize


\series bold 
\emph on 
free:
\series default 
\emph default 
 the register is not allocated to any uop.
\layout Itemize


\series bold 
\emph on 
waiting:
\series default 
\emph default 
 the register has been allocated to a uop but that uop is waiting to issue.
\layout Itemize


\series bold 
\emph on 
bypass:
\series default 
\emph default 
 the uop associated with the register has issued and produced a value (or
 encountered an exception), but that value is only on the bypass network
 - it has not actually been written back yet.
 For simulation purposes only, uops immediately write their results into
 the physical register as soon as they issue, even though technically the
 result is still only on the bypass network.
 This helps simplify the simulator considerably without compromising accuracy.
\layout Itemize


\series bold 
\emph on 
written:
\series default 
\emph default 
 the uop associated with the register has passed through the writeback stage
 and the value of the physical register is now up to date; all future consumers
 will read the uop's result from this physical register.
\layout Itemize


\series bold 
\emph on 
arch:
\series default 
\emph default 
 the physical register is currently mapped to one of the architectural registers
; it has no associated uop currently in the pipeline
\layout Itemize


\series bold 
\emph on 
pendingfree:
\series default 
\emph default 
 this is a special state described in Section 
\begin_inset LatexCommand \ref{sub:PhysicalRegisterRecyclingComplications}

\end_inset 

.
\layout Standard

One physical register is allocated to each uop and moved into the 
\emph on 
waiting
\emph default 
 state, regardless of which type of uop it is.
 For integer, floating point and load uops, the physical register holds
 the actual numerical value generated by the corresponding uop.
 Branch uops place the target RIP of the branch in a physical register.
 Store uops place the merged data to store in the register.
 Technically branches and stores do not need physical registers, but to
 keep the processor design simple, they are allocated registers anyway.
\layout Section


\begin_inset LatexCommand \label{sec:LoadStoreQueueEntry}

\end_inset 

Load Store Queue Entries
\layout Standard

Load Store Queue (LSQ) Entries (the 
\family typewriter 
\size small 
LoadStoreQueueEntry
\family default 
\size default 
 structure in PTLsim) are used to track additional information about loads
 and stores in the pipeline that cannot be represented by a physical register.
 Specifically, LSQ entries track:
\layout Itemize


\series bold 
Physical address
\series default 
 of the corresponding load or store
\layout Itemize


\series bold 
Data
\series default 
 field (64 bits) stores the loaded value (for loads) or the value to store
 (for stores)
\layout Itemize


\series bold 
Address valid 
\series default 
bit flag indicates if the load or store knows its effective physical address
 yet.
 If set, the physical address field is valid.
\layout Itemize


\series bold 
Data valid 
\series default 
bit flag indicates if the data field is valid.
 For loads, this is set when the data has arrived from the cache.
 For stores, this is set when the data to store becomes ready and is merged.
\layout Itemize


\series bold 
Invalid
\series default 
 bit flag is set if an exception occurs in the corresponding load or store.
\layout Standard

The 
\family typewriter 
\size small 
LoadStoreQueueEntry
\family default 
\size default 
 structure is technically a superset of a structure known as an 
\emph on 
SFR
\emph default 
 (Store Forwarding Register), which completely represents any load or store
 and can be passed between PTLsim subsystems easily.
 One LSQ entry is allocated to each load or store during the Allocate stage.
\layout Standard

In real processors, the load queue (LDQ) and store queue (STQ) are physically
 separate for circuit complexity reasons.
 However, in PTLsim a unified LSQ is used to make searching operations easier.
 One additional bit flag (
\family typewriter 
\size small 
store
\family default 
\size default 
 bit) specifies whether an LSQ entry is a load or store.
\layout Subsection


\begin_inset LatexCommand \label{sub:RegisterRenaming}

\end_inset 

Register Renaming
\layout Standard

The basic register renaming process in the PTLsim x86 model is very similar
 to classical register renaming, with the exception of the flags complications
 described in Section 
\begin_inset LatexCommand \ref{sub:FlagsManagement}

\end_inset 

.
 Two versions of the register rename table (RRT) are maintained: a 
\emph on 
speculative RRT
\emph default 
 which is updated as uops are renamed, and a 
\emph on 
commit RRT
\emph default 
, which is only updated when uops successfully commit.
 Since the simulator implements a unified physical and architectural register
 file, the commit process does not actually involve any data movement between
 physical and architectural registers: only the commit RRT needs to be updated.
 The commit RRT is used only for exception and branch mispredict recovery,
 since it holds the last known good mapping of architectural to physical
 registers.
\layout Standard

Each rename table contains 80 entries as shown in Table 
\begin_inset LatexCommand \ref{table:ArchitecturalRegisters}

\end_inset 

.
 This table maps architectural registers and pseudo-registers to the most
 up to date physical registers for the following:
\layout Itemize

16 x86-64 integer registers
\layout Itemize

16 128-bit SSE registers (represented as separate 64-bit high and low halves)
\layout Itemize

ZAPS, CF, OF flag sets described in Section 
\begin_inset LatexCommand \ref{sub:FlagsManagement}

\end_inset 

.
 These rename table entries point to the physical register (with attached
 flags) of the most recent uop in program order to update any or all of
 the ZAPS, CF, OF flag sets, respectively.
\layout Itemize

Various integer and x87 status registers
\layout Itemize

Temporary pseudo-registers 
\family typewriter 
\size small 
temp0
\family default 
\size default 
-
\family typewriter 
\size small 
temp7
\family default 
\size default 
 not visible to x86 code but required to hold temporaries (e.g.
 generated addresses or value to swap in 
\family typewriter 
\size small 
xchg
\family default 
\size default 
 instructions).
\layout Itemize

Special fixed values, e.g.
 
\family typewriter 
\size small 
zero
\family default 
\size default 
, 
\family typewriter 
\size small 
imm
\family default 
\size default 
 (value is in immediate field), 
\family typewriter 
\size small 
mem
\family default 
\size default 
 (destination of stores)
\layout Standard


\begin_inset Float table
wide false
collapsed false

\layout Caption


\begin_inset LatexCommand \label{table:ArchitecturalRegisters}

\end_inset 

Architectural registers and pseudo-registers used for renaming.
\layout Standard
\noindent \align center 

\begin_inset  Tabular
<lyxtabular version="3" rows="11" columns="9">
<features>
<column alignment="left" valignment="top" leftline="true" width="0">
<column alignment="left" valignment="top" leftline="true" width="0">
<column alignment="left" valignment="top" leftline="true" width="0">
<column alignment="left" valignment="top" leftline="true" width="0">
<column alignment="left" valignment="top" leftline="true" width="0">
<column alignment="left" valignment="top" leftline="true" width="0">
<column alignment="left" valignment="top" leftline="true" width="0">
<column alignment="left" valignment="top" leftline="true" width="0">
<column alignment="left" valignment="top" leftline="true" rightline="true" width="0">
<row topline="true" bottomline="true">
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\size small 
Architectural Registers and Pseudo-Registers
\end_inset 
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\size small 
0
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rax
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rcx
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rdx
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rbx
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rsp
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rbp
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rsi
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rdi
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\size small 
8
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
r8
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
r9
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
r10
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
r11
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
r12
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
r13
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
r14
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
r15
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\size small 
16
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
xmml0
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
xmmh0
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
xmml1
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
xmmh1
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
xmml2
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
xmmh2
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
xmml3
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
xmmh3
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\size small 
24
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
xmml4
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
xmmh4
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
xmml5
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
xmmh5
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
xmml6
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
xmmh6
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
xmml7
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
xmmh7
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\size small 
32
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
xmml8
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
xmmh8
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
xmml9
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
xmmh9
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
xmml10
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
xmmh10
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
xmml11
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
xmmh11
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\size small 
40
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
xmml12
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
xmmh12
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
xmml13
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
xmmh13
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
xmml14
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
xmmh14
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
xmml15
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
xmmh15
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\size small 
48
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
fptos
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
fpsw
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
fpcw
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
fptags
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
fp4
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
fp5
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
fp6
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
fp7
\end_inset 
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\size small 
56
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rip
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
flags
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
sr3
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
mxcsr
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
sr0
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
sr1
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
sr2
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
zero
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\size small 
64
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
temp0
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
temp1
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
temp2
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
temp3
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
temp4
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
temp5
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
temp6
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
temp7
\end_inset 
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\size small 
72
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
zf
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
cf
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
of
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
imm
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
mem
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
temp8
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
temp9
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
temp10
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\end_inset 


\layout Standard

Once the uop's three architectural register sources are mapped to physical
 registers, these physical registers are placed in the 
\family typewriter 
\size small 
operands[
\family default 
\size default 
0,1,2
\family typewriter 
\size small 
]
\family default 
\size default 
 fields.
 The fourth operand field, 
\family typewriter 
\size small 
operands[
\family default 
\size default 
3
\family typewriter 
\size small 
]
\family default 
\size default 
, is used to hold a store buffer dependency for loads and stores; this will
 be discussed later.
 The speculative RRT entries for both the destination physical register
 and any modified flags are then overwritten.
 Finally, the ROB is moved into the 
\series bold 
\emph on 
frontend
\series default 
\emph default 
 state.
\layout Subsection

External State
\layout Standard

Since the rest of the simulator outside of the out of order core does not
 know about the RRTs and expects architectural registers to be in a standardized
 format, the system-wide 
\family typewriter 
\size small 
ctx
\family default 
\size default 
 structure of class 
\family typewriter 
\size small 
CoreState
\family default 
\size default 
 is used to house the architectural register file.
 The 
\family typewriter 
\size small 
REG_flags
\family default 
\size default 
 and 
\family typewriter 
\size small 
REG_rip
\family default 
\size default 
 entries of this structure are directly updated by the out of order core
 as instructions commit.
\layout Section

Frontend Stages
\layout Standard

To simulate various processor frontend pipeline depths, ROBs are placed
 in the 
\emph on 
frontend
\emph default 
 state for a user-selectable number of cycles.
 In the 
\family typewriter 
\size small 
frontend()
\family default 
\size default 
 function, the 
\family typewriter 
\size small 
cycles_left
\family default 
\size default 
 field in each ROB is decremented until it becomes zero.
 At this point, the uop is moved to the 
\series bold 
\emph on 
ready_to_dispatch
\series default 
\emph default 
 state.
 This feature can be used to simulate various branch mispredict penalties
 by setting the 
\family typewriter 
\size small 
FRONTEND_STAGES
\family default 
\size default 
 constant.
\layout Chapter


\begin_inset LatexCommand \label{sec:ClusterDispatchScheduleIssue}

\end_inset 

Scheduling, Dispatch and Issue
\layout Section


\begin_inset LatexCommand \label{sec:Clustering}

\end_inset 

Clustering and Issue Queue Configuration
\layout Standard

The PTLsim out of order model can simulate an arbitrarily complex set of
 functional units grouped into 
\emph on 
clusters
\emph default 
.
 Clusters are specified by the 
\family typewriter 
\size small 
Cluster
\family default 
\size default 
 class and are defined by the 
\family typewriter 
\size small 
clusters[]
\family default 
\size default 
 array in 
\family typewriter 
\size small 
ooohwdef.h
\family default 
\size default 
.
 Each Cluster element defines the name of the cluster, which functional
 units belong to the cluster (
\family typewriter 
\size small 
fu_mask
\family default 
\size default 
 field) and the maximum number of uops that can be issued in that cluster
 each cycle (
\family typewriter 
\size small 
issue_width
\family default 
\size default 
 field)
\layout Standard

The 
\family typewriter 
\size small 
intercluster_latency_map
\family default 
\size default 
 matrix defines the forwarding latency, in cycles, between a given cluster
 and every other cluster.
 If 
\family typewriter 
\size small 
intercluster_latency_map[
\family default 
\size default 
\emph on 
A
\family typewriter 
\size small 
\emph default 
][
\family default 
\size default 
\emph on 
B
\family typewriter 
\size small 
\emph default 
]
\family default 
\size default 
 is 
\emph on 
L
\emph default 
 cycles, this means that functional units in cluster 
\emph on 
B
\emph default 
 must wait 
\emph on 
L
\emph default 
 cycles after a uop 
\emph on 
U
\emph default 
 in cluster A completes before cluster B's functional units can issue a
 uop dependent on 
\emph on 
U
\emph default 
's result.
 If the latency is zero between clusters 
\emph on 
A
\emph default 
 and 
\emph on 
B
\emph default 
, producer and consumer uops in 
\emph on 
A
\emph default 
 and 
\emph on 
B
\emph default 
 can always be issued back to back in subsequent cycles.
 Hence, the diagonal of the forwarding latency matrix is always all zeros.
\layout Standard

This clustering mechanism can be used to implement several features of modern
 microprocessors.
 First, traditional clustering is possible, in which it takes multiple additiona
l cycles to forward results between different clusters (for instance, one
 or more integer clusters and a floating point unit).
 Second, several issue queues and corresponding issue width limits can be
 defined within a given virtual cluster, for instance to sort loads, stores
 and ALU operations into separate issue queues with different policies.
 This is done by specifying an inter-cluster latency of zero cycles between
 the relevant pseudo-clusters with separate issue queues.
 Both of these uses are required to accurately model most modern processors.
\layout Standard

There is also an equivalent 
\family typewriter 
\size small 
intercluster_bandwidth_map
\family default 
\size default 
 matrix to specify the maximum number of values that can be routed between
 any two clusters each cycle.
\layout Standard

The 
\family typewriter 
\size small 
IssueQueue
\family default 
\size default 
 template class is used to declare issue queues; each cluster has its own
 issue queue.
 The syntax 
\family typewriter 
\size small 
IssueQueue<
\family default 
\size default 
\emph on 
size
\family typewriter 
\size small 
\emph default 
>
\family default 
\size default 
 
\family typewriter 
\size small 
issueq_
\family default 
\size default 
\emph on 
name
\family typewriter 
\size small 
\emph default 
;
\family default 
\size default 
 is used to declare an issue queue with a specific size.
 In the current implementation, the size can be from 1 to 64 slots.
 The macros 
\family typewriter 
\size small 
foreach_issueq()
\family default 
\size default 
, 
\family typewriter 
\size small 
sched_get_all_issueq_free_slots()
\family default 
\size default 
 and 
\family typewriter 
\size small 
issueq_operation_on_cluster_with_result()
\family default 
\size default 
 macros must be modified if the cluster and issue queue configuration is
 changed to reflect all available clusters; the modifications required should
 be obvious from the example code.
 These macros with switch statements are required instead of a simple array
 since the issue queues can be of different template types and sizes.
\layout Section

Cluster Selection
\layout Standard

The 
\family typewriter 
\size small 
ReorderBufferEntry::select_cluster()
\family default 
\size default 
 function is responsible for routing a given uop into a specific cluster
 at the time it is dispatched; uops do not switch between clusters after
 this.
\layout Standard

Various heuristics are employed to select which cluster a given uop should
 be routed to.
 In the reference implementation provided in 
\family typewriter 
\size small 
ooocore.cpp
\family default 
\size default 
, a weighted score is generated for each possible cluster by scanning through
 the uop's operands to determine which cluster they will be forwarded from.
 If a given operand's corresponding producer uop 
\emph on 
S
\emph default 
 is currently either dispatched to cluster 
\emph on 
C
\emph default 
 but waiting to execute or is still on the bypass network of cluster 
\emph on 
C
\emph default 
, then cluster 
\emph on 
C
\emph default 
's score is incremented.
 
\layout Standard

The final cluster is selected as the cluster with the highest score out
 of the set of clusters which the uop can actually issue on (e.g.
 a floating point uop cannot issue on a cluster with only integer units).
 The 
\family typewriter 
\size small 
ReorderBufferEntry::executable_on_cluster_mask
\family default 
\size default 
 bitmap can be used to further restrict which clusters a uop can be dispatched
 to, for instance because certain clusters can only write to certain physical
 register files.
 This mechanism is designed to route each uop to the cluster in which the
 majority of its operands will become available at the earliest time; in
 practice it works quite well and variants of this technique are often used
 in real processors.
\layout Section


\begin_inset LatexCommand \label{sec:Scheduling}

\end_inset 

Issue Queue Structure and Operation
\layout Standard

PTLsim implements issue queues in the 
\family typewriter 
\size small 
IssueQueue
\family default 
\size default 
 template class using the collapsing priority queue design used in most
 modern processors.
 
\layout Standard

As each uop is dispatched, it is placed at the end of the issue queue for
 its cluster and several associative arrays are updated to reflect which
 operands the uop is still waiting for.
 In the IssueQueue class, the 
\family typewriter 
\size small 
insert()
\family default 
\size default 
 method takes the ROB index of the uop (its 
\emph on 
tag
\emph default 
 in issue queue terminology), the tags (ROB indices) of its operands, and
 a map of which of the operands are ready versus waiting.
 The ROB index is inserted into an associative array, and the ROB index
 tags of any waiting operands are inserted into corresponding slots in parallel
 arrays, one array per operand (in the current implementation, up to 4 operands
 are tracked).
 If an operand was ready at dispatch time, the slot for that operand in
 the corresponding array is marked as invalid since there is no need to
 wake it up later.
 Notice that the new slot is always at the end of the issue queue array;
 this is made possible by the collapsing mechanism described below.
\layout Standard

The issue queue maintains two bitmaps to track the state of each slot in
 the queue.
 The 
\family typewriter 
\size small 
valid
\family default 
\size default 
 bitmap indicates which slots are occupied by uops, while the 
\family typewriter 
\size small 
issued
\family default 
\size default 
 bitmap indicates which of those uops have been issued.
 Together, these two bitmaps form the state machine described in Table 
\begin_inset LatexCommand \ref{table:IssueQueueStateMachine}

\end_inset 

.
\layout Standard


\begin_inset Float table
wide false
collapsed false

\layout Caption


\begin_inset LatexCommand \label{table:IssueQueueStateMachine}

\end_inset 

Issue Queue State Machine
\layout Standard
\noindent \align center 

\begin_inset  Tabular
<lyxtabular version="3" rows="5" columns="3">
<features>
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="left" valignment="top" leftline="true" rightline="true" width="0">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Valid
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Issued
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Meaning
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
0
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
0
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Unused slot
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
0
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
1
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

(invalid)
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
1
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
0
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Dispatched but waiting for operands
\end_inset 
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
1
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
1
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Issued to a functional unit but not yet completed
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\end_inset 


\layout Standard

After 
\family typewriter 
\size small 
insert()
\family default 
\size default 
 is called, the slot is placed in the dispatched state.
 As each uop completes, its tag (ROB index) is broadcast using the 
\family typewriter 
\size small 
broadcast()
\family default 
\size default 
 method to one or more issue queues accessible in that cycle.
 Because of clustering, some issue queues will receive the broadcast later
 than others; this is discussed below.
 Each slot in each of the four operand arrays is compared against the broadcast
 value.
 If the operand tag in that slot is valid and matches the broadcast tag,
 the slot (in one of the operand arrays only, not the entire issue queue)
 is invalidated to indicate it is ready and no longer waiting for further
 broadcasts.
\layout Standard

Every cycle, the 
\family typewriter 
\size small 
clock()
\family default 
\size default 
 method uses the 
\family typewriter 
\size small 
valid
\family default 
\size default 
 and 
\family typewriter 
\size small 
issued
\family default 
\size default 
 bitmaps together with the valid bitmaps of each of the operand arrays to
 compute which issue queue slots in the dispatched state are no longer waiting
 on any of their operands.
 This bitmap of ready slots is then latched into the 
\family typewriter 
\size small 
allready
\family default 
\size default 
 bitmap.
\layout Standard

The 
\family typewriter 
\size small 
issue()
\family default 
\size default 
 method simply finds the index of the first set bit in the 
\family typewriter 
\size small 
allready
\family default 
\size default 
 bitmap (this is the slot of the oldest ready uop in program order), marks
 the corresponding slot as issued, and returns the slot.
 The processor then selects a functional unit for the uop in that slot and
 executes it via the 
\family typewriter 
\size small 
ReorderBufferEntry::issue()
\family default 
\size default 
 method.
 After the uop has completed execution (i.e.
 it cannot possibly be replayed), the 
\family typewriter 
\size small 
release()
\family default 
\size default 
 method is called to remove the slot from the issue queue, freeing it up
 for incoming uops in the dispatch stage.
 The collapsing design of the issue queue means that the slot is not simply
 marked as invalid - all slots after it are physically shifted left by one,
 leaving a free slot at the end of the array.
 This design is relatively simple to implement in hardware and makes determining
 the oldest ready to issue uop very trivial.
\layout Standard

Because of the collapsing mechanism, it is critical to note that the slot
 index returned by 
\family typewriter 
\size small 
issue()
\family default 
\size default 
 will become invalid after the next call to the 
\family typewriter 
\size small 
remove()
\family default 
\size default 
 method; hence, it should never be stored anywhere if a slot could be removed
 from the issue queue in the meantime.
\layout Standard

If a uop issues but determines that it cannot actually complete at that
 time, it must be 
\emph on 
replayed
\emph default 
.
 The 
\family typewriter 
\size small 
replay()
\family default 
\size default 
 method clears the issued bit for the uop's issue queue slot, returning
 it to the dispatched state.
 The replay mechanism can optionally add additional dependencies such that
 the uop is only re-issued after those dependencies are resolved.
 This is important for loads and stores, which may need to add a dependency
 on a prior store queue entry after finding a matching address in the load
 or store queues.
 In rare cases, a replay may also be required when a uop is issued but no
 applicable functional units are left for it to execute on.
 The 
\family typewriter 
\size small 
ReorderBufferEntry::replay()
\family default 
\size default 
 method is a wrapper around 
\family typewriter 
\size small 
IssueQueue::replay()
\family default 
\size default 
 used to collect the operands the uop is still waiting for.
\layout Subsection

Implementation
\layout Standard

PTLsim uses a novel method of modeling the issue queue and other associative
 structures with small tags.
 Specifically, the 
\family typewriter 
\size small 
FullyAssociativeArrayTags8bit
\family default 
\size default 
 template class declared in 
\family typewriter 
\size small 
logic.h
\family default 
\size default 
 and used to build the issue queue makes use of the host processor's 128-bit
 vector (SSE) instructions to do massively parallel associative matching,
 masking and bit scanning on up to 16 tags every clock cycle.
 This makes it substantially faster than simulators using the naive approach
 of scanning the issue queue entries linearly.
 Similar classes in 
\family typewriter 
\size small 
logic.h
\family default 
\size default 
 support O(1) associative searches of both 8-bit and 16-bit tags; tags longer
 than this are generally more efficient if the generic 
\family typewriter 
\size small 
FullyAssociativeArrayTags
\family default 
\size default 
 using standard integer comparisons is used instead.
\layout Standard

As a result of this high performance design, each issue queue is limited
 to 64 entries and the tags to be matched must be between 0 and 255 to fit
 in 8 bits.
 The 
\family typewriter 
\size small 
FullyAssociativeArrayTags16bit
\family default 
\size default 
 class can be used instead if longer tags are required, at the cost of reduced
 simulation performance.
 To enable this, 
\family typewriter 
\size small 
BIG_ROB
\family default 
\size default 
 must be defined in 
\family typewriter 
\size small 
ooohwdef.h
\family default 
\size default 
.
\layout Subsection

Other Designs
\layout Standard

It's important to remember that the issue queue design described above is
 
\emph on 
one
\emph default 
 possible implemention out of the many designs currently used in industry
 and research processors.
 For instance, in lieu of the collapsing design (used by the Pentium 4 and
 Power4/5/970), the AMD K8 uses a sequence number tag of the ROB and comparator
 logic to select the earliest ready instruction.
 Similarly, the Pentium 4 uses a set of bit vectors (a 
\emph on 
dependency matrix
\emph default 
) instead of tag broadcasts to wake up instructions.
 These other approaches may be implemented by modifying the 
\family typewriter 
\size small 
IssueQueue
\family default 
\size default 
 class as appropriate.
\layout Section


\begin_inset LatexCommand \label{sec:Issue}

\end_inset 

Issue
\layout Standard

The 
\family typewriter 
\size small 
issue()
\family default 
\size default 
 top-level function issues one or more instructions in each cluster from
 each issue queue every cycle.
 This function consults the 
\family typewriter 
\size small 
clusters[
\family default 
\size default 
\emph on 
clusterid
\family typewriter 
\size small 
\emph default 
].issue_width
\family default 
\size default 
 field defined in 
\family typewriter 
\size small 
ooohwdef.h
\family default 
\size default 
 to determine the maximum number of uops to issue from each cluster.
 The 
\family typewriter 
\size small 
issueq_operation_on_cluster_with_result(cluster, iqslot, issue())
\family default 
\size default 
 macro (Section 
\begin_inset LatexCommand \ref{sec:Clustering}

\end_inset 

) is used to invoke the 
\family typewriter 
\size small 
issue()
\family default 
\size default 
 method of the appropriate cluster to select the earliest ready issue queue
 slot, as described in Section 
\begin_inset LatexCommand \ref{sec:Scheduling}

\end_inset 

.
 
\layout Standard

The 
\family typewriter 
\size small 
ReorderBufferEntry::issue()
\family default 
\size default 
 method of the corresponding ROB entry is then called to actually execute
 the uop.
 This method first makes sure a functional unit is available within the
 cluster that's capable of executing the uop; if not, the uop is replayed
 and re-issued again on the next cycle.
 At this point, the uop's three operands (
\family typewriter 
\size small 
ra
\family default 
\size default 
, 
\family typewriter 
\size small 
rb
\family default 
\size default 
, 
\family typewriter 
\size small 
rc
\family default 
\size default 
) are read from the physical register file.
 If any of the operands are invalid, the entire uop is marked as invalid
 with an 
\family typewriter 
\size small 
EXCEPTION_Propagate
\family default 
\size default 
 result and is not further executed.
 Otherwise, the uop is executed by calling the synthesized execute function
 for the uop (see Section 
\begin_inset LatexCommand \ref{sec:FetchStage}

\end_inset 

).
\layout Standard

Loads and stores are handled specially by calling the 
\family typewriter 
\size small 
issueload()
\family default 
\size default 
 or 
\family typewriter 
\size small 
issuestore()
\family default 
\size default 
 method.
 Since loads and stores can encounter an mis-speculation (e.g.
 when a load is erroneously issued before an earlier store to the same addresses
), the 
\family typewriter 
\size small 
issueload()
\family default 
\size default 
 and 
\family typewriter 
\size small 
issuestore()
\family default 
\size default 
 functions can return 
\family typewriter 
\size small 
ISSUE_MISSPECULATED
\family default 
\size default 
 to force all uops in program order after the mis-speculated uop to be annulled
 and sent through the pipeline again.
 Similarly, if 
\family typewriter 
\size small 
issueload()
\family default 
\size default 
 or 
\family typewriter 
\size small 
issuestore()
\family default 
\size default 
 return 
\family typewriter 
\size small 
ISSUE_NEEDS_REPLAY
\family default 
\size default 
, issuing from that cluster is aborted since the uop has been replayed in
 accordance with Section 
\begin_inset LatexCommand \ref{sec:Scheduling}

\end_inset 

.
 It is important to note that loads which miss the cache are considered
 to complete successfully and do 
\emph on 
not
\emph default 
 require a replay; their physical register is simply marked as waiting until
 the load arrives.
 In both the mis-speculation and replay cases, no further uops from the
 cluster's issue queue are dispatched until the next cycle.
\layout Standard

Branches are handled similar to integer and floating point operations, except
 that they may cause a mis-speculation in the event of a branch misprediction;
 this is discussed below.
\layout Standard

If the uop caused an exception, we force it directly to the commit stage
 and not through writeback; this keeps dependencies waiting until they can
 be properly annulled by the speculation recovery logic.
 The commit stage will detect the exception and take appropriate action.
 If the exceptional uop was speculatively executed beyond a branch, it will
 never reach commit anyway since the bogus branch would have to commit before
 the exception would even become visible.
\layout Standard


\series bold 
\emph on 
NOTE:
\series default 
\emph default 
 In PTLsim, all issued uops put their result in the uop's assigned physical
 register at the time of issue, even though the data technically does not
 appear there until writeback (i.e.
 the physical register enters the 
\emph on 
written
\emph default 
 state).
 This is done to simplify the simulator implementation; it is assumed that
 any data 
\begin_inset Quotes eld
\end_inset 

read
\begin_inset Quotes erd
\end_inset 

 from physical registers before writeback is in fact being read from the
 bypass network instead.
\layout Chapter


\begin_inset LatexCommand \label{sec:SpeculationAndRecovery}

\end_inset 

Speculation and Recovery
\layout Section

Misspeculation Cases
\layout Standard

PTLsim supports three speculative execution recovery mechanisms to handle
 various types of speculation failures:
\layout Itemize


\series bold 
Replay
\series default 
 is for scheduling and dependency mis-predictions only.
 Replayed uops remain in the issue queue so replay is very fast but limited
 in scope.
 Replay is described extensively in Section 
\begin_inset LatexCommand \ref{sec:ClusterDispatchScheduleIssue}

\end_inset 

.
\layout Itemize


\series bold 
Redispatch
\series default 
 finds the slice of uops in the ROB dependent on a mis-speculated uop and
 sends only those dependent uops back to the 
\emph on 
ready-to-dispatch
\emph default 
 state.
 It is used for load-store aliasing recovery, value mispredictions and other
 cases where the fetched uops themselves are still valid, but their outputs
 are invalid.
\layout Itemize


\series bold 
Annulment
\series default 
 removes any uops in program order after (or optionally including) a given
 uop.
 It is used for branch mispredictions and misalignment recovery.
\layout Section


\begin_inset LatexCommand \label{sec:Redispatch}

\end_inset 

Redispatch 
\layout Subsection

Redispatch Process
\layout Standard

Many types of mis-speculations do not require refetching a different set
 of uops; instead, any uops dependent on a mis-speculated uop can simply
 be recirculated through the pipeline so they can re-execute and produce
 correct values.
 This process is known as 
\emph on 
redispatch
\emph default 
; in the baseline out of order core, it is used to recover from load-store
 aliasing (Section 
\begin_inset LatexCommand \ref{sub:AliasCheck}

\end_inset 

).
\layout Standard

When a mis-speculated ROB is detected, 
\family typewriter 
\size small 
ROB.redispatch_dependents()
\family default 
\size default 
 is called.
 This function identifies the slice of uops that consumed values (directly
 or indirectly) from the mis-speculated uop, using dependency bitmaps similar
 to those used in real processors.
 
\family typewriter 
\size small 
ROB.redispatch_dependents(bool inclusive)
\family default 
\size default 
 has an 
\emph on 
inclusive
\emph default 
 parameter: if false, only the dependent uops are redispatched, not including
 the mis-speculated uop.
 This is most useful for value prediction, where the correct value can be
 directly reinjected into the mis-speculated uop's physical register without
 re-executing it.
\layout Standard

In 
\family typewriter 
\size small 
ROB.redispatch()
\family default 
\size default 
, each affected uop is placed back into the 
\family typewriter 
\size small 
rob_ready_to_dispatch state
\family default 
\size default 
, always in program order.
 This helps to avoid deadlocks, since the redispatched slice is given priority
 for insertion back into the issue queue.
 The resources associated with each uop (physical register, LDQ/STQ slot,
 IQ slot, etc.) are also restored to the state they were in immediately after
 renaming, so they can be properly recirculated through the pipeline as
 if the uop never issued.
 Various other issues must also be handled, such as making sure known store-to-l
oad aliasing constraints are preserved across the redispatch so as to avoid
 infinite replay loops, and branch directions must be corrected if a mispredict
 caused a fetch unit redirection but that mispredict was in fact based on
 mis-speculated data.
\layout Subsection

Deadlock Recovery
\layout Standard

Redispatch can create deadlocks in cases where other unrelated uops occupy
 all the issue queue slots needed by the redispatched uops to make forward
 progress, and there is a circular dependency loop (e.g.
 on loads and stores not known at the time of the redispatch) that creates
 a chicken-and-egg problem, thus blocking forward progress.
\layout Standard

To recover from this situation, we detect the case where no uops have been
 dispatched for 64 cycles, yet the 
\family typewriter 
\size small 
ready_to_dispatch
\family default 
\size default 
 queue still has valid uops.
 This situation very rarely happens in practice unless there is a true deadlock.
 To break up the deadlock, ideally we should only need to redispatch all
 uops occupying issue queue slots or those already waiting for dispatch
 - all others have produced a result and cannot block the issue queues again.
 However, this does not always work in pathological cases, and can sometime
 lead to repeated deadlocks.
 Since deadlocks are very infrequent, they can be resolved by just flushing
 the entire pipeline.
 This has a negligible impact on performance.
\layout Subsection

Statistical Counters
\layout Standard

Several statistical counters are maintained in the PTLsim statistics tree
 to measure redispatch overhead, in the 
\family typewriter 
\size small 
dispatch/redispatch
\family default 
\size default 
 node:
\layout Itemize


\family typewriter 
\size small 
deadlock-flushes
\family default 
\size default 
 measures how many times the pipeline must be flushed to resolve a deadlock.
\layout Itemize


\family typewriter 
\size small 
trigger-uops
\family default 
\size default 
 measures how many uops triggered redispatching because of a misspeculation.
 This number does not count towards the statistics below.
\layout Itemize


\family typewriter 
\size small 
dependent-uops
\family default 
\size default 
 is a histogram of how many uops depended on each trigger uop, not including
 the trigger uop itself.
\layout Section

Annulment
\layout Subsection

Branch Mispredictions
\layout Standard

Branch mispredictions form the bulk of all mis-speculated operations.
 Whenever the actual RIP returned by a branch uop differs from the 
\family typewriter 
\size small 
riptaken
\family default 
\size default 
 field of the uop, the branch has been mispredicted.
 This means all uops after (but 
\emph on 
not
\emph default 
 including) the branch must be annulled and removed from all processor structure
s.
 The fetch queue (Section 
\begin_inset LatexCommand \ref{sec:FetchStage}

\end_inset 

) is then reset and fetching is redirected to the correct branch target.
 However, all uops in program order before the branch are still correct
 and may continue executing.
\layout Standard

Note that we do 
\emph on 
not
\emph default 
 just reissue the branch: this would be pointless, as we already know the
 correct RIP since the branch uop itself has already executed once.
 Instead, we let it writeback and commit as if it were predicted correctly.
\layout Subsection


\begin_inset LatexCommand \label{sec:SpeculationRecovery}

\end_inset 

Annulment Process
\layout Standard

In PTLsim, the 
\family typewriter 
\size small 
ReorderBufferEntry::annul()
\family default 
\size default 
 method removes any and all ROBs that entered the pipeline after and optionally
 including the misspeculated uop (depending on the 
\family typewriter 
\size small 
keep_misspec_uop
\family default 
\size default 
 argument).
 Because this method moves all affected ROBs to the free state, they are
 instantly taken out of consideration for future pipeline stages and will
 be dropped on the next cycle.
\layout Standard

We must be extremely careful to annul all uops in an x86 macro-op; otherwise
 half the x86 instruction could be executed twice once refetched.
 Therefore, if the first uop to annul is not also the first uop in the x86
 macro-op, we may have to scan backwards in the ROB until we find the first
 uop of the macro-op.
 In this way, we ensure that we can annul the entire macro-op.
 All uops comprising the macro-op are guaranteed to still be in the ROB
 since none of the uops can commit until the entire macro-op can commit.
 Note that this does not apply if the final uop in the macro-op is a branch
 and that branch uop itself is being retained as occurs with mispredicted
 branches.
\layout Standard

The first uop to annul is determined in the 
\family typewriter 
\size small 
annul()
\family default 
\size default 
 method by scanning backwards in time from the excepting uop until a uop
 with its SOM (start of macro-op) bit is set, as described in Section 
\begin_inset LatexCommand \ref{sec:UopIntro}

\end_inset 

.
 This SOM uop represents the boundary between x86 instructions, and is where
 we start annulment.
 The end of the range of uops to annul is at the tail of the reorder buffer.
\layout Standard

We have to reconstruct the speculative RRT as it existed just before the
 first uop to be annulled was renamed.
 This is done by calling the 
\family typewriter 
\size small 
pseudocommit()
\family default 
\size default 
 method of each annulled uop to implement the 
\begin_inset Quotes eld
\end_inset 

fast flush with pseudo-commit
\begin_inset Quotes erd
\end_inset 

 algorithm as follows.
 First, we overwrite the speculative RRT with the committed RRT.
 We then 
\emph on 
simulate
\emph default 
 the commitment of all non-speculative ROBs up to the first uop to be annulled
 by updating the speculative RRT as if it were the commit RRT.
 This brings the speculative RRT to the same state as if all in flight nonspecul
ative operations before the first uop to be annulled had actually committed.
 Fetching is then resumed at the correct RIP, where new uops are renamed
 using the recovered speculative RRT.
\layout Standard

Other methods of RRT reconstruction (like backwards walk with saved checkpoint
 values) are difficult to impossible because of the requirement that flag
 rename tables be restored even if some of the required physical registers
 with attached flags have since been freed.
 Technically RRT checkpointing could be used but due to the load/store replay
 mechanism in use, this would require a checkpoint at every load and store
 as well as branches.
 Hence, the forward walk method seems to offer the best performance in practice
 and is quite simple.
 The Pentium 4 is believed to use a similar method of recovering from some
 types of mis-speculations.
\layout Standard

After reconstructing the RRT, for each ROB to annul, we broadcast the ROB
 index to the appropriate cluster's issue queue, allowing the issue queue
 to purge the slot of the ROB being annulled.
 Finally, for each annulled uop, we free any resources allocated to it (i.e.,
 the ROB itself, the destination physical register, the load/store queue
 entry (if any) and so on.
 Any updates to the branch predictor and return address stack made during
 the speculative execution of branches are also rolled back.
\layout Standard

Finally, the fetch unit is restarted at the correct RIP and uops enter the
 pipeline and are renamed according to the recovered rename tables and allocated
 resource maps.
\layout Chapter

Load Issue
\layout Section


\begin_inset LatexCommand \label{sec:IssuingLoads}

\end_inset 

Issuing Loads
\layout Standard

The 
\family typewriter 
\size small 
ReorderBufferEntry::issueload()
\family default 
\size default 
 function is responsible for issuing all load uops.
 The 
\family typewriter 
\size small 
issueload()
\family default 
\size default 
 method starts by computing the effective physical address of the value
 to load.
 In the released version of PTLsim, physical and virtual addresses are the
 same.
 If the load is one of the special unaligned fixup forms (
\family typewriter 
\size small 
ld.lo
\family default 
\size default 
, 
\family typewriter 
\size small 
ld.hi
\family default 
\size default 
) described in Section 
\begin_inset LatexCommand \ref{sub:UnalignedLoadsAndStores}

\end_inset 

, the address is re-aligned according to the type of instruction.
 At this point, the 
\family typewriter 
\size small 
check_access_and_alignment()
\family default 
\size default 
 function is called to resolve any immediately obvious exceptions such as
 page faults or alignment problems (for normal loads).
\layout Standard

If a given load or store accesses an unaligned address but is not one of
 the special 
\family typewriter 
\size small 
ld.lo
\family default 
\size default 
/
\family typewriter 
\size small 
ld.hi
\family default 
\size default 
/
\family typewriter 
\size small 
st.lo
\family default 
\size default 
/
\family typewriter 
\size small 
st.hi
\family default 
\size default 
 uops described in Section 
\begin_inset LatexCommand \ref{sub:UnalignedLoadsAndStores}

\end_inset 

, the processor responds by annulling all uops after and including the problem
 load; it then refetches instructions starting at the RIP address of the
 load itself.
 When the load instruction is refetched, it is transformed into a pair of
 
\family typewriter 
\size small 
ld.lo
\family default 
\size default 
/
\family typewriter 
\size small 
ld.hi
\family default 
\size default 
 or 
\family typewriter 
\size small 
st.lo
\family default 
\size default 
/
\family typewriter 
\size small 
st.hi
\family default 
\size default 
 uops in accordance with Section 
\begin_inset LatexCommand \ref{sub:UnalignedLoadsAndStores}

\end_inset 

.
 This refetch approach is required rather than a simple replay operation
 since a replay would require allocating two entries in the issue queue
 and potentially two ROBs, which is not possible with the PTLsim design
 once uops have been renamed.
\layout Standard

Technically, PTLsim splits loads into into low and high fixup uops by simply
 retranslating the basic block starting at the problem load's RIP.
 In real processors, the frontend pipeline generally has logic for predicting
 which loads and stores will be unaligned and will dynamically split them
 into aligned parts.
 Functionally these two approaches are the same, since in effect PTLsim
 predicts which loads need to be split by simply retaining the retranslated
 basic block with the split loads.
\layout Standard

If a load from the effective address would cause a page fault at this point,
 the load is aborted and execution returns to the 
\family typewriter 
\size small 
ReorderBufferEntry::issue()
\family default 
\size default 
 method, causing the result to be marked with an exception (
\family typewriter 
\size small 
EXCEPTION_PageFaultOnRead
\family default 
\size default 
).
\layout Standard

One x86-specific complication arises at this point.
 If a load (or store) uop is the high part (
\family typewriter 
\size small 
ld.hi
\family default 
\size default 
 or 
\family typewriter 
\size small 
st.hi
\family default 
\size default 
) of an unaligned load or store pair, but the actual user address did not
 overlap any of the high 64 bits accessed by the 
\family typewriter 
\size small 
ld.hi
\family default 
\size default 
 or 
\family typewriter 
\size small 
st.hi
\family default 
\size default 
 uop, the load should be completely ignored, even if the high part overlapped
 onto an invalid page.
 This is because it is perfectly legal to do an unaligned load or store
 at the very end of a page such that the next 64 bit chunk is not mapped
 to a valid page; the x86 architecture mandates that the load or store execute
 correctly as far as the user program is concerned.
\layout Section

Store Queue Check and Store Dependencies
\layout Standard

After doing these exception checks, the load/store queue (LSQ) is scanned
 backwards in time from the current load's entry to the LSQ's head.
 If a given LSQ entry corresponds to a store, the store's address has been
 resolved and the memory range needed by the load overlaps the memory range
 touched by the store, the load effectively has a dependency on the earlier
 store that must be resolved before the load can issue.
 The meaning of 
\begin_inset Quotes eld
\end_inset 

overlapping memory range
\begin_inset Quotes erd
\end_inset 

 is defined more specifically in Section 
\begin_inset LatexCommand \ref{sec:StoreMerging}

\end_inset 

.
\layout Standard

In some cases, the addresses of one or more prior stores that a load may
 depend on may not have been resolved by the time the load issues.
 Some processors will stall the load uop until 
\emph on 
all
\emph default 
 prior store addresses are known, but this can decrease performance by incorrect
ly preventing independent loads from starting as soon as their address is
 available.
 For this reason, the PTLsim processor model aggressively issues loads as
 soon as possible unless the load is predicted to frequently alias another
 store currently in the pipeline.
 This load/store aliasing prediction technique is described in Section 
\begin_inset LatexCommand \ref{sub:AliasCheck}

\end_inset 

.
\layout Standard

In either of the cases above, in which an overlapping store is identified
 by address but that store's data is not yet available for forwarding to
 the load, or where a prior store's address has not been resolved but is
 
\emph on 
predicted
\emph default 
 to overlap the load, the load effectively has a data flow dependency on
 the earlier store.
 This dependency is represented by setting the load's fourth 
\family typewriter 
\size small 
rs
\family default 
\size default 
 operand (
\family typewriter 
\size small 
operands[RS]
\family default 
\size default 
 in the 
\family typewriter 
\size small 
ReorderBufferEntry
\family default 
\size default 
) to the store the load is waiting on.
 After adding this dependency, the 
\family typewriter 
\size small 
replay()
\family default 
\size default 
 method is used to force the load back to the dispatched state, where it
 waits until the prior store is resolved.
 After the load is re-issued for a second time, the store queue is scanned
 again to make sure no intervening stores arrived in the meantime.
 If a different match is found this time, the load is replayed a third time.
 In practice, loads are rarely replayed more than once.
\layout Section

Data Extraction
\layout Standard

Once the prior store a load depends on (if any) is ready and all the exception
 checks above have passed, it is time to actually obtain the load's data.
 This process can be complicated since some bytes in the region accessed
 by the load could come from the data cache while other bytes may be forwarded
 from a prior store.
 If one or more bytes need to be obtained from the data cache, the L1 cache
 is probed (via the 
\family typewriter 
\size small 
probe_cache_and_sfr()
\family default 
\size default 
 function) to see if the required line is present.
 If so, and the combination of the forwarded store (if any) and the L1 line
 fills in all bytes required by the load, the final data can be extracted.
\layout Standard

To extract the data, the load unit creates a 64-bit temporary buffer by
 overlaying the bytes touched by the prior store (if any) on top of the
 bytes obtained from the cache.
 The correct word is then extracted and sign extended (if required) from
 this buffer to form the result of the load.
 Unaligned loads (described in Section 
\begin_inset LatexCommand \ref{sub:UnalignedLoadsAndStores}

\end_inset 

) are somewhat more complex in that both the low and high 64 bit chunks
 from the 
\family typewriter 
\size small 
ld.lo
\family default 
\size default 
 and 
\family typewriter 
\size small 
ld.hi
\family default 
\size default 
 uops, respectively, are placed into a 128-bit buffer from which the final
 result is extracted.
\layout Standard

For simulation purposes only, the data to load is immediately accessed and
 recorded by 
\family typewriter 
\size small 
issueload()
\family default 
\size default 
 regardless of whether or not there is a cache miss.
 This makes the loaded data significantly easier to track.
 In a real processor, the data extraction process obviously only happens
 after the missing line actually arrives, however our implementation in
 no way affects performance.
\layout Section


\begin_inset LatexCommand \label{sec:CacheMissHandling}

\end_inset 

Cache Miss Handling
\layout Standard

If no combination of the prior store's forwarded bytes and data present
 in the L1 cache can fulfill a load, this is miss and lower cache levels
 must be accessed.
 This process is described in Sections 
\begin_inset LatexCommand \ref{sec:InitiatingCacheMiss}

\end_inset 

 and 
\begin_inset LatexCommand \ref{sec:FillingCacheMiss}

\end_inset 

.
 As far as the core is concerned, the load is completed at this point even
 if the data has not yet arrived.
 The issue queue entry for the load can be released since the load is now
 officially in progress and cannot be replayed.
 Once the loaded data has arrived, the cache subsystem calls the 
\family typewriter 
\size small 
ReorderBuffer::loadwakeup()
\family default 
\size default 
, which marks both the physical register and LSQ entry of the load as ready,
 and places the load's ROB into the 
\emph on 
completed
\emph default 
 state.
 This allows the processor to wake up dependents of the load on the next
 cycle.
\layout Chapter

Stores
\layout Section


\begin_inset LatexCommand \label{sec:StoreMerging}

\end_inset 

Store to Store Forwarding and Merging
\layout Standard

In the PTLsim out of order model, a given store may merge its data with
 that of a previous store in program order.
 This ensures that loads which may need to forward data from a store always
 reference exactly one store queue entry, rather than having to merge data
 from multiple smaller prior stores to cover the entire byte range being
 loaded.
 In this model, physical memory is divided up into 8 byte (64 bit) chunks.
 As each store issues, it scans the store queue backwards in program order
 to find the most recent prior store to the same 8 byte aligned physical
 address.
 If there is a match, the current store depends on the matching prior store,
 and cannot complete and forward its data to other consuming loads and stores
 until the prior store in question also completes.
 This ensures that the current store's data can be composited on top of
 the older store's data to form a single up to date 8-byte chunk.
 As described in Section 
\begin_inset LatexCommand \ref{sec:LoadStoreQueueEntry}

\end_inset 

, each store queue entry contains a byte mask to indicate which of the 8
 bytes in each chunk are currently modified by stores in flight versus those
 bytes which must come from the data cache.
\layout Standard

Technically there are more efficient approaches, such as allowing stores
 to issue in any order so long as they do not overlap on the basis of individual
 bytes.
 However, no modern processor allows such arbitrary forwarding since the
 circuit complexity involved with scanning the store queue for partial address
 matches would be prohibitive and slow.
 Instead, most processors only support store to load forwarding when a single
 larger prior store covers the entire byte range accessed by a smaller or
 same sized load; all other combinations stall the load until the overlapping
 prior stores commit to the data cache.
 
\layout Standard

The store inheritance scheme used by PTLsim (described first) is an improvement
 to the more common 
\begin_inset Quotes eld
\end_inset 

stall on size mismatch
\begin_inset Quotes erd
\end_inset 

 scheme above, but may incur more store dependency replays (since stores
 now depend on other stores when they target the same 8-byte chunk) compared
 to a stall on size mismatch scheme.
 As a case study, the Pentium 4 processor (Prescott core) implements a combinati
on of these approaches.
\layout Section


\begin_inset LatexCommand \label{sec:SplitPhaseStores}

\end_inset 

Split Phase Stores
\layout Standard

The 
\family typewriter 
\size small 
ReorderBufferEntry::issuestore()
\family default 
\size default 
 function is responsible for issuing all store uops.
 Stores are unusual in that they can issue even if their 
\family typewriter 
\size small 
rc
\family default 
\size default 
 operand (the value to store) is not ready at the same time as the 
\family typewriter 
\size small 
ra
\family default 
\size default 
 and 
\family typewriter 
\size small 
rb
\family default 
\size default 
 operands forming the effective address.
 This property is useful since it allows a store to establish an entry in
 the store queue as soon as the effective address can be generated, even
 if the data to store is not ready.
 By establishing addresses in the store queue as soon as possible, we can
 avoid performance losses associated with the unnecessary replay of loads
 that may depend on a store whose address is unavailable at the time the
 load issues.
 In effect, this means that each store uop may actually issue twice.
\layout Standard

In the first phase issue, which occurs as soon as the 
\family typewriter 
\size small 
ra
\family default 
\size default 
 and 
\family typewriter 
\size small 
rb
\family default 
\size default 
 operands become ready, the store uop computes its effective physical address,
 checks that address for all exceptions (such as alignment problems and
 page faults) and writes the address into the corresponding 
\family typewriter 
\size small 
LoadStoreQueueEntry
\family default 
\size default 
 structure before setting its the 
\family typewriter 
\size small 
addrvalid
\family default 
\size default 
 bit as described in Section 
\begin_inset LatexCommand \ref{sec:LoadStoreQueueEntry}

\end_inset 

.
 If an exception is detected at this point, the 
\family typewriter 
\size small 
invalid
\family default 
\size default 
 bit in the store queue entry is set and the destination physical register's
 
\family typewriter 
\size small 
FLAG_inv
\family default 
\size default 
 flag is set so any attempt to commit the store will fail.
\layout Subsection


\begin_inset LatexCommand \label{sub:AliasCheck}

\end_inset 

Load Queue Search (Alias Check)
\layout Standard

The load queue is then searched to find any loads after the current store
 in program order which have already issued but have done so without forwarding
 data from the current store.
 These loads erroneously issued before the current store (now known to overlap
 the load's address) was able to forward the correct data to the offending
 load(s).
 This situation is known as 
\emph on 
aliasing
\emph default 
, and is effectively a mis-speculation requiring us to reissue any uops
 depending on the store.
 The redispatch method (Section 
\begin_inset LatexCommand \ref{sec:Redispatch}

\end_inset 

) is used to re-execute only those uops dependent (either directly or indirectly
) on the store.
\layout Standard

Since the redispatch process required to correct aliasing violations is
 expensive and may result in infinite loops, it is desirable to predict
 in advance which loads and stores are likely to alias each other such that
 loads predicted to alias are never issued when prior stores in the store
 queue still have unknown addresses.
 This works because in most out of order processors, statistically speaking,
 very few loads alias stores compared to normal loads from the cache.
 When an aliasing mis-speculation occurs, an entry is added to a small fully
 associative structure (typically 
\begin_inset Formula $\le16$
\end_inset 

 entries) called the Load Store Alias Predictor (LSAP).
 This structure is indexed by a portion of the address of the load instruction
 that aliased.
 This allows the load unit to avoid issuing any load uop that matches any
 address in the LSAP if any prior store addresses are still unresolved;
 if this is the case, a dependency is created on the first unresolved store
 such that the load is replayed (and the load and store queues are again
 scanned) once that store resolves.
 Similar methods of aliasing prediction are used by the Pentium 4 (Prescott
 core only) and Alpha 21264.
\layout Subsection

Store Queue Search (Merge Check)
\layout Standard

At this point the store queue is searched for prior stores to the same 8-byte
 block as described above in Section 
\begin_inset LatexCommand \ref{sec:StoreMerging}

\end_inset 

; if the store depends on a prior store, the scheduler structures are updated
 to add an additional dependency (in 
\family typewriter 
\size small 
operands[RS]
\family default 
\size default 
) on this prior store before the store is replayed in accordance with Section
 
\begin_inset LatexCommand \ref{sec:Scheduling}

\end_inset 

 to wait for the prior store to complete.
 If no prior store is found, or the prior store is ready, the current store
 is marked as a second phase store by setting the 
\family typewriter 
\size small 
load_store_second_phase
\family default 
\size default 
 flag in its ROB entry.
 Finally, the store is replayed in accordance with Section 
\begin_inset LatexCommand \ref{sec:Scheduling}

\end_inset 

.
\layout Standard

In the second phase of store uop scheduling, the store uop is only re-issued
 when all four operands (
\family typewriter 
\size small 
ra
\family default 
\size default 
 + 
\family typewriter 
\size small 
rb
\family default 
\size default 
 address, 
\family typewriter 
\size small 
rc
\family default 
\size default 
 data and 
\family typewriter 
\size small 
rs
\family default 
\size default 
 source store queue entry) are valid.
 The second phase repeats the scan of the load and store queues described
 above to catch any loads and stores that may have issued between the first
 and second phase issues; the store is replayed a third time if necessary.
 Otherwise, the 
\family typewriter 
\size small 
rc
\family default 
\size default 
 operand data is merged with the data from the prior store (if any) store
 queue entry, and the combined data and bytemask is written into the current
 store's store queue entry.
 Finally, the entry's 
\family typewriter 
\size small 
dataready
\family default 
\size default 
 bit is set to make the entry available for forwarding to other waiting
 loads and stores.
\layout Standard

The first and second phases may be combined into a single issue without
 replay if both the address and data operands of the store are all ready
 at the same time and the prior store (if any) the current store inherits
 from has already successfully issued.
\layout Chapter

Forwarding, Wakeup and Writeback
\layout Section

Forwarding and the Clustered Bypass Network
\layout Standard

Immediately after each uop is issued and the 
\family typewriter 
\size small 
ReorderBufferEntry::issue()
\family default 
\size default 
 method actually generates its result, the 
\family typewriter 
\size small 
cycles_left
\family default 
\size default 
 field of the ROB is set to the expected latency of the uop (e.g.
 between 1 and 5 cycles).
 The uop is then moved to the 
\emph on 
issued
\emph default 
 state and placed on the 
\family typewriter 
\size small 
rob_issued_list
\family default 
\size default 
.
 Every cycle, the 
\family typewriter 
\size small 
complete()
\family default 
\size default 
 method iterates through each ROB in issued state and decrements its 
\family typewriter 
\size small 
cycles_left
\family default 
\size default 
 field.
 If 
\family typewriter 
\size small 
cycles_left
\family default 
\size default 
 becomes zero, the corresponding uop has completed execution.
 The ROB is moved to the 
\emph on 
completed
\emph default 
 state (on 
\family typewriter 
\size small 
rob_completed_list
\family default 
\size default 
) and its physical register or store queue entry is moved to the 
\family typewriter 
\size small 
bypass
\family default 
\size default 
 state so newly dispatched uops do not try to wait for it.
\layout Standard

The 
\family typewriter 
\size small 
transfer()
\family default 
\size default 
 function is also called every cycle.
 This function examines the list of ROBs in the 
\emph on 
completed
\emph default 
 state and is responsible for broadcasting the completed ROB's tag (ROB
 index) to the issue queues.
 Because of clustering (Section 
\begin_inset LatexCommand \ref{sec:Clustering}

\end_inset 

), some issue queues will receive the broadcast later than others.
 Specifically, the ROB's 
\family typewriter 
\size small 
forward_cycle
\family default 
\size default 
 field determines which issue queues and remote clusters are visible 
\family typewriter 
\size small 
forward_cycle
\family default 
\size default 
 cycles after the uop completed.
 The 
\family typewriter 
\size small 
forward()
\family default 
\size default 
 method, called by 
\family typewriter 
\size small 
transfer()
\family default 
\size default 
 for each uop in the 
\emph on 
completed
\emph default 
 state, indexes into a lookup table 
\family typewriter 
\size small 
forward_at_cycle_lut[
\family default 
\size default 
\emph on 
cluster
\family typewriter 
\size small 
\emph default 
][
\family default 
\size default 
\emph on 
forward_cycle
\family typewriter 
\size small 
\emph default 
]
\family default 
\size default 
 to get a bitmap of which remote clusters are accessible 
\family typewriter 
\size small 
forward_cycle
\family default 
\size default 
 cycles after he uop completed, relative to the original cluster.the uop
 issued in.
 The 
\family typewriter 
\size small 
IssueQueue::broadcast()
\family default 
\size default 
 method (Section 
\begin_inset LatexCommand \ref{sec:Scheduling}

\end_inset 

) is then called for each applicable cluster to wake up any operands of
 uops in that cluster waiting on the newly completed uop.
\layout Standard

The 
\family typewriter 
\size small 
MAX_FORWARDING_LATENCY
\family default 
\size default 
 constant (in 
\family typewriter 
\size small 
ooohwdef.h
\family default 
\size default 
) specifies the maximum number of cycles between any two clusters.
 After the ROB has progressed through 
\family typewriter 
\size small 
MAX_FORWARDING_LATENCY
\family default 
\size default 
 cycles in the 
\emph on 
completed
\emph default 
 state, it is moved to the 
\family typewriter 
\size small 
ready-to-writeback
\family default 
\size default 
 state, effectively meaning the result has arrived at the physical register
 file and is eligible for writeback in the next cycle.
\layout Section

Writeback
\layout Standard

Every cycle, the 
\family typewriter 
\size small 
writeback()
\family default 
\size default 
 function scans the list of ROBs in the 
\emph on 
ready-to-writeback
\emph default 
 state and selects at most 
\family typewriter 
\size small 
WRITEBACK_WIDTH
\family default 
\size default 
 results to write to the physical register file.
 The 
\family typewriter 
\size small 
forward()
\family default 
\size default 
 method is first called one final time to catch the corner case in which
 a dependent uop was dispatched while producer uop was waiting in the 
\emph on 
ready-to-writeback
\emph default 
 state.
\layout Standard

As mentioned in Section 
\begin_inset LatexCommand \ref{sec:Issue}

\end_inset 

, for simulation purposes only, each uop puts its result directly into its
 assigned physical register at the time of issue, even though the data technical
ly does not appear there until writeback.
 This is done to simplify the simulator implementation; it is assumed that
 any data 
\begin_inset Quotes eld
\end_inset 

read
\begin_inset Quotes erd
\end_inset 

 from physical registers before writeback is in fact being read from the
 bypass network instead.
 Therefore, no actual data movement occurs in the 
\family typewriter 
\size small 
writeback()
\family default 
\size default 
 function; its sole purpose is to place the uop's physical register into
 the written state (via the 
\family typewriter 
\size small 
PhysicalRegister::writeback()
\family default 
\size default 
 method) and to move the ROB into its terminal state, 
\emph on 
ready-to-commit
\emph default 
.
\layout Chapter


\begin_inset LatexCommand \label{sec:CommitStage}

\end_inset 

Commitment
\layout Section

Introduction
\layout Standard

The commit stage examines uops from the head of the ROB, blocks until all
 uops comprising a given x86 instruction are ready to commit, commits the
 results of those uops to the architectural state and finally frees the
 resources associated with each uop.
\layout Section

Atomicity of x86 instructions
\layout Standard

The x86 architecture specifies 
\emph on 
atomic execution
\emph default 
 for all distinct x86 instructions.
 This means that since each x86 instruction may be comprised of multiple
 uops; none of these uops may commit until 
\emph on 
all
\emph default 
 uops in the instruction are ready to commit.
 In PTLsim, this is accomplished by checking if the uop at the head of the
 ROB (next to commit) has its SOM (start of macro-op) bit set.
 If so, the ROB is scanned forwards from the SOM uop to the next uop in
 program order with its EOM (end of macro-op) bit set.
 If all uops in this range are ready to commit and exception-free, the SOM
 uop is allowed to commit, effectively unlocking the ROB head pointer until
 the next uop with a SOM bit set is encountered.
 However, any exception in any uop comprising the x86 instruction at the
 head of the ROB causes the pipeline to be flushed and an exception to be
 taken.
 Similarly, external interrupts are only acknowledged at the boundary between
 x86 instructions (i.e.
 after the EOM uop of each instruction).
\layout Section

Commitment
\layout Standard

As each uop commits, it may update several components of the architectural
 state.
 
\layout Standard

Integer ALU and floating point uops obviously update their destination architect
ural register (
\emph on 
rd
\emph default 
).
 In PTLsim, this is done by simply updating the committed register rename
 table (
\family typewriter 
\size small 
commitrrt
\family default 
\size default 
) rather than actually copying register values.
 However, the old physical register mapped to architectural register 
\emph on 
rd
\emph default 
 will normally become inaccessible after the Commit RRT mapping for 
\emph on 
rd
\emph default 
 is overwritten with the committing uop's physical register index.
 The old physical register previously mapped to 
\emph on 
rd
\emph default 
 can then be freed.
 Technically physical registers allocated to intermediate uops (such as
 those used to hold temporary values) can be immediately freed without updating
 any Commit RRT entries, but for consistency we do not do this.
\layout Standard

In PTLsim, a physical register is freed by moving it to the 
\family typewriter 
\size small 
PHYSREG_FREE
\family default 
\size default 
 state.
 Unfortunately for various reasons related to long pipelines and the renaming
 of x86 flags, register reclamation is not so simple, but this will be discussed
 below in Section 
\begin_inset LatexCommand \ref{sub:PhysicalRegisterRecyclingComplications}

\end_inset 

.
\layout Standard

Some uops may also commit to a subset of the x86 flags, as specified in
 the uop encoding.
 For these uops, in theory no rename tables need updating, since the flags
 can be directly masked into the 
\family typewriter 
\size small 
REG_flags
\family default 
\size default 
 architectural pseudo-register.
 Should the pipeline be flushed, the rename table entries for the ZAPS,
 CF, OF flag sets will all be reset to point to the 
\family typewriter 
\size small 
REG_flags
\family default 
\size default 
 pseudo-register anyway.
 However, for the speculation recovery scheme described in Section 
\begin_inset LatexCommand \ref{sec:SpeculationRecovery}

\end_inset 

, the 
\family typewriter 
\size small 
REG_zf
\family default 
\size default 
, 
\family typewriter 
\size small 
REG_cf
\family default 
\size default 
, and 
\family typewriter 
\size small 
REG_of
\family default 
\size default 
 commit RRT entries are updated as well to match the updates done to the
 speculative RRT.
\layout Standard

Branches and jumps update the 
\family typewriter 
\size small 
REG_rip
\family default 
\size default 
 pseudo architectural register, while all other uops simply increment 
\family typewriter 
\size small 
REG_rip
\family default 
\size default 
 by the number of bytes in the x86 instruction being committed.
 The number of bytes (1-15) is stored in a 4-bit field of the first uop
 in each x86 instruction (i.e.
 the uop with its SOM bit set).
\layout Standard

Stores commit to the architectural state by writing directly to the data
 cache.
 Remember that a series of stores into a given 64-bit chunk of memory are
 merged within the store queue to the store uop's corresponding STQ entry
 as the store uop issues, so the commit unit always writes 64 bits to the
 cache at a time.
 The byte mask associated with the STQ entry of the store uop is used to
 only update the modified bytes in each chunk of memory in program order.
\layout Section


\begin_inset LatexCommand \label{sub:PhysicalRegisterRecyclingComplications}

\end_inset 

Physical Register Recycling Complications
\layout Subsection

Problem Scenarios
\layout Standard

In some processor designs, it is not always possible to immediately free
 the physical register mapped to a given architectural register when that
 old architectural register mapping is overwritten during commit as described
 above.
 Out of order x86 processors must maintain three separate rename table entries
 for the ZAPS, CF, OF flags in addition to the register rename table entry,
 any or all of which may be updated when uops rename and retire, depending
 on the uop's flag renaming semantics (see Section 
\begin_inset LatexCommand \ref{sub:FlagsManagement}

\end_inset 

), For this reason, even though a given physical register value may become
 inaccessible and hence dead at commit time, the flags associated with that
 physical register are frequently still referenced within the pipeline,
 so the physical register itself must remain allocated.
\layout Standard

Consider the following specific example, with uops listed in program order:
\layout Itemize


\family typewriter 
\size small 
sub rax = rax,rbx
\family default 
\size default 

\newline 
Assign RRT[
\family typewriter 
\size small 
rax
\family default 
\size default 
] = phys reg r0
\newline 
Assign RRT[
\family typewriter 
\size small 
flags
\family default 
\size default 
] = 
\emph on 
r0
\emph default 
 (since SUB all updates flags)
\layout Itemize


\family typewriter 
\size small 
mov rax = rcx
\family default 
\size default 

\newline 
Assign RRT[
\family typewriter 
\size small 
rax
\family default 
\size default 
] = phys reg r1
\newline 

\emph on 
No flags renamed:
\emph default 
 MOV never updates flags, so RRT[
\family typewriter 
\size small 
flags
\family default 
\size default 
] is still 
\emph on 
r0
\emph default 
.
\layout Itemize


\family typewriter 
\size small 
br.e target
\family default 
\size default 

\newline 
Depends on flags attached to 
\emph on 
r0
\emph default 
, even though actual architectural register (
\family typewriter 
\size small 
rax
\family default 
\size default 
) for 
\emph on 
r0
\emph default 
 has already been overwritten in the commit RRT by the MOV's commit.
 We cannot free 
\emph on 
r0
\emph default 
 since the BR uop might not have issued yet.
\layout Standard

This situation only happens with instruction sets like x86 (and SPARC or
 even PowerPC to some extent) which support writing flags (particularly
 multiple independent flags) and data in a single instruction.
\layout Subsection

Reference Counting
\layout Standard

For these reasons, we need to prevent U2's register from being freed if
 it is still referenced by anything still in the pipeline; the normal reorder
 buffer mechanism cannot always handle this situation in a very long pipeline.
\layout Standard

One solution (the one used by PTLsim) is to give each physical register
 a reference counter.
 Physical registers can be referenced from three structures: as operands
 to ROBs, from the speculative RRT, and from the committed RRT.
 As each uop operand is renamed, the counter for the corresponding physical
 register is incremented by calling the 
\family typewriter 
\size small 
PhysicalRegister::addref()
\family default 
\size default 
 method.
 As each uop commits, the counter for each of its operands is decremented
 via the 
\family typewriter 
\size small 
PhysicalRegister::unref()
\family default 
\size default 
 method.
 Similarly, 
\family typewriter 
\size small 
unref()
\family default 
\size default 
 and 
\family typewriter 
\size small 
addref()
\family default 
\size default 
 are used whenever an entry in the speculative RRT or commit RRT is updated.
 During mis-speculation recovery (see Section 
\begin_inset LatexCommand \ref{sec:SpeculationRecovery}

\end_inset 

), 
\family typewriter 
\size small 
unref()
\family default 
\size default 
 is also used to unlock the operands of uops slated for annulment.
 Finally, 
\family typewriter 
\size small 
unref()
\family default 
\size default 
 and 
\family typewriter 
\size small 
addref()
\family default 
\size default 
 are used when loads and stores need to add a new dependency on a waiting
 store queue entry (see Sections 
\begin_inset LatexCommand \ref{sec:IssuingLoads}

\end_inset 

 and 
\begin_inset LatexCommand \ref{sec:SplitPhaseStores}

\end_inset 

).
\layout Standard

As we update the committed RRT during the commit stage, the old register
 R mapped to the destination architectural register A of the uop being committed
 is examined.
 The register R is only moved to the 
\emph on 
free
\emph default 
 state iff its reference counter is zero.
 Otherwise, it is moved to the 
\emph on 
pendingfree
\emph default 
 state.
 The hardware examines the counters of 
\emph on 
pendingfree
\emph default 
 physical registers every cycle and moves physical registers to the 
\emph on 
free
\emph default 
 state only when their counters become zero and they are in the 
\emph on 
pendingfree
\emph default 
 state.
\layout Subsection

Hardware Implementation
\layout Standard

The hardware implementation of this scheme is straightforward and low complexity.
 The counters can have a very small number of bits since it is very unlikely
 a given physical register would be referenced by all 100+ uops in the ROB;
 3 bits should be enough to handle the typical maximum of < 8 uops sharing
 a given operand.
 Counter overflows can simply stall renaming or flush the pipeline since
 they are so rare.
\layout Standard

The counter table can be updated in bulk each cycle by adding/subtracting
 the appropriate sum or just adding zero if the corresponding register wasn't
 used.
 Since there are several stages between renaming and commit, the same counter
 is never both incremented and decremented in the same cycle, so race conditions
 are not an issue.
 
\layout Standard

In real processors, the Pentium 4 uses a scheme similar to this one but
 uses bit vectors instead.
 For smaller physical register files, this may be a better solution.
 Each physical register has a bit vector with one bit per ROB entry.
 If a given physical register P is still used by ROB entry E in the pipeline,
 P's bit vector bit R is set.
 Register P cannot be freed until all bits in its vector are zero.
\layout Section


\begin_inset LatexCommand \label{sec:PipelineFlushesAndBarriers}

\end_inset 

Pipeline Flushes and Barriers
\layout Standard

In some cases, the entire pipeline must be empty after a given uop commits.
 For instance, a 
\emph on 
barrier
\emph default 
 uop (e.g.
 system call, serializing uop, or major microcode assist) will stall the
 frontend when first renamed, and when committed (at which point it is the
 only uop in the pipeline), it will call 
\family typewriter 
\size small 
flush_pipeline()
\family default 
\size default 
 to restart fetching at the appropriate RIP.
 Exceptions have a similar effect when they reach the commit stage.
 After doing this, the current architectural registers must be copied into
 the externally visible 
\family typewriter 
\size small 
ctx.commitarf[]
\family default 
\size default 
 array, since normally the architectural registers are scattered throughout
 the physical register file.
 Fortunately, the commit stage also updates 
\family typewriter 
\size small 
ctx.commitarf[]
\family default 
\size default 
 in parallel with the commit RRT, even though the 
\family typewriter 
\size small 
commitarf
\family default 
\size default 
 array is never actually read by the out of order core.
\layout Standard

At this point, the 
\family typewriter 
\size small 
handle_barrier()
\family default 
\size default 
 or 
\family typewriter 
\size small 
handle_exception()
\family default 
\size default 
 function is called to actually communicate with the world outside the out
 of order core.
 In the case of 
\family typewriter 
\size small 
handle_barrier()
\family default 
\size default 
, generally this involves executing native code inside PTLsim to execute
 a system call on behalf of the simulated thread, or to service a very complex
 x86 instruction (e.g.
 
\family typewriter 
\size small 
cpuid
\family default 
\size default 
, floating point save or restore, etc).
 For 
\family typewriter 
\size small 
handle_exception()
\family default 
\size default 
, the simulation is stopped and the user is notified that a genuine user
 visible (non-speculative) exception reached the commit stage.
\layout Standard

If execution can continue after handling the barrier or exception, the 
\family typewriter 
\size small 
external_to_core_state()
\family default 
\size default 
 function is called to completely reset the out of order core using the
 state stored in 
\family typewriter 
\size small 
ctx.commitarf[]
\family default 
\size default 
.
 This involves allocating a fixed physical register for each of the 64 architect
ural registers in 
\family typewriter 
\size small 
ctx.commitarf[]
\family default 
\size default 
, setting the speculative and committed rename tables to their proper cold
 start values, and resetting all reference counts on physical registers
 as appropriate.
 If the processor is configured with multiple physical register files (Section
 
\begin_inset LatexCommand \ref{sec:PhysicalRegisters}

\end_inset 

), the initial physical register for each architectural register is allocated
 in the first physical register file only (this is configurable by modifying
 
\family typewriter 
\size small 
external_to_core_state()
\family default 
\size default 
).
 At this point, the main simulation loop can resume as if the processor
 had just restarted from scratch.
\layout Chapter


\begin_inset LatexCommand \label{sec:CacheHierarchy}

\end_inset 

Cache Hierarchy
\layout Standard

The PTLsim cache hierarchy model is highly flexible and can be used to model
 a wide variety of contemporary cache structures.
 The cache subsystem (defined in 
\family typewriter 
\size small 
dcacheint.h
\family default 
\size default 
 and implemented by 
\family typewriter 
\size small 
dcache.cpp
\family default 
\size default 
) by default consists of four levels:
\layout Itemize


\series bold 
L1 data cache
\series default 
 is directly probed by all loads and stores
\layout Itemize


\series bold 
L1 instruction cache
\series default 
 services all instruction fetches
\layout Itemize


\series bold 
L2 cache
\series default 
 is shared between data and instructions, with data paths to both L1 caches
\layout Itemize


\series bold 
L3 cache
\series default 
 is also shared and is optionally present
\layout Itemize


\series bold 
Main memory
\series default 
 is considered infinite in size but still has configurable characteristics
\layout Standard

These cache levels are listed in order from highest level (closer to the
 core) to lowest level (far away).
 The cache hierarchy is assumed to be 
\emph on 
inclusive
\emph default 
, i.e.
 any data in higher levels is assumed to always be present in lower levels.
 Additionally, the cache levels are generally 
\emph on 
write-through
\emph default 
, meaning that every store updates all cache levels, rather than waiting
 for a dirty line to be evicted.
 PTLsim supports a 48-bit virtual address space and 40-bit physical addresses
 in accordance with the x86-64 minimum requirements.
\layout Section

General Configurable Parameters
\layout Standard

All caches support configuration of:
\layout Itemize

Line size in bytes.
 Any power of two size is acceptable, however the line size of a lower cache
 level must be the same or larger than any line size of a higher level cache.
 For example, it is illegal to have 128 byte L1 lines with 64 byte L2 lines.
\layout Itemize

Set count may be any power of two number.
 The total cache size in bytes is of course (line size) 
\begin_inset Formula $\times$
\end_inset 

 (set count)
\begin_inset Formula $\times$
\end_inset 

 (way count)
\layout Itemize

Way count (associativity) may be any number from 1 (direct mapped) up to
 the set count (fully associative).
 Note that simulation performance (and clock speed in a real processor)
 will suffer if the associativity is too great, particularly for L1 caches.
\layout Itemize

Latency in cycles from a load request to the arrival of the data.
\layout Standard

In dcacheint.h, the two base classes 
\family typewriter 
\size small 
CacheLine
\family default 
\size default 
 and 
\family typewriter 
\size small 
CacheLineWithValidMask
\family default 
\size default 
 are interchangeable, depending on the model being used.
 The 
\family typewriter 
\size small 
CacheLine
\family default 
\size default 
 class is a standard cache line with no actual data (since the bytes in
 each line are simply held in memory for simulation purposes).
 
\layout Standard

The 
\family typewriter 
\size small 
CacheLineWithValidMask
\family default 
\size default 
 class adds a bitmask specifying which bytes within the cache line contain
 valid data and which are unknown.
 This is useful for implementing 
\begin_inset Quotes eld
\end_inset 

no stall on store
\begin_inset Quotes erd
\end_inset 

 semantics, in which stores simply allocate a new way in the appropriate
 set but only set the valid bits for those bytes actually modified by the
 store.
 The rest of the cache line not touched by the store can be brought in later
 without stalling the processor (unless a load tries to access them); this
 is PTLsim's default model.
 Additionally, this technique may be used to implement sectored cache lines,
 in which the line fill bus is smaller than the cache line size.
 This means that groups of bytes within the line may be filled over subsequent
 cycles rather than all at once.
\layout Standard

The 
\family typewriter 
\size small 
AssociativeArray
\family default 
\size default 
 template class in 
\family typewriter 
\size small 
logic.h
\family default 
\size default 
 forms the basis of all caches in PTLsim.
 To construct a cache in which specific lines can be locked into place,
 the 
\family typewriter 
\size small 
LockableAssociativeArray
\family default 
\size default 
 template class may be used instead.
 Finally, the 
\family typewriter 
\size small 
CommitRollbackCache
\family default 
\size default 
 template class is useful for creating versions of PTLsim with cache level
 commit/rollback support for out of order commit, fault recovery and advanced
 speculation techniques.
\layout Standard

The various caches are defined in 
\family typewriter 
\size small 
dcacheint.h
\family default 
\size default 
 by specializations of these template classes.
 The classes are 
\family typewriter 
\size small 
L1Cache
\family default 
\size default 
, 
\family typewriter 
\size small 
L1ICache
\family default 
\size default 
, 
\family typewriter 
\size small 
L2Cache
\family default 
\size default 
 and 
\family typewriter 
\size small 
L3Cache
\family default 
\size default 
.
\layout Section


\begin_inset LatexCommand \label{sec:InitiatingCacheMiss}

\end_inset 

Initiating a Cache Miss
\layout Standard

As described in Section 
\begin_inset LatexCommand \ref{sec:IssuingLoads}

\end_inset 

, in the out of order core model, the 
\family typewriter 
\size small 
issueload()
\family default 
\size default 
 function determines if some combination of a prior store's forwarded bytes
 (if any) and data present in the L1 cache can fulfill a load.
 If not, this is a miss and lower cache levels must be accessed.
 In this case, a 
\family typewriter 
\size small 
LoadStoreInfo
\family default 
\size default 
 structure (defined in 
\family typewriter 
\size small 
dcache.h
\family default 
\size default 
) is prepared with various metadata about the load, including which ROB
 entry and physical register to wake up when the load arrives, its size,
 alignment, sign extension properties, prefetch properties and so on.
 The 
\family typewriter 
\size small 
issueload_slowpath()
\family default 
\size default 
 function (defined in 
\family typewriter 
\size small 
dcache.cpp
\family default 
\size default 
) is then called with this information, the physical address to load and
 any data inherited from a prior store still in the pipeline.
 The 
\family typewriter 
\size small 
issueload_slowpath()
\family default 
\size default 
 function moves the load request out of the core pipeline and into the cache
 hierarchy.
 
\layout Standard

The 
\emph on 
Load Fill Request Queue
\emph default 
 (LFRQ) is a structure used to hold information about any outstanding loads
 that have missed any cache level.
 The LFRQ allows a configurable number of loads to be outstanding at any
 time and provides a central control point between cache lines arriving
 from the L2 cache or lower levels and the movement of the requested load
 data into the processor core to dependent instructions.
 The 
\family typewriter 
\size small 
LoadFillReq
\family default 
\size default 
 structure, prepared by 
\family typewriter 
\size small 
issueload_slowpath()
\family default 
\size default 
, contains all the data needed to return a filled load to the core: the
 physical address of the load, the data and bytemask already known so far
 (e.g.
 forwarded from a prior store) and the 
\family typewriter 
\size small 
LoadStoreInfo
\family default 
\size default 
 metadata described above.
\layout Standard

The 
\emph on 
Miss Buffer
\emph default 
 (MB) tracks all outstanding cache lines, rather than individual loads.
 Each MB slot uses a bitmap to track one or more LFRQ entries that need
 to be awakened when the missing cache line arrives.
 After adding the newly created 
\family typewriter 
\size small 
LoadFillReq
\family default 
\size default 
 entry to the LFRQ, the 
\family typewriter 
\size small 
MissBuffer::initiate_miss()
\family default 
\size default 
 method uses the missing line's physical address to allocate a new slot
 in the miss buffer array (or simply uses an existing slot if a miss was
 already in progress on a given line).
 In any case, the MB's wakeup bitmap is updated to reflect the new LFRQ
 entry referring to that line.
 Each MB entry contains a 
\family typewriter 
\size small 
cycles
\family default 
\size default 
 field, indicating the number of cycles remaining for that miss buffer before
 it can be moved up the cache hierarchy until it reaches the core.
 Each entry also contains two bits (
\family typewriter 
\size small 
icache
\family default 
\size default 
 and 
\family typewriter 
\size small 
dcache
\family default 
\size default 
) indicating which L1 caches to which the line should eventually be delivered;
 this is required because a single L2 line (and corresponding miss buffer)
 may be referenced by both the L1 data and instruction caches.
 
\layout Standard

In 
\family typewriter 
\size small 
initiate_miss()
\family default 
\size default 
, the L2 and L3 caches are probed to see if they contain the required line.
 If the L2 has the line, the miss buffer is placed into the 
\family typewriter 
\size small 
STATE_DELIVER_TO_L1
\family default 
\size default 
 state, indicating that the line is now in progress to the L1 cache.
 Similarly, an L2 miss but L3 hit results in the 
\family typewriter 
\size small 
STATE_DELIVER_TO_L2
\family default 
\size default 
 state, and a miss all the way to main memory results in 
\family typewriter 
\size small 
STATE_DELIVER_TO_L3
\family default 
\size default 
.
\layout Standard

In the very unlikely event that either the LFRQ slot or miss buffer are
 full, an exception is returned to out of order core, which typically replays
 the affected load until space in these structures becomes available.
 For prefetch requests, only a miss buffer is allocated; no LFRQ slot is
 needed.
\layout Section


\begin_inset LatexCommand \label{sec:FillingCacheMiss}

\end_inset 

Filling a Cache Miss
\layout Standard

The 
\family typewriter 
\size small 
MissBuffer::clock()
\family default 
\size default 
 method implements all synchronous state transitions.
 For each active miss buffer, the 
\family typewriter 
\size small 
cycles
\family default 
\size default 
 counter is decremented, and if it becomes zero, the MB's current state
 is examined.
 If a given miss buffer was in the 
\family typewriter 
\size small 
STATE_DELIVER_TO_L3
\family default 
\size default 
 state (i.e.
 in progress from main memory) and the cycle counter just became zero, a
 line in the L3 cache is validated with the incoming data (this may involve
 evicting another line in the same set to make room).
 The MB is then moved to the next state up the cache hierarchy (i.e.
 
\family typewriter 
\size small 
STATE_DELIVER_TO_L2
\family default 
\size default 
 in this example) and its cycles field is updated with the latency of the
 cache level it is now leaving (e.g.
 
\family typewriter 
\size small 
L3_LATENCY
\family default 
\size default 
 in this example).
 
\layout Standard

This process continues with successive levels until the MB is in the 
\family typewriter 
\size small 
STATE_DELIVER_TO_L1
\family default 
\size default 
 state and its cycles field has been decremented to zero.
 If the MB's 
\family typewriter 
\size small 
dcache
\family default 
\size default 
 bit is set, the L1 corresponding line is validated and the 
\family typewriter 
\size small 
lfrq.wakeup()
\family default 
\size default 
 method is called to invoke a new state machine to wake up any loads waiting
 on the recently filled line (as known from the MB's 
\family typewriter 
\size small 
lfrqmap
\family default 
\size default 
 bitmap).
 If the MB's 
\family typewriter 
\size small 
icache
\family default 
\size default 
 bit was set, the line is validated in the L1 instruction cache, and the
 
\family typewriter 
\size small 
icache_wakeup_func()
\family default 
\size default 
 callback is used to notify the out of order core's fetch stage that it
 may probe the cache for the missing line again.
 In any case, the miss buffer is then returned to the unused state.
\layout Standard

Each LFRQ slot can be in one of three states: 
\emph on 
free
\emph default 
, 
\emph on 
waiting
\emph default 
 and 
\emph on 
ready
\emph default 
.
 LFRQ slots remain in the 
\emph on 
waiting
\emph default 
 state as long as they are referenced by a miss buffer; once the 
\family typewriter 
\size small 
lfrq.wakeup()
\family default 
\size default 
 method is called, all slots affiliated with that miss buffer are moved
 to the 
\emph on 
ready
\emph default 
 state.
 The 
\family typewriter 
\size small 
LoadFillRequestQueue::clock()
\family default 
\size default 
 method finds up to 
\family typewriter 
\size small 
MAX_WAKEUPS_PER_CYCLE
\family default 
\size default 
 LFRQ slots in the 
\emph on 
ready
\emph default 
 state and wakes them up by calling the 
\family typewriter 
\size small 
load_filled_callback()
\family default 
\size default 
 callback with the saved 
\family typewriter 
\size small 
LoadStoreInfo
\family default 
\size default 
 metadata.
 The out of order core handles this callback as described in Section 
\begin_inset LatexCommand \ref{sec:CacheMissHandling}

\end_inset 

.
\layout Standard

For simulation purposes only, the value to be loaded is immediately recorded
 as soon as the load issues, independent of the cache hit or miss status.
 In real hardware, the LFRQ entry data would be used to extract the correct
 bytes from the newly arrived line and perform sign extension and alignment.
 If the original load required bytes from a mixture of its source store
 buffer and the data cache, the SFR data and mask fields in the LFRQ entry
 would be used to perform this merging operation.
 The data would then be written into the physical register specified by
 the 
\family typewriter 
\size small 
LoadStoreInfo
\family default 
\size default 
 metadata and that register would be marked as ready before sending a signal
 to the issue queues to wake up dependent operations.
\layout Standard

In some cases, the out of order core may need to annul speculatively executed
 loads.
 The cache subsystem is notified of this through the 
\family typewriter 
\size small 
annul_lfrq_slot()
\family default 
\size default 
 function called by the core.
 This function clears the specified LFRQ slot in each miss buffer's lfrqmap
 entry (since that slot should no longer be awakened now that it has been
 annulled), and frees the LFRQ entry itself.
\layout Section


\begin_inset LatexCommand \label{sec:TranslationLookasideBuffers}

\end_inset 

Translation Lookaside Buffers
\layout Standard

The cache subsystem includes separate translation lookaside buffers (TLBs)
 for data (DTLB) and instructions (ITLB) to map virtual to physical addresses.
 Note that virtual addresses are always used within the simulated virtual
 address space; hence the TLBs are solely for accurately measuring performance.
 To achieve fast simulation, the TLBs are not actually associatively scanned
 on each access; instead, the 
\family typewriter 
\size small 
TranslationLookasideBuffer::check()
\family default 
\size default 
 method simply checks one of the simulator's Shadow Page Access Tables (SPATs)
 as described in Section 
\begin_inset LatexCommand \ref{sec:AddressSpaceSimulation}

\end_inset 

.
 For DTLB accesses, the 
\family typewriter 
\size small 
dtlbmap
\family default 
\size default 
 SPAT is used, while ITLB accesses use the 
\family typewriter 
\size small 
itlbmap
\family default 
\size default 
 SPAT.
 If a bit in the appropriate SPAT is set, that page is considered mapped
 within the TLB.
 When entries are added to or evicted from the TLBs, the SPAT bit for the
 old entry's virtual page address must be cleared and the bit for the new
 entry's virtual page address must be set; this keeps the SPATs up to date.
\layout Standard

TLB miss penalties can be modeled in various ways.
 In most x86 processors, a hardware state machine is used to walk the 3-level
 or 4-level page table tree by issuing a chain of loads until the lowest
 level page table containing the physical address and attributes is reached.
 This can take from ~10 cycles up to hundreds of cycles if the page tables
 themselves are not already in the cache hierarchy.
 To model this, the 
\family typewriter 
\size small 
probe_cache_and_sfr()
\family default 
\size default 
 function queries the DTLB for every access, and if a miss is detected,
 it simulates an L2 cache miss to add some latency to the load causing the
 TLB miss.
 The TLB is then updated with the 
\family typewriter 
\size small 
TranslationLookasideBuffer::replace()
\family default 
\size default 
 method.
\layout Standard


\series bold 
\emph on 
NOTE:
\series default 
\emph default 
 PTLsim does not fully support self modifying code.
 Since no actual data is stored within the data and instruction caches (only
 tags are maintained), self modifying code may appear to work correctly.
 However, according to the x86 standard, any stores to any instructions
 currently in the pipeline must flush the entire pipeline; PTLsim does not
 currently do this.
\layout Chapter

Branch Prediction
\layout Section

Introduction
\layout Standard

PTLsim provides a variety of branch predictors in 
\family typewriter 
\size small 
branchpred.cpp
\family default 
\size default 
.
 The branch prediction subsystem is relatively independent of the core simulator
 and can be treated as a black box, so long as it implements the interfaces
 in 
\family typewriter 
\size small 
branchpred.h
\family default 
\size default 
.
\layout Standard

The branch prediction subsystem always contains at least three distinct
 predictors for the three main classes of branches:
\layout Itemize


\emph on 
Conditional Branch Predictor
\emph default 
 returns a boolean (taken or not taken) for each conditional branch (
\family typewriter 
\size small 
br.cc
\family default 
\size default 
 uop)
\layout Itemize


\emph on 
Branch Target Buffer
\emph default 
 (BTB) predicts indirect branch (
\family typewriter 
\size small 
jmp
\family default 
\size default 
 uop) targets
\layout Itemize


\emph on 
Return Address Stack
\emph default 
 (RAS) predicts return instructions (i.e.
 specially marked indirect 
\family typewriter 
\size small 
jmp
\family default 
\size default 
 uops) based on prior calls
\layout Itemize

Unconditional branches (
\family typewriter 
\size small 
bru
\family default 
\size default 
) are never predicted since their destination is explicitly encoded.
\layout Standard

All these predictors are accessed by the core through the 
\family typewriter 
\size small 
BranchPredictorInterface
\family default 
\size default 
 object.
 Based on the opcode and other uop information, the core determines the
 type flags of each branch uop:
\layout Itemize


\family typewriter 
\size small 
BRANCH_HINT_UNCOND
\family default 
\size default 
 for unconditional branches.
 These are never predicted since the destination is implied.
\layout Itemize


\family typewriter 
\size small 
BRANCH_HINT_COND
\family default 
\size default 
 for conditional branches.
\layout Itemize


\family typewriter 
\size small 
BRANCH_HINT_INDIRECT
\family default 
\size default 
 for indirect branches, including returns.
\layout Itemize


\family typewriter 
\size small 
BRANCH_HINT_CALL
\family default 
\size default 
 for calls (both direct and indirect).
 This implies that the return address of the call should be a should be
 pushed on the RAS.
\layout Itemize


\family typewriter 
\size small 
BRANCH_HINT_RET
\family default 
\size default 
 for returns (indirect branches).
 This implies that the return address should be taken from the top RAS stack
 entry, not the BTB.
\layout Standard

Multiple flags may be present for each uop (for instance, 
\family typewriter 
\size small 
BRANCH_HINT_RET
\family default 
\size default 
 and 
\family typewriter 
\size small 
BRANCH_HINT_INDIRECT
\family default 
\size default 
 are both used for the 
\family typewriter 
\size small 
jmp
\family default 
\size default 
 uop terminating an x86 
\family typewriter 
\size small 
ret
\family default 
\size default 
 instruction).
\layout Standard

To make a prediction at fetch time, the core calls the 
\family typewriter 
\size small 
BranchPredictorInterface::predict()
\family default 
\size default 
 method, passing it a 
\family typewriter 
\size small 
PredictorUpdate
\family default 
\size default 
 structure.
 This structure is carried along with each uop until it retires, and contains
 all the information needed to eventually update the branch predictor at
 the end of the pipeline.
 The contents will vary depending on the predictor chosen, but in general
 this structure contains pointers into internal predictor counter tables
 and various flags.
 The 
\family typewriter 
\size small 
predict() 
\family default 
\size default 
method fills in this structure.
\layout Standard

As each uop commits, the 
\family typewriter 
\size small 
BranchPredictorInterface::update()
\family default 
\size default 
 method is passed the uop's saved 
\family typewriter 
\size small 
PredictorUpdate
\family default 
\size default 
 structure and the branch outcome (expected target RIP versus real target
 RIP) so the branch predictor can be updated.
 In PTLsim, predictor updates only occur at retirement to avoid corruption
 caused by speculative instructions.
\layout Section

Conditional Branch Predictor
\layout Standard

The PTLsim conditional branch predictor is the most flexible predictor,
 since it can be easily replaced.
 The default predictor implemented in 
\family typewriter 
\size small 
branchpred.cpp
\family default 
\size default 
 is a selection based predictor.
 In essence, two separate predictors are maintained.
 The 
\emph on 
history predictor
\emph default 
 hashes a shift register of previously predicted branches into a table slot;
 this slot returns whether or not the branch with that history is predicted
 as taken.
 PTLsim supports various combinations of the history and branch address
 to provide 
\emph on 
gshare
\emph default 
 based semantics.
 The 
\emph on 
bimodal predictor
\emph default 
 is simpler; it uses 2-bit saturating counters to predict if a given branch
 is likely to be taken.
 Finally, a 
\emph on 
selection predictor
\emph default 
 specifies which of the two predictors is more accurate and should be used
 for future predictions.
 This style of predictor, sometimes called a 
\emph on 
McFarling predictor
\emph default 
, has been described extensively in the literature and variations are used
 by most modern processors.
\layout Standard

Through the 
\family typewriter 
\size small 
CombinedPredictor
\family default 
\size default 
 template class, the user can specify the sizes of all the tables (history,
 bimodal, selector), the history depth, the method in which the global history
 and branch address are combined and so on.
 Alternatively, the conditional branch predictor can be replaced with something
 entirely different if desired.
\layout Section

Branch Target Buffer
\layout Standard

The Branch Target Buffer (BTB) is essentially a small cache that maps indirect
 branch RIP addresses (i.e., 
\family typewriter 
\size small 
jmp
\family default 
\size default 
 uops) into predicted target RIP addresses.
 It is set associative, with a user configurable number of sets and ways.
 In PTLsim, the BTB does not take into account any indirect branch history
 information.
 The BTB is a nearly universal structure in branch prediction; see the literatur
e for more information.
\layout Section

Return Address Stack
\layout Standard

The Return Address Stack (RAS) predicts the target address of indirect jumps
 marked with the 
\family typewriter 
\size small 
BRANCH_HINT_RET
\family default 
\size default 
 flag.
 Whenever the 
\family typewriter 
\size small 
BRANCH_HINT_RET
\family default 
\size default 
 flag is passed to the predict() method, the top RAS stack entry is returned
 as the predicted target, overriding anything in the BTB.
\layout Standard

Unlike the conditional branch predictor and BTB, the RAS updated speculatively
 in the frontend pipeline, before the outcome of calls and returns are known.
 This allows better performance when closely spaced calls and returns must
 be predicted as they are fetched, before either the call or corresponding
 return have actually executed.
 However, when called with the 
\family typewriter 
\size small 
BRANCH_HINT_RET
\family default 
\size default 
 flag, the 
\family typewriter 
\size small 
predict()
\family default 
\size default 
 method only returns the RIP at the top of the RAS, but does not push or
 pop the RAS.
 This must be done after the corresponding 
\family typewriter 
\size small 
bru
\family default 
\size default 
 or 
\family typewriter 
\size small 
jmp
\family default 
\size default 
 (for direct and\SpecialChar ~
or indirect calls, respectively) or 
\family typewriter 
\size small 
jmp
\family default 
\size default 
 (for returns) uop is actually allocated in the ROB.
 
\layout Standard

This approach is required since the RAS is speculatively updated: if uops
 must be annulled (because of branch mispredictions or mis-speculations),
 the annulment occurs by walking backwards in the ROB until the excepting
 uop is encountered.
 However, if the RAS were updated during the fetch stage, some uops may
 not be in the ROB yet and hence the rollback logic cannot undo speculative
 changes made to the RAS by these uops.
 This causes the RAS to get out of alignment and performance suffers.
\layout Standard

To solve this problem, the RAS is only updated in the allocate stage immediately
 after fetch.
 In the out of order core's 
\family typewriter 
\size small 
rename()
\family default 
\size default 
 function, the 
\family typewriter 
\size small 
BranchPredictorInterface::updateras()
\family default 
\size default 
 method is called to either push or pop an entry from the RAS (calls push
 entries, returns pop entries).
 Unlike the conditional branch predictor and BTB, this is the only place
 the RAS is updated, rather than performing updates at commit time.
\layout Standard

If uops must be annulled, the 
\family typewriter 
\size small 
ReorderBufferEntry::annul()
\family default 
\size default 
 method calls the 
\family typewriter 
\size small 
BranchPredictorInterface::annulras()
\family default 
\size default 
 method with the 
\family typewriter 
\size small 
PredictorUpdate
\family default 
\size default 
 structure for each uop it encounters in reverse program order.
 This method effectively undoes whatever change was made to the RAS when
 the 
\family typewriter 
\size small 
updateras()
\family default 
\size default 
 method was called with the same 
\family typewriter 
\size small 
PredictorUpdate
\family default 
\size default 
 information during renaming and allocation.
 This is possible because 
\family typewriter 
\size small 
updateras()
\family default 
\size default 
 saves checkpoint information (namely, the old RAS top of stack and the
 value at that stack slot) before updating the RAS; this allows the RAS
 state to be rolled backwards in time as uops are annulled in reverse program
 order.
 At the end of the annulment process when fetching is restarted at the correct
 RIP, the RAS state should be identical to the state that existed before
 the last uop to be annulled was originally fetched.
\layout Part


\begin_inset LatexCommand \label{part:Appendices}

\end_inset 

Appendices
\layout Chapter


\begin_inset LatexCommand \label{sec:UopReference}

\end_inset 

PTLsim uop Reference
\layout Standard

The following sections document the semantics and encoding of each micro-operati
on (uop) supported by the PTLsim processor core.
 The 
\family typewriter 
\size small 
opinfo[]
\family default 
\size default 
 table in 
\family typewriter 
\size small 
ptlhwdef.cpp
\family default 
\size default 
 and constants in 
\family typewriter 
\size small 
ptlhwdef.h
\family default 
\size default 
 give actual numerical values for the opcodes and other fields described
 below.
\layout Standard
\line_bottom \pagebreak_top 

\family typewriter 
\series bold 
\size large 
\SpecialChar ~

\family sans 
\series default 
\size default 

\newline 

\size larger 
Merging Rules
\layout Standard


\begin_inset  Tabular
<lyxtabular version="3" rows="2" columns="3">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Mnemonic
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Syntax
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Operation
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
op
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = ra 
\begin_inset Formula $\leftarrow$
\end_inset 

 (ra 
\emph on 
op
\emph default 
 rb)
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Standard
\added_space_top medskip 

\family sans 
\series bold 
Merging Rules:
\layout Standard


\family sans 
The x86 compatible ALUs implement operations on 1, 2, 4 or 8 byte quantities.
 Unless otherwise indicated, all operations take a 2-bit size shift field
 (
\family typewriter 
\size small 
sz
\family sans 
\size default 
) used to determine the effective size in bytes of the operation as follows:
\layout Itemize


\family sans 
\series bold 
sz = 0:
\series default 
 Low byte of 
\emph on 
rd
\emph default 
 is set to the 8-bit result; high 7 bytes of 
\emph on 
rd
\emph default 
 are set to corresponding bytes of 
\emph on 
ra
\emph default 
.
\layout Itemize


\family sans 
\series bold 
sz = 1:
\series default 
 Low two bytes of 
\emph on 
rd
\emph default 
 is set to the 16-bit result; high 6 bytes of 
\emph on 
rd
\emph default 
 are set to corresponding bytes of 
\emph on 
ra
\emph default 
.
\layout Itemize


\family sans 
\series bold 
sz = 2:
\series default 
 Low four bytes of 
\emph on 
rd
\emph default 
 is set to the 32-bit result; high 4 bytes of 
\emph on 
rd
\emph default 
 are cleared to zero in accordance with x86-64 zero extension semantics.
 The 
\emph on 
ra
\emph default 
 operand is unused and should be 
\family typewriter 
\size small 
REG_zero
\family sans 
\size default 
.
\layout Itemize


\family sans 
\series bold 
sz = 3:
\series default 
 All 8 bytes of 
\emph on 
rd
\emph default 
 are set to the 64-bit result.
 
\emph on 
ra
\emph default 
 is unused and should be 
\family typewriter 
\size small 
REG_zero
\family sans 
\size default 
.
\layout Standard


\family sans 
Flags are calculated based on the 
\emph on 
sz
\emph default 
-byte value produced by the ALU, not the final 64-bit result in 
\emph on 
rd
\emph default 
.
\layout Standard
\added_space_top bigskip \line_bottom 

\family sans 
\size larger 
Other Pseudo-Operators
\layout Standard
\added_space_top medskip 

\family sans 
The descriptions in this reference use various pseudo-operators to describe
 the semantics of each uop.
 These operators are described below.
\layout Standard


\family sans 
\series bold 
EvalFlags(
\emph on 
ra
\emph default 
)
\layout Standard


\family sans 
The 
\emph on 
EvalFlags
\emph default 
 pseudo-operator evaluates the ZAPS, CF, OF flags attached to the source
 operand 
\emph on 
ra
\emph default 
 in accordance with the type of condition code evaluation specified by the
 uop.
 The operator returns 1 if the evaluation is true; otherwise 0 is returned.
\layout Standard


\family sans 
\series bold 
SignExt(
\emph on 
ra
\emph default 
, N)
\layout Standard


\family sans 
The 
\emph on 
SignExt
\emph default 
 operator sign extends the ra operand by the number of bits specified by
 N.
 Specifically, bit 
\emph on 
ra
\emph default 
[N] is copied to all high order bits from bit 63 down to bit 
\emph on 
N
\emph default 
.
 If N is not specified, it is assumed to mean the number of bits in the
 effective size of the uop's result (as described under Merging Rules).
\layout Standard


\family sans 
\series bold 
MergeWithSFR(mem, sfr)
\layout Standard


\family sans 
The 
\emph on 
MergeWithSFR
\emph default 
 pseudo-operator is described in the reference page for load uops.
\layout Standard


\family sans 
\series bold 
MergeAlign(mem, sfr)
\layout Standard


\family sans 
The 
\emph on 
MergeAlign
\emph default 
 pseudo-operator is described in the reference page for load uops.
\layout Standard
\line_bottom \pagebreak_top 

\family typewriter 
\series bold 
\size large 
mov and or xor andnot ornot nand nor eqv
\family sans 
\series default 
\size default 

\newline 

\size larger 
Logical Operations
\layout Standard


\begin_inset  Tabular
<lyxtabular version="3" rows="10" columns="3">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="block" valignment="top" width="0">
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Mnemonic
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Syntax
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Operation
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
mov
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = ra 
\begin_inset Formula $\leftarrow$
\end_inset 

 rb
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
and
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = ra 
\begin_inset Formula $\leftarrow$
\end_inset 

 ra & rb
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
or
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = ra 
\begin_inset Formula $\leftarrow$
\end_inset 

 ra | rb
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
xor
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = ra 
\begin_inset Formula $\leftarrow$
\end_inset 

 ra ^ rb
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
andnot
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = ra 
\begin_inset Formula $\leftarrow$
\end_inset 

 (~ra) & rb
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
ornot
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = ra 
\begin_inset Formula $\leftarrow$
\end_inset 

 (~ra) | rb
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
nand
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = ra 
\begin_inset Formula $\leftarrow$
\end_inset 

 ~(ra & rb)
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
nor
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = ra 
\begin_inset Formula $\leftarrow$
\end_inset 

 ~(ra | rb)
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
eqv
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = ra 
\begin_inset Formula $\leftarrow$
\end_inset 

 ~(ra ^ rb)
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Standard
\added_space_top medskip 

\family sans 
\series bold 
Notes:
\layout Itemize


\family sans 
All operations merge the ALU result with 
\emph on 
ra
\emph default 
 and generate flags in accordance with the standard x86 merging rules described
 previously.
\layout Standard
\line_bottom \pagebreak_top 

\family typewriter 
\series bold 
\size large 
add sub addadd addsub subadd subsub addm subm addc subc
\family sans 
\series default 
\size default 

\newline 

\size larger 
Add and Subtract
\layout Standard


\begin_inset  Tabular
<lyxtabular version="3" rows="9" columns="3">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Mnemonic
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Syntax
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Operation
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
add
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = ra 
\begin_inset Formula $\leftarrow$
\end_inset 

 ra + rb
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
sub
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = ra 
\begin_inset Formula $\leftarrow$
\end_inset 

 ra - rb
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
adda
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb,rc*S
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = ra 
\begin_inset Formula $\leftarrow$
\end_inset 

 ra + rb + (rc << S)
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
adds
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb,rc*S
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = ra 
\begin_inset Formula $\leftarrow$
\end_inset 

 ra - rb + (rc << S)
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
addm
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb,rc
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = ra 
\begin_inset Formula $\leftarrow$
\end_inset 

 (ra + rb) & rc
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
subm
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb,rc
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = ra 
\begin_inset Formula $\leftarrow$
\end_inset 

 (ra - rb) & rc
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
addc
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb,rc
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = ra 
\begin_inset Formula $\leftarrow$
\end_inset 

 (ra + rb) + rc.cf
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
subc
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb,rc
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = ra 
\begin_inset Formula $\leftarrow$
\end_inset 

 (ra - rb) - rc.cf
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Standard
\added_space_top medskip 

\family sans 
\series bold 
Notes:
\layout Itemize


\family sans 
All operations merge the ALU result with 
\emph on 
ra
\emph default 
 and generate flags in accordance with the standard x86 merging rules described
 previously.
\layout Itemize


\family sans 
The 
\family typewriter 
\size small 
adda
\family sans 
\size default 
 and 
\family typewriter 
\size small 
adds
\family sans 
\size default 
 uops are useful for small shifts and x86 three-operand 
\family typewriter 
\size small 
LEA
\family sans 
\size default 
-style address generation.
\layout Itemize


\family sans 
The 
\family typewriter 
\size small 
addc
\family sans 
\size default 
 and 
\family typewriter 
\size small 
subc
\family sans 
\size default 
 uops use only the carry flag field of their rc operand; the value is unused.
\layout Itemize


\family sans 
The 
\family typewriter 
\size small 
addm
\family sans 
\size default 
 and 
\family typewriter 
\size small 
subm
\family sans 
\size default 
 uops mask the result by the immediate in 
\emph on 
rc
\emph default 
.
 They are used in microcode for modular stack arithmetic.
\layout Standard
\line_bottom \pagebreak_top 

\family typewriter 
\series bold 
\size large 
sel
\family sans 
\series default 
\size default 

\newline 

\size larger 
Conditional Select
\layout Standard


\begin_inset  Tabular
<lyxtabular version="3" rows="2" columns="3">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Mnemonic
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Syntax
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Operation
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
sel.
\emph on 
cc
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb,(rc)
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = ra 
\begin_inset Formula $\leftarrow$
\end_inset 

 (EvalFlags(rc)) ? rb : ra
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Standard
\added_space_top medskip 

\family sans 
\series bold 
Notes:
\layout Itemize


\family sans 
\series bold 
\emph on 
cc
\series default 
\emph default 
 is any valid condition code flag evaluation
\layout Itemize


\family sans 
The 
\family typewriter 
\size small 
sel
\family sans 
\size default 
 uop merges the selected operand with 
\emph on 
ra
\emph default 
 in accordance with the standard x86 merging rules described previously
\layout Itemize


\family sans 
The 64-bit result and all flags are treated as a single value for selection
 purposes, i.e.
 the flags attached to the selected input are passed to the output
\layout Itemize


\family sans 
If one of the (ra, rb) operands is not valid (has 
\family typewriter 
\size small 
FLAG_INV
\family sans 
\size default 
 set) but the selected operand is valid, the result is valid.
 This is an exception to the invalid bit propagation rule only when the
 selected input is valid.
 If the 
\emph on 
rc
\emph default 
 operand is invalid, the result is always invalid.
\layout Itemize


\family sans 
If any of the inputs are waiting (
\family typewriter 
\size small 
FLAG_WAIT
\family sans 
\size default 
 is set), the uop does not issue, even if the selected input was ready.
 This is a pipeline simplification.
\layout Itemize


\family sans 
set rd = (a),b
\layout Itemize


\family sans 
sel rd = b,0,1,c
\layout Standard
\line_bottom \pagebreak_top 

\family typewriter 
\series bold 
\size large 
set
\family sans 
\series default 
\size default 

\newline 

\size larger 
Conditional Set
\layout Standard


\begin_inset  Tabular
<lyxtabular version="3" rows="2" columns="3">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Mnemonic
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Syntax
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Operation
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
set.
\emph on 
cc
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb,(rc)
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = ra 
\begin_inset Formula $\leftarrow$
\end_inset 

 EvalFlags(rc) ? rb : 0
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Standard
\added_space_top medskip 

\family sans 
\series bold 
Notes:
\layout Itemize


\family sans 
\series bold 
\emph on 
cc
\series default 
\emph default 
 is any valid condition code flag evaluation
\layout Itemize


\family sans 
The value 0 or 1 is zero extended to the operation size and merged with
 
\emph on 
rb
\emph default 
 in accordance with the standard x86 merging rules described previously
 (except that 
\family typewriter 
\size small 
set
\family sans 
\size default 
 uses 
\emph on 
rb
\emph default 
 as the merge target instead of 
\emph on 
ra
\emph default 
)
\layout Itemize


\family sans 
Flags attached to 
\emph on 
ra
\emph default 
 (condition code) are passed through to the output
\layout Standard
\line_bottom \pagebreak_top 

\family typewriter 
\series bold 
\size large 
set.sub set.and
\family sans 
\series default 
\size default 

\newline 

\size larger 
Conditional Compare and Set 
\layout Standard


\begin_inset  Tabular
<lyxtabular version="3" rows="3" columns="3">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Mnemonic
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Syntax
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Operation
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
set.sub.
\emph on 
cc
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb,rc
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = rc 
\begin_inset Formula $\leftarrow$
\end_inset 

 EvalFlags(ra - rb) ? 1 : 0
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
set.and.
\emph on 
cc
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb,rc
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = rc 
\begin_inset Formula $\leftarrow$
\end_inset 

 EvalFlags(ra & rb) ? 1 : 0
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Standard
\added_space_top medskip 

\family sans 
\series bold 
Notes:
\layout Itemize


\family sans 
The 
\family typewriter 
\size small 
set.sub
\family sans 
\size default 
 and 
\family typewriter 
\size small 
set.and
\family sans 
\size default 
 uops take the place of a 
\family typewriter 
\size small 
sub
\family sans 
\size default 
 or 
\family typewriter 
\size small 
and
\family sans 
\size default 
 uop immediately consumed by a 
\family typewriter 
\size small 
set
\family sans 
\size default 
 uop; this is intended to shorten the critical path if uop merging is performed
 by the processor
\layout Itemize


\family sans 
\series bold 
\emph on 
cc
\series default 
\emph default 
 is any valid condition code flag evaluation
\layout Itemize


\family sans 
The value 0 or 1 is zero extended to the operation size and then merged
 with 
\emph on 
rc
\emph default 
 in accordance with the standard x86 merging rules described previously
 (except that 
\family typewriter 
\size small 
set.sub
\family sans 
\size default 
 and 
\family typewriter 
\size small 
set.and
\family sans 
\size default 
 use 
\emph on 
rc
\emph default 
 as the merge target instead of 
\emph on 
ra
\emph default 
)
\layout Itemize


\family sans 
Flags generated as the result of the comparison are passed through with
 the result
\layout Standard
\line_bottom \pagebreak_top 

\family typewriter 
\series bold 
\size large 
br
\family sans 
\series default 
\size default 

\newline 

\size larger 
Conditional Branch
\layout Standard


\begin_inset  Tabular
<lyxtabular version="3" rows="2" columns="3">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Mnemonic
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Syntax
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Operation
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
br
\emph on 
.cc
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rip = (ra,rb),riptaken,ripseq
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rip = EvalFlags(ra) ? riptaken : ripseq
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Standard
\added_space_top medskip 

\family sans 
\series bold 
Notes:
\layout Itemize


\family sans 
\series bold 
\emph on 
cc
\series default 
\emph default 
 is any valid condition code flag evaluation
\layout Itemize


\family sans 
The 
\family typewriter 
\size small 
rip
\family sans 
\size default 
 (user-visible instruction pointer register) is reset to one of two immediates.
 If the flags evaluation is true, the 
\emph on 
riptaken
\emph default 
 immediate is selected; otherwise the 
\emph on 
ripseq
\emph default 
 immediate is selected.
\layout Itemize


\family sans 
If the flag evaluation is false (i.e., ripseq is selected), the 
\family typewriter 
\size small 
BranchMispredict
\family sans 
\size default 
 internal exception is raised.
 The processor should annul all uops after the branch and restart fetching
 at the RIP specified by the result (in this case, 
\emph on 
ripseq
\emph default 
).
\layout Itemize


\family sans 
Branches are always assumed to be taken.
 If the branch is predicted as not taken (i.e.
 future uops come from the next sequential RIP after the branch), it is
 the responsibility of the decoder or frontend to swap the 
\emph on 
riptaken
\emph default 
 and 
\emph on 
ripseq
\emph default 
 immediates and invert the condition of the branch.
 All condition encodings can be inverted by inverting bit 0 of the 4-bit
 condition specifier.
\layout Itemize


\family sans 
The destination register should always be 
\family typewriter 
\size small 
REG_rip
\family sans 
\size default 
; otherwise this uop is undefined.
\layout Itemize


\family sans 
If the target RIP falls within an unmapped page, not present page or a page
 marked as no-execute (NX), the 
\family typewriter 
\size small 
PageFaultOnExec
\family sans 
\size default 
 exception is taken.
\layout Itemize


\family sans 
No flags are generated by this uop
\layout Standard
\line_bottom \pagebreak_top 

\family typewriter 
\series bold 
\size large 
br.sub br.and
\family sans 
\series default 
\size default 

\newline 

\size larger 
Compare and Conditional Branch
\layout Standard


\begin_inset  Tabular
<lyxtabular version="3" rows="3" columns="3">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Mnemonic
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Syntax
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Operation
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
br
\emph on 
.cc
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rip = ra,rb,riptaken,ripseq
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rip = EvalFlags(ra - rb) ? riptaken : ripseq
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
br
\emph on 
.cc
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rip = ra,rb,riptaken,ripseq
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rip = EvalFlags(ra & rb) ? riptaken : ripseq
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Standard
\added_space_top medskip 

\family sans 
\series bold 
Notes:
\layout Itemize


\family sans 
The 
\family typewriter 
\size small 
br.sub
\family sans 
\size default 
 and 
\family typewriter 
\size small 
br.and
\family sans 
\size default 
 uops take the place of a 
\family typewriter 
\size small 
sub
\family sans 
\size default 
 or 
\family typewriter 
\size small 
and
\family sans 
\size default 
 uop immediately consumed by a 
\family typewriter 
\size small 
br
\family sans 
\size default 
 uop; this is intended to shorten the critical path if uop merging is performed
 by the processor
\layout Itemize


\family sans 
\series bold 
\emph on 
cc
\series default 
\emph default 
 is any valid condition code flag evaluation
\layout Itemize


\family sans 
The 
\family typewriter 
\size small 
rip
\family sans 
\size default 
 (user-visible instruction pointer register) is reset to one of two immediates.
 If the flags evaluation is true, the 
\emph on 
riptaken
\emph default 
 immediate is selected; otherwise the 
\emph on 
ripseq
\emph default 
 immediate is selected
\layout Itemize


\family sans 
If the flag evaluation is false (i.e., ripseq is selected), the 
\family typewriter 
\size small 
BranchMispredict
\family sans 
\size default 
 internal exception is raised.
 The processor should annul all uops after the branch and restart fetching
 at the RIP specified by the result (in this case, 
\emph on 
ripseq
\emph default 
)
\layout Itemize


\family sans 
Branches are always assumed to be taken.
 If the branch is predicted as not taken (i.e.
 future uops come from the next sequential RIP after the branch), it is
 the responsibility of the decoder or frontend to swap the 
\emph on 
riptaken
\emph default 
 and 
\emph on 
ripseq
\emph default 
 immediates and invert the condition of the branch.
 All condition encodings can be inverted by inverting bit 0 of the 4-bit
 condition specifier.
\layout Itemize


\family sans 
The destination register should always be 
\family typewriter 
\size small 
REG_rip
\family sans 
\size default 
; otherwise this uop is undefined
\layout Itemize


\family sans 
If the target RIP falls within an unmapped page, not present page or a page
 marked as no-execute (NX), the 
\family typewriter 
\size small 
PageFaultOnExec
\family sans 
\size default 
 exception is taken.
\layout Itemize


\family sans 
Flags generated as the result of the comparison are passed through with
 the result
\layout Standard
\line_bottom \pagebreak_top 

\family typewriter 
\series bold 
\size large 
jmp
\family sans 
\series default 
\size default 

\newline 

\size larger 
Indirect Jump
\layout Standard


\begin_inset  Tabular
<lyxtabular version="3" rows="2" columns="3">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Mnemonic
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Syntax
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Operation
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
jmp
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rip = ra,riptaken
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rip = ra
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Standard
\added_space_top medskip 

\family sans 
\series bold 
Notes:
\layout Itemize


\family sans 
The 
\family typewriter 
\size small 
rip
\family sans 
\size default 
 (user-visible instruction pointer register) is reset to the target address
 specified by 
\emph on 
ra
\layout Itemize


\family sans 
If the 
\emph on 
ra
\emph default 
 operand does not match the 
\emph on 
riptaken
\emph default 
 immediate, the 
\family typewriter 
\size small 
BranchMispredict
\family sans 
\size default 
 internal exception is raised.
 The processor should annul all uops after the branch and restart fetching
 at the RIP specified by the result (in this case, 
\emph on 
ra
\emph default 
)
\layout Itemize


\family sans 
Indirect jumps are always assumed to match the predicted target in 
\emph on 
riptaken
\emph default 
.
 If some other target is predicted, it is the responsibility of the decoder
 or frontend to set the 
\emph on 
riptaken
\emph default 
 immediate to that predicted target
\layout Itemize


\family sans 
The destination register should always be 
\family typewriter 
\size small 
REG_rip
\family sans 
\size default 
; otherwise this uop is undefined
\layout Itemize


\family sans 
If the target RIP falls within an unmapped page, not present page or a marked
 as no-execute (NX), the 
\family typewriter 
\size small 
PageFaultOnExec
\family sans 
\size default 
 exception is taken.
\layout Itemize


\family sans 
No flags are generated by this uop
\layout Standard
\line_bottom \pagebreak_top 

\family typewriter 
\series bold 
\size large 
jmpp
\family sans 
\series default 
\size default 

\newline 

\size larger 
Indirect Jump Within Microcode
\layout Standard


\begin_inset  Tabular
<lyxtabular version="3" rows="2" columns="3">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Mnemonic
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Syntax
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Operation
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
jmpp
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
null = ra,riptaken
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
internalrip = ra
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Standard
\added_space_top medskip 

\family sans 
\series bold 
Notes:
\layout Itemize


\family sans 
The 
\family typewriter 
\size small 
jmpp
\family sans 
\size default 
 uop redirects uop fetching into microcode not accessible as x86 instructions.
 The target address (inside PTLsim, not x86 space) is specified by 
\emph on 
ra
\layout Itemize


\family sans 
If the 
\emph on 
ra
\emph default 
 operand does not match the 
\emph on 
riptaken
\emph default 
 immediate, the 
\family typewriter 
\size small 
BranchMispredict
\family sans 
\size default 
 internal exception is raised.
 The processor should annul all uops after the branch and restart fetching
 at the RIP specified by the result (in this case, 
\emph on 
ra
\emph default 
)
\layout Itemize


\family sans 
Indirect jumps are always assumed to match the predicted target in 
\emph on 
riptaken
\emph default 
.
 If some other target is predicted, it is the responsibility of the decoder
 or frontend to set the 
\emph on 
riptaken
\emph default 
 immediate to that predicted target
\layout Itemize


\family sans 
The destination register should always be 
\family typewriter 
\size small 
REG_rip
\family sans 
\size default 
; otherwise this uop is undefined
\layout Itemize


\family sans 
The user visible rip register is not updated after this uop issues; otherwise
 it would point into PTLsim space not accessible to x86 code.
 Updating is resumed after a normal 
\family typewriter 
\size small 
jmp
\family sans 
\size default 
 issues to return to user code.
 It is the responsibility of the decoder to move the user address to return
 to into some temporary register (traditionally 
\family typewriter 
\size small 
REG_sr2
\family sans 
\size default 
 but this is not required).
\layout Itemize


\family sans 
No flags are generated by this uop
\layout Standard
\line_bottom \pagebreak_top 

\family typewriter 
\series bold 
\size large 
bru
\family sans 
\series default 
\size default 

\newline 

\size larger 
Unconditional Branch
\layout Standard


\begin_inset  Tabular
<lyxtabular version="3" rows="2" columns="3">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Mnemonic
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Syntax
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Operation
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
bru
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rip = riptaken
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rip = riptaken
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Standard
\added_space_top medskip 

\family sans 
\series bold 
Notes:
\layout Itemize


\family sans 
The 
\family typewriter 
\size small 
rip
\family sans 
\size default 
 (user-visible instruction pointer register) is reset to the specified immediate.
 The processor may redirect fetching from the new RIP
\layout Itemize


\family sans 
No exceptions are possible with unconditional branches
\layout Itemize


\family sans 
If the target RIP falls within an unmapped page, not present page or a marked
 as no-execute (NX), the 
\family typewriter 
\size small 
PageFaultOnExec
\family sans 
\size default 
 exception is taken.
\layout Itemize


\family sans 
No flags are generated by this uop
\layout Standard
\line_bottom \pagebreak_top 

\family typewriter 
\series bold 
\size large 
brp
\family sans 
\series default 
\size default 

\newline 

\size larger 
Unconditional Branch Within Microcode
\layout Standard


\begin_inset  Tabular
<lyxtabular version="3" rows="2" columns="3">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Mnemonic
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Syntax
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Operation
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
bru
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
null = riptaken
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
internalrip = riptaken
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Standard
\added_space_top medskip 

\family sans 
\series bold 
Notes:
\layout Itemize


\family sans 
The 
\family typewriter 
\size small 
brp
\family sans 
\size default 
 uop redirects uop fetching into microcode not accessible as x86 instructions.
 The target address (inside PTLsim, not x86 space) is specified by the 
\emph on 
riptaken
\emph default 
 immediate
\layout Itemize


\family sans 
The 
\family typewriter 
\size small 
rip
\family sans 
\size default 
 (user-visible instruction pointer register) is reset to the specified 
\emph on 
riptaken
\emph default 
 immediate.
 The processor may redirect fetching from the new RIP
\layout Itemize


\family sans 
No exceptions are possible with unconditional branches
\layout Itemize


\family sans 
The user visible rip register is not updated after this uop issues; otherwise
 it would point into PTLsim space not accessible to x86 code.
 Updating is resumed after a normal 
\family typewriter 
\size small 
jmp
\family sans 
\size default 
 uop issues to return to user code.
 It is the responsibility of the decoder to move the user address to return
 to into some temporary register (traditionally 
\family typewriter 
\size small 
REG_sr2
\family sans 
\size default 
 but this is not required).
\layout Itemize


\family sans 
No flags are generated by this uop
\layout Standard
\line_bottom \pagebreak_top 

\family typewriter 
\series bold 
\size large 
chk
\family sans 
\series default 
\size default 

\newline 

\size larger 
Check Speculation
\layout Standard


\begin_inset  Tabular
<lyxtabular version="3" rows="2" columns="3">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Mnemonic
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Syntax
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Operation
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
chk
\emph on 
.cc
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,recrip,extype
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = EvalCheck(ra) ? 0 : recrip
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Standard
\added_space_top medskip 

\family sans 
\series bold 
Notes:
\layout Itemize


\family sans 
The 
\family typewriter 
\size small 
chk
\family sans 
\size default 
 uop verifies 
\emph on 
certain
\emph default 
 properties about ra.
 If this verification check passes, no action is taken.
 If the check fails, 
\family typewriter 
\size small 
chk
\family sans 
\size default 
 signals an exception of the user specified type in the 
\emph on 
rc
\emph default 
 immediate.
 The result of the 
\family typewriter 
\size small 
chk
\family sans 
\size default 
 uop in this case is the user specified RIP to recover at after the check
 failure is handled in microcode.
 This recovery RIP is saved in the 
\family typewriter 
\size small 
recoveryrip
\family sans 
\size default 
 internal register.
\layout Itemize


\family sans 
This mechanism is intended to allow simple inlined uop sequences to branch
 into microcode if certain conditions fail, since normally inlined uop sequences
 cannot contain embedded branches.
 One example use is in the 
\family typewriter 
\size small 
REP
\family sans 
\size default 
 series of instructions to ensure that the count is not zero on entry (a
 special corner case).
\layout Itemize


\family sans 
Unlike most conditional uops, the 
\family typewriter 
\size small 
chk
\family sans 
\size default 
 uop directly checks the numerical value of 
\emph on 
ra
\emph default 
 against zero, and ignores any attached flags.
 Therefore, the 
\series bold 
\emph on 
cc
\series default 
\emph default 
 condition code flag evaluation type is restricted to the subset (e, ne,
 be, nbe, l, nl, le, nle).
\layout Itemize


\family sans 
No flags are generated by this uop
\layout Standard
\line_bottom \pagebreak_top 

\family typewriter 
\series bold 
\size large 
ld ld.lo ld.hi ldx ldx.lo ldx.hi
\family sans 
\series default 
\size default 

\newline 

\size larger 
Load
\layout Standard


\begin_inset  Tabular
<lyxtabular version="3" rows="4" columns="3">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="block" valignment="top" width="50col%">
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Mnemonic
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Syntax
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Operation
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
ld
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = [ra,rb],sfra
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = MergeWithSFR(mem[ra + rb], sfra)
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
ld.lo
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = [ra+rb],sfra
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = MergeWithSFR(mem[floor(ra + rb), 8], sfra)
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
ld.hi
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = [ra+rb],rc,sfra
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = MergeAlign(
\newline 
\SpecialChar ~
\SpecialChar ~
MergeWithSFR(mem[(floor(ra + rb), 8) + 8], sfra), rc)
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Standard
\added_space_top medskip 

\family sans 
\series bold 
Notes:
\layout Itemize


\family sans 
\emph on 
The PTLsim load unit model is described in substantial detail in Section
 
\begin_inset LatexCommand \ref{sec:IssuingLoads}

\end_inset 

; this section only gives an overview of the load uop semantics.
\layout Itemize


\family sans 
The 
\family typewriter 
\size small 
ld
\family sans 
\size default 
 family of uops loads values from the virtual address specified by the sum
 
\emph on 
ra
\emph default 
 + 
\emph on 
rb
\emph default 
.
 The 
\family typewriter 
\size small 
ld
\family sans 
\size default 
 form zero extends the loaded value, while the 
\family typewriter 
\size small 
ldx
\family sans 
\size default 
 form sign extends the loaded value to 64 bits.
\layout Itemize


\family sans 
All values are zero or sign extended to 64 bits; no subword merging takes
 place as with ALU uops.
 The decoder is responsible for following the load with an explicit 
\family typewriter 
\size small 
mov
\family sans 
\size default 
 uop to merge 8-bit and 16-bit loads with their old destination register.
\layout Itemize


\family sans 
The 
\emph on 
sfra
\emph default 
 operand specifies the store forwarding register (a.k.a.
 store buffer) to merge with data from the cache to form the final result.
 The inherited SFR may be determined dynamically by querying a store queue
 or can be predicted statically.
\layout Itemize


\family sans 
If the load misses the cache, the 
\family typewriter 
\size small 
FLAG_WAIT
\family sans 
\size default 
 flag of the result is set.
\layout Itemize


\family sans 
Load uops do not generate any other condition code flags
\layout Standard


\family sans 
\series bold 
Unaligned Load Support:
\layout Itemize


\family sans 
The processor supports unaligned loads via a pair of 
\family typewriter 
\size small 
ld.lo
\family sans 
\size default 
 and 
\family typewriter 
\size small 
ld.hi
\family sans 
\size default 
 uops; an overview can be found in Section 
\begin_inset LatexCommand \ref{sub:UnalignedLoadsAndStores}

\end_inset 

.
 The alignment type of the load is stored in the uop's cond field (0 = 
\family typewriter 
\size small 
ld
\family sans 
\size default 
, 1 = 
\family typewriter 
\size small 
ld.lo
\family sans 
\size default 
, 2 = 
\family typewriter 
\size small 
ld.hi
\family sans 
\size default 
).
\layout Itemize


\family sans 
The 
\family typewriter 
\size small 
ld.lo
\family sans 
\size default 
 uop rounds down its effective address 
\begin_inset Formula $\left\lfloor ra+rb\right\rfloor $
\end_inset 

 to the nearest 64-bit boundary and performs the load.
 The 
\family typewriter 
\size small 
ld.hi
\family sans 
\size default 
 uop rounds 
\begin_inset Formula $\left\lceil ra+rb+8\right\rceil $
\end_inset 

 up to the next 64-bit boundary, performs a load at that address, then takes
 as its third rc operand the first (
\family typewriter 
\size small 
ld.lo
\family sans 
\size default 
) load's result.
 The two loads are concatenated into a 128-bit word and the final unaligned
 data is extracted (and sign extended if the 
\family typewriter 
\size small 
ldx
\family sans 
\size default 
 form was used).
 
\layout Itemize


\family sans 
Special corner case for when the actual user address (
\emph on 
ra
\emph default 
 + 
\emph on 
rb
\emph default 
) did not actually require any bytes in the 8-byte range loaded by the 
\family typewriter 
\size small 
ld.hi
\family sans 
\size default 
 uop (i.e.
 the load was contained entirely within the low 64-bit aligned chunk).
 Since it is perfectly legal to do an unaligned load to the very end of
 the page such that the next 64 bit chunk is not mapped to a valid page,
 the 
\family typewriter 
\size small 
ld.hi
\family sans 
\size default 
 uop does not actually access memory; the entire result is extracted from
 the prior 
\family typewriter 
\size small 
ld.lo
\family sans 
\size default 
 result in the 
\emph on 
rc
\emph default 
 operand.
\layout Standard


\family sans 
\series bold 
Exceptions:
\layout Itemize


\family typewriter 
\size small 
UnalignedAccess
\family sans 
\size default 
 if the address (
\emph on 
ra
\emph default 
 + 
\emph on 
rb
\emph default 
) is not aligned to an integral multiple of the size in bytes of the load.
 Unaligned loads (
\family typewriter 
\size small 
ld.lo
\family sans 
\size default 
 and 
\family typewriter 
\size small 
ld.hi
\family sans 
\size default 
) do not generate this exception.
 Since x86 automatically corrects alignment problems, microcode must handle
 this exception as described in Section 
\begin_inset LatexCommand \ref{sub:UnalignedLoadsAndStores}

\end_inset 

.
\layout Itemize


\family typewriter 
\size small 
PageFaultOnRead
\family sans 
\size default 
 if the virtual address (
\emph on 
ra
\emph default 
 + 
\emph on 
rb
\emph default 
) falls on a page not accessible to the caller in the current operating
 mode, or a page marked as not present.
\layout Itemize


\family sans 
Various other exceptions and replay conditions may exist depending on the
 specific processor core model.
\layout Standard
\line_bottom \pagebreak_top 

\family typewriter 
\series bold 
\size large 
st
\family sans 
\series default 
\size default 

\newline 

\size larger 
Store
\layout Standard


\begin_inset  Tabular
<lyxtabular version="3" rows="4" columns="3">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Mnemonic
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Syntax
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Operation
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
st
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
sfrd = [ra,rb],rc,sfra
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
sfrd = MergeWithSFR((ra + rb), sfra, rc)
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
st.lo
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
sfrd = [ra+rb],rc,sfra
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
sfrd = MergeWithSFR(floor(ra + rb, 8), sfra, rc)
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
st.hi
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
sfrd = [ra+rb],rc,sfra
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
sfrd = MergeWithSFR(floor(ra + rb, 8) + 8, sfra, rc)
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Standard
\added_space_top medskip 

\family sans 
\series bold 
Notes:
\layout Itemize


\family sans 
\emph on 
The PTLsim store unit model is described in substantial detail in Section
 
\begin_inset LatexCommand \ref{sec:StoreMerging}

\end_inset 

; this section only gives an overview of the store uop semantics.
\layout Itemize


\family sans 
The 
\family typewriter 
\size small 
st
\family sans 
\size default 
 family of uops prepares values to be stored to the virtual address specified
 by the sum 
\emph on 
ra
\emph default 
 + 
\emph on 
rb
\emph default 
.
\layout Itemize


\family sans 
The 
\emph on 
sfra
\emph default 
 operand specifies the store forwarding register (a.k.a.
 store buffer) to merge the data to be stored (the 
\emph on 
rc
\emph default 
 operand) into.
 The inherited SFR may be determined dynamically by querying a store queue
 or can be predicted statically, as described in 
\emph on 

\begin_inset LatexCommand \ref{sec:StoreMerging}

\end_inset 

.
\layout Itemize


\family sans 
Store uops only generate the SFR for tracking purposes; the cache is only
 written when the SFR is committed.
\layout Itemize


\family sans 
The store uop may issue as soon as the 
\emph on 
ra
\emph default 
 and 
\emph on 
rb
\emph default 
 operands are ready, even if the 
\emph on 
rc
\emph default 
 and 
\emph on 
sfra
\emph default 
 operands are not known.
 The store must be replayed once these operands become known, in accordance
 with Section 
\begin_inset LatexCommand \ref{sec:SplitPhaseStores}

\end_inset 

.
\layout Itemize


\family sans 
Store uops do not generate any other condition code flags
\layout Standard


\family sans 
\series bold 
Unaligned Store Support:
\layout Itemize


\family sans 
The processor supports unaligned stores via a pair of 
\family typewriter 
\size small 
st.lo
\family sans 
\size default 
 and 
\family typewriter 
\size small 
st.hi
\family sans 
\size default 
 uops; an overview can be found in Section 
\begin_inset LatexCommand \ref{sub:UnalignedLoadsAndStores}

\end_inset 

.
 The alignment type of the load is stored in the uop's cond field (0 = 
\family typewriter 
\size small 
st
\family sans 
\size default 
, 1 = 
\family typewriter 
\size small 
st.lo
\family sans 
\size default 
, 2 = 
\family typewriter 
\size small 
st.hi
\family sans 
\size default 
).
\layout Itemize

Stores are handled in a similar manner, with 
\family typewriter 
\size small 
st.lo
\family default 
\size default 
 and 
\family typewriter 
\size small 
st.hi
\family default 
\size default 
 rounding down and up to store parts of the unaligned value in adjacent
 64-bit blocks.
 
\layout Itemize


\family sans 
The 
\family typewriter 
\size small 
st.lo
\family sans 
\size default 
 uop rounds down its effective address 
\begin_inset Formula $\left\lfloor ra+rb\right\rfloor $
\end_inset 

 to the nearest 64-bit boundary and stores the appropriately aligned portion
 of the 
\family typewriter 
\size small 
rc
\family sans 
\size default 
 operand that actually falls within that range of 8 bytes.
 The 
\family typewriter 
\size small 
ld.hi
\family sans 
\size default 
 uop rounds 
\begin_inset Formula $\left\lceil ra+rb+8\right\rceil $
\end_inset 

 up to the next 64-bit boundary and similarly stores the appropriately aligned
 portion of the 
\family typewriter 
\size small 
rc
\family sans 
\size default 
 operand that actually falls within that high range of 8 bytes.
\layout Itemize


\family sans 
Special corner case for when the actual user address (
\emph on 
ra
\emph default 
 + 
\emph on 
rb
\emph default 
) did not actually touch any bytes in the 8-byte range normally written
 by the 
\family typewriter 
\size small 
st.hi
\family sans 
\size default 
 uop (i.e.
 the store was contained entirely within the low 64-bit aligned chunk).
 Since it is perfectly legal to do an unaligned store to the very end of
 the page such that the next 64 bit chunk is not mapped to a valid page,
 the 
\family typewriter 
\size small 
st.hi
\family sans 
\size default 
 uop does not actually do anything in this case (the bytemask of the generated
 SFR is set to zero and no exceptions are checked).
\layout Standard


\family sans 
\series bold 
Exceptions:
\layout Itemize


\family typewriter 
\size small 
UnalignedAccess
\family sans 
\size default 
 if the address (
\emph on 
ra
\emph default 
 + 
\emph on 
rb
\emph default 
) is not aligned to an integral multiple of the size in bytes of the store.
 Unaligned stores (
\family typewriter 
\size small 
st.lo
\family sans 
\size default 
 and 
\family typewriter 
\size small 
st.hi
\family sans 
\size default 
) do not generate this exception.
 Since x86 automatically corrects alignment problems, microcode must handle
 this exception as described in Section 
\begin_inset LatexCommand \ref{sub:UnalignedLoadsAndStores}

\end_inset 

.
\layout Itemize


\family typewriter 
\size small 
PageFaultOnWrite
\family sans 
\size default 
 if the virtual address (
\emph on 
ra
\emph default 
 + 
\emph on 
rb
\emph default 
) falls on a write protected page, a page not accessible to the caller in
 the current operating mode, or a page marked as not present.
\layout Itemize


\family typewriter 
\size small 
LoadStoreAliasing
\family sans 
\size default 
 if a prior load is found to alias the store (see Section 
\begin_inset LatexCommand \ref{sub:AliasCheck}

\end_inset 

).
\layout Itemize


\family sans 
Various other exceptions and replay conditions may exist depending on the
 specific processor core model.
\layout Standard
\line_bottom \pagebreak_top 

\family typewriter 
\series bold 
\size large 
ldp ldxp
\family sans 
\series default 
\size default 

\newline 

\size larger 
Load from Internal Space
\layout Standard


\begin_inset  Tabular
<lyxtabular version="3" rows="3" columns="3">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Mnemonic
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Syntax
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Operation
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
ldp
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = [ra,rb]
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = MSR[ra+rb]
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
ldxp
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = [ra+rb]
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = SignExt(MSR[ra+rb])
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Standard
\added_space_top medskip 

\family sans 
\series bold 
Notes:
\layout Itemize


\family sans 
The 
\family typewriter 
\size small 
ldp
\family sans 
\size default 
 and 
\family typewriter 
\size small 
ldxp
\family sans 
\size default 
 uops load values from the internal PTLsim address space not accessible
 to x86 code.
 Typically this address space is mapped to internal machine state registers
 (MSRs) and microcode scratch space.
 The internal address to access is specified by the sum 
\emph on 
ra
\emph default 
 + 
\emph on 
rb
\emph default 
.
 The 
\family typewriter 
\size small 
ldp
\family sans 
\size default 
 form zero extends the loaded value, while the 
\family typewriter 
\size small 
ldxp
\family sans 
\size default 
 form sign extends the loaded value to 64 bits.
\layout Itemize


\family sans 
Load uops do not generate any other condition code flags
\layout Itemize


\family sans 
Internal loads may not be unaligned, and never stall or generate exceptions.
\layout Standard
\line_bottom \pagebreak_top 

\family typewriter 
\series bold 
\size large 
stp
\family sans 
\series default 
\size default 

\newline 

\size larger 
Store to Internal Space
\layout Standard


\begin_inset  Tabular
<lyxtabular version="3" rows="2" columns="3">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Mnemonic
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Syntax
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Operation
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
stp
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
null = [ra,rb],rc
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
MSR[ra+rb] = rc
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Standard
\added_space_top medskip 

\family sans 
\series bold 
Notes:
\layout Itemize


\family sans 
The 
\family typewriter 
\size small 
stp
\family sans 
\size default 
 uop stores a value to the internal PTLsim address space not accessible
 to x86 code.
 Typically this address space is mapped to internal machine state registers
 (MSRs) and microcode scratch space.
 The internal address to store is specified by the sum 
\emph on 
ra
\emph default 
 + 
\emph on 
rb
\emph default 
 and the value to store is specified by 
\emph on 
rc
\emph default 
.
\layout Itemize


\family sans 
Store uops do not generate any other condition code flags
\layout Itemize


\family sans 
Internal stores may not be unaligned, and never stall or generate exceptions.
\layout Standard
\line_bottom \pagebreak_top 

\family typewriter 
\series bold 
\size large 
shl shr sar rotl rotr rotcl rotcr
\family sans 
\series default 
\size default 

\newline 

\size larger 
Shifts and Rotates
\layout Standard


\begin_inset  Tabular
<lyxtabular version="3" rows="8" columns="3">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Mnemonic
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Syntax
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Operation
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
shl
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb,rc
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = ra 
\begin_inset Formula $\leftarrow$
\end_inset 

 (ra << rb)
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
shr
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb,rc
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = ra 
\begin_inset Formula $\leftarrow$
\end_inset 

 (ra >> rb)
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
sar
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb,rc
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = ra 
\begin_inset Formula $\leftarrow$
\end_inset 

 SignExt(ra >> rb)
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
rotl
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb,rc
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = ra 
\begin_inset Formula $\leftarrow$
\end_inset 

 (ra 
\emph on 
rotateleft
\emph default 
 rb)
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
rotr
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb,rc
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = ra 
\begin_inset Formula $\leftarrow$
\end_inset 

 (ra 
\emph on 
rotateright
\emph default 
 rb)
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
rotcl
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb,rc
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = ra 
\begin_inset Formula $\leftarrow$
\end_inset 

 ({rc.cf, ra} 
\emph on 
rotateleft
\emph default 
 rb)
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
rotcr
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb,rc
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = ra 
\begin_inset Formula $\leftarrow$
\end_inset 

 ({rc.cf, ra} 
\emph on 
rotateright
\emph default 
 rb)
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Standard
\added_space_top medskip 

\family sans 
\series bold 
Notes:
\layout Itemize


\family sans 
The shift and rotate instructions have some of the most bizarre semantics
 in the entire x86 instruction set: they may or may not modify flags depending
 on the rotation count operand, which we may not even know until the instruction
 issues.
 This is introduced in Section 
\begin_inset LatexCommand \ref{sec:ShiftRotateProblems}

\end_inset 

.
\layout Itemize


\family sans 
The specific rules are as follows:
\begin_deeper 
\layout Itemize


\family sans 
If the count 
\begin_inset Formula $rb=0$
\end_inset 

 is zero, no flags are modified
\layout Itemize


\family sans 
If the count 
\begin_inset Formula $rb=1$
\end_inset 

, both OF and CF are modified, but ZAPS is preserved
\layout Itemize


\family sans 
If the count 
\begin_inset Formula $rb>1$
\end_inset 

, only the CF is modified.
 (Technically the value in OF is undefined, but on K8 and P4, it retains
 the old value, so we try to be compatible).
\layout Itemize


\family sans 
Shifts also alter the ZAPS flags while rotates do not.
\end_deeper 
\layout Itemize


\family sans 
For constant counts (immediate 
\emph on 
rb
\emph default 
 values), the semantics are easy to determine in advance.
\layout Itemize


\family sans 
For variable counts (
\emph on 
rb
\emph default 
 comes from register), things are more complex.
 Since the shift needs to determine its output flags at runtime based on
 both the shift count and the input flags (CF, OF, ZAPS), we need to specify
 the latest versions in program order of all the existing flags.
 However, this would require three operands to the shift uop not even counting
 the value and count operands.
 Therefore, we use a 
\family typewriter 
\size small 
collcc
\family sans 
\size default 
 (collect condition code flags, see Section 
\begin_inset LatexCommand \ref{sub:FlagsManagement}

\end_inset 

) uop to get all the most up to date flags into one result, using three
 operands for ZAPS, CF, OF.
 This forms a zero word with all the correct flags attached, which is then
 forwarded as the 
\emph on 
rc
\emph default 
 operand to the shift.
 This may add additional scheduling constraints in the case that one of
 the operands to the shift itself sets the flags, but this is fairly rare.
 Conveniently, this also lets us directly implement the 65-bit 
\family typewriter 
\size small 
rotcl
\family sans 
\size default 
/
\family typewriter 
\size small 
rotcr
\family sans 
\size default 
 uops in hardware with little additional complexity.
\layout Itemize


\family sans 
All operations merge the ALU result with 
\emph on 
ra
\emph default 
 and generate flags in accordance with the standard x86 merging rules described
 previously.
\layout Itemize


\family sans 
The specific flags attached to the result depend on the input conditions
 described above.
 The user should always assume these uops always produce the latest version
 of each of the ZAPS, CF, OF flag sets.
\layout Standard
\line_bottom \pagebreak_top 

\family typewriter 
\series bold 
\size large 
mask
\family sans 
\series default 
\size default 

\newline 

\size larger 
Masking, Insertion and Extraction
\layout Standard


\begin_inset  Tabular
<lyxtabular version="3" rows="2" columns="3">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Mnemonic
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Syntax
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Operation
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
mask
\emph on 
.x|z
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb,[ms,mc,ds]
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
See semantics below
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Standard
\added_space_top medskip 

\family sans 
\series bold 
Notes:
\layout Itemize


\family sans 
The 
\family typewriter 
\size small 
mask
\family sans 
\size default 
 uop and its variants are used for generalized bit field extraction, insertion,
 sign and zero extension using the 18-bit control field in the immediate
\layout Itemize


\family sans 
These uops are used extensively within PTLsim microcode, but are also useful
 if the processor supports dynamically merging a chain of 
\family typewriter 
\size small 
shr
\family sans 
\size default 
, 
\family typewriter 
\size small 
and
\family sans 
\size default 
, 
\family typewriter 
\size small 
or
\family sans 
\size default 
 uops.
\layout Itemize


\family sans 
The condition code flags (ZAPS, CF, OF) are the flags logically generated
 by the final AND operation.
\layout Standard
\added_space_top medskip 

\family sans 
\series bold 
Control Field Format
\layout Standard


\family sans 
The 18-bit 
\emph on 
rc
\emph default 
 immediate has the following three 6-bit fields:
\layout Standard
\noindent \align center 

\family sans 

\begin_inset  Tabular
<lyxtabular version="3" rows="2" columns="3">
<features>
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" rightline="true" width="0">
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
DS
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
MC
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
MS
\end_inset 
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
12
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
6
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
0
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Itemize


\family sans 
The 
\family typewriter 
\size small 
mask
\family sans 
\size default 
 uop and its variants are used for generalized bit field extraction, insertion,
 sign and zero extension using the 18-bit control field in the immediate
\layout Standard
\added_space_top medskip 

\family sans 
\series bold 
Operation:
\layout LyX-Code


\size small 
M = 1'[(ms+mc-1):ms]
\layout LyX-Code


\size small 
T = (ra & ~M) | ((rb >>> ds) & M)
\layout LyX-Code


\size small 
if (Z) {
\layout LyX-Code


\size small 
  # Zero extend
\layout LyX-Code


\size small 
  rd = ra 
\begin_inset Formula $\leftarrow$
\end_inset 

 (T & 1'[(ms+mc-1):0])
\layout LyX-Code


\size small 
else if (X) {
\layout LyX-Code


\size small 
  # Sign extend
\layout LyX-Code


\size small 
  rd = ra 
\begin_inset Formula $\leftarrow$
\end_inset 

 (T[ms+mc-1]) ? (T | 1'[63:(ms+mc)]) : (T & 1'[(ms+mc-1):0])
\layout LyX-Code


\size small 
} else {
\layout LyX-Code


\size small 
  rd = ra 
\begin_inset Formula $\leftarrow$
\end_inset 

 T
\layout LyX-Code


\size small 
}
\layout LyX-Code

\layout Standard
\line_bottom \pagebreak_top 

\family typewriter 
\series bold 
\size large 
bswap
\family sans 
\series default 
\size default 

\newline 

\size larger 
Byte Swap
\layout Standard


\begin_inset  Tabular
<lyxtabular version="3" rows="2" columns="3">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Mnemonic
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Syntax
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Operation
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
bswap
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = ra 
\begin_inset Formula $\leftarrow$
\end_inset 

 ByteSwap(rb)
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Standard
\added_space_top medskip 

\family sans 
\series bold 
Notes:
\layout Itemize


\family sans 
The 
\family typewriter 
\size small 
bswap
\family sans 
\size default 
 uop reverses the endianness of the 
\emph on 
rb
\emph default 
 operand.
 The uop's effective result size determines the range of bytes which are
 reversed.
\layout Itemize


\family sans 
This uop's semantics are identical to the x86 
\family typewriter 
\size small 
bswap
\family sans 
\size default 
 instruction.
\layout Itemize


\family sans 
This uop does not generate any condition code flags.
\layout Standard
\line_bottom \pagebreak_top 

\family typewriter 
\series bold 
\size large 
collcc
\family sans 
\series default 
\size default 

\newline 

\size larger 
Collect Condition Codes
\layout Standard


\begin_inset  Tabular
<lyxtabular version="3" rows="2" columns="3">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="block" valignment="top" width="50col%">
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Mnemonic
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Syntax
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Operation
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
collcc
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb,rc
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd.zaps = ra.zaps 
\newline 
rd.cf = rb.cf
\newline 
rd.of = rc.of
\newline 
rd = rd.flags
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Standard
\added_space_top medskip 

\family sans 
\series bold 
Notes:
\layout Itemize


\family sans 
The 
\family typewriter 
\size small 
collcc
\family sans 
\size default 
 uop collects the condition code flags from three potentially distinct source
 operands into a single output with the combined condition code flags in
 both its appended flags and data.
\layout Itemize


\family sans 
This uop is useful for collecting all flags before passing them as input
 to another uop which only supports one source of flags (for instance, the
 shift and rotate uops).
\layout Standard
\line_bottom \pagebreak_top 

\family typewriter 
\series bold 
\size large 
movccr movrcc
\family sans 
\series default 
\size default 

\newline 

\size larger 
Move Condition Code Flags Between Register Value and Flag Parts
\layout Standard


\begin_inset  Tabular
<lyxtabular version="3" rows="3" columns="3">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="block" valignment="top" width="50col%">
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Mnemonic
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Syntax
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Operation
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
movccr
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = ra.flags
\newline 
rd.flags = 0
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
movrcc
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd.flags = ra
\newline 
rd = ra
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Standard
\added_space_top medskip 

\family sans 
\series bold 
Notes:
\layout Itemize


\family sans 
The 
\family typewriter 
\size small 
movccr
\family sans 
\size default 
 uop takes the condition code flag bits attached to 
\emph on 
ra
\emph default 
 and copies them into the 64-bit register part of the result.
\layout Itemize


\family sans 
The 
\family typewriter 
\size small 
movrcc
\family sans 
\size default 
 uop takes the low bits of the 
\emph on 
ra
\emph default 
 operand and moves those bits into the condition code flag bits attached
 to the result.
\layout Itemize


\family sans 
The bits moved consist of the ZF, PF, SF, CF, OF flags
\layout Itemize


\family sans 
The WAIT and INV flags of the result are always cleared since the uop would
 not even issue if these were set in 
\emph on 
ra
\emph default 
.
\layout Standard
\line_bottom \pagebreak_top 

\family typewriter 
\series bold 
\size large 
andcc orcc ornotcc xorcc
\family sans 
\series default 
\size default 

\newline 

\size larger 
Logical Operations on Condition Codes
\layout Standard


\begin_inset  Tabular
<lyxtabular version="3" rows="5" columns="3">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Mnemonic
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Syntax
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Operation
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
andcc
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd.flags = ra.flags & rb.flags
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
orcc
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd.flags = ra.flags | rb.flags
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
ornotcc
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd.flags = ra.flags | (~rb.flags)
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
xorcc
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd.flags = ra.flags ^ rb.flags
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Standard
\added_space_top medskip 

\family sans 
\series bold 
Notes:
\layout Itemize


\family sans 
These uops are used to perform logical operations on the condition code
 flags attached to 
\emph on 
ra
\emph default 
 and 
\emph on 
rb
\emph default 
.
\layout Itemize


\family sans 
If the 
\emph on 
rb
\emph default 
 operand is an immediate, the immediate data is used instead of the flags
 normally attached to a register operand.
\layout Itemize


\family sans 
The 64-bit value of the output is always set to zero.
\layout Standard
\line_bottom \pagebreak_top 

\family typewriter 
\series bold 
\size large 
mull mulh
\family sans 
\series default 
\size default 

\newline 

\size larger 
Integer Multiplication
\layout Standard


\begin_inset  Tabular
<lyxtabular version="3" rows="3" columns="3">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Mnemonic
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Syntax
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Operation
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
mull
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = ra 
\begin_inset Formula $\leftarrow$
\end_inset 

 lowbits(ra 
\begin_inset Formula $\times$
\end_inset 

 rb)
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
mulh
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = ra 
\begin_inset Formula $\leftarrow$
\end_inset 

 highbits(ra 
\begin_inset Formula $\times$
\end_inset 

 rb)
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Standard
\added_space_top medskip 

\family sans 
\series bold 
Notes:
\layout Itemize


\family sans 
These uops multiply 
\emph on 
ra
\emph default 
 and 
\emph on 
rb
\emph default 
, then retain only the low 
\emph on 
N
\emph default 
 bits or high 
\emph on 
N
\emph default 
 bits of the result (where N is the uop's effective result size in bits).
 This result is then merged into 
\emph on 
ra
\emph default 
.
\layout Itemize


\family sans 
The condition code flags generated by these uops correspond to the normal
 x86 semantics for integer multiplication (
\family typewriter 
\size small 
imul
\family sans 
\size default 
); the flags are calculated relative to the effective result size.
\layout Itemize


\family sans 
The 
\emph on 
rb
\emph default 
 operand may be an immediate
\layout Standard
\line_bottom \pagebreak_top 

\family typewriter 
\series bold 
\size large 
bt bts btr btc
\family sans 
\series default 
\size default 

\newline 

\size larger 
Bit Testing and Manipulation
\layout Standard


\begin_inset  Tabular
<lyxtabular version="3" rows="5" columns="3">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="block" valignment="top" width="50col%">
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Mnemonic
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Syntax
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Operation
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
bt
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd.cf = ra[rb] 
\newline 
rd = ra 
\begin_inset Formula $\leftarrow$
\end_inset 

 (rd.cf) ? -1 : +1
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
bts
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd.cf = ra[rb]
\newline 
rd = ra 
\begin_inset Formula $\leftarrow$
\end_inset 

 ra | (1 << rb)
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
btr
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd.cf = ra[rb]
\newline 
rd = ra 
\begin_inset Formula $\leftarrow$
\end_inset 

 ra & (~(1 << rb))
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
btc
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd.cf = ra[rb]
\newline 
rd = ra 
\begin_inset Formula $\leftarrow$
\end_inset 

 ra ^ (1 << rb)
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Standard
\added_space_top medskip 

\family sans 
\series bold 
Notes:
\layout Itemize


\family sans 
These uops test a given bit in 
\emph on 
ra
\emph default 
 and then atomically modify (set, reset or complement) that bit in the result.
\layout Itemize


\family sans 
The CF flag of the output is set to the original value in bit position 
\emph on 
rb
\emph default 
 of 
\emph on 
ra
\emph default 
.
 Other condition code flag bits in the output are undefined.
\layout Itemize


\family sans 
The 
\family typewriter 
\size small 
bt
\family sans 
\size default 
 (bit test) uop is special: it generates a value of -1 or +1 if the tested
 bit is 1 or 0, respectively.
 This is used in microcode for setting up an increment for the 
\family typewriter 
\size small 
rep
\family sans 
\size default 
 x86 instructions.
\layout Standard
\line_bottom \pagebreak_top 

\family typewriter 
\series bold 
\size large 
ctz clz
\family sans 
\series default 
\size default 

\newline 

\size larger 
Count Trailing or Leading Zeros
\layout Standard


\begin_inset  Tabular
<lyxtabular version="3" rows="3" columns="3">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="block" valignment="top" width="50col%">
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Mnemonic
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Syntax
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Operation
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
ctz
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd.zf = (rb == 0)
\newline 
rd = ra 
\begin_inset Formula $\leftarrow$
\end_inset 

 (rb) ? LSBIndex(rb) : 0
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
clz
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd.zf = (rb == 0)
\newline 
rd = ra 
\begin_inset Formula $\leftarrow$
\end_inset 

 (rb) ? MSBIndex(rb) : 0
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Standard
\added_space_top medskip 

\family sans 
\series bold 
Notes:
\layout Itemize


\family sans 
These uops find the bit index of the first '1' bit in 
\emph on 
rb
\emph default 
, starting from the lowest bit 0 (for 
\family typewriter 
\size small 
ctz
\family sans 
\size default 
) or the highest bit of the data type (for 
\family typewriter 
\size small 
clz
\family sans 
\size default 
).
\layout Itemize


\family sans 
The result is zero (technically, undefined) if ra is zero.
\layout Itemize


\family sans 
The ZF flag of the result is 1 if 
\emph on 
rb
\emph default 
 was zero, or 0 if 
\emph on 
rb
\emph default 
 was nonzero.
 Other condition code flags are undefined.
\layout Standard
\line_bottom \pagebreak_top 

\family typewriter 
\series bold 
\size large 
ctpop
\family sans 
\series default 
\size default 

\newline 

\size larger 
Count Population of '1' Bits
\layout Standard


\begin_inset  Tabular
<lyxtabular version="3" rows="2" columns="3">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="block" valignment="top" width="50col%">
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Mnemonic
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Syntax
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Operation
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
ctpop
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd.zf = (ra == 0)
\newline 
rd = PopulationCount(ra)
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Standard
\added_space_top medskip 

\family sans 
\series bold 
Notes:
\layout Itemize


\family sans 
The 
\family typewriter 
\size small 
ctpop
\family sans 
\size default 
 uop counts the number of '1' bits in the 
\emph on 
ra
\emph default 
 operand.
\layout Itemize


\family sans 
The ZF flag of the result is 1 if 
\emph on 
ra
\emph default 
 was zero, or 0 if 
\emph on 
ra
\emph default 
 was nonzero.
 Other condition code flags are undefined.
\layout Standard
\line_bottom \pagebreak_top 

\family typewriter 
\series bold 
\size large 
\SpecialChar ~

\family sans 
\series default 
\size default 

\newline 

\size larger 
Floating Point Format and Merging
\layout Standard
\added_space_top medskip 

\family sans 
All floating point uops use the same encoding to specify the precision and
 vector format of the operands.
 The uop's 
\emph on 
size
\emph default 
 field is encoded as follows:
\layout Itemize


\family typewriter 
\series bold 
\size small 
00:
\family sans 
\series default 
\size default 
 Single precision scalar floating point (
\family typewriter 
\size small 
\emph on 
op
\series bold 
\emph default 
fp
\family sans 
\series default 
\size default 
 mnemonic).
 The operation is only performed on the low 32 bits (in IEEE single precision
 format) of the 64-bit inputs; the high 32 bits of the ra operand are copied
 to the high 32 bits of the output.
\layout Itemize


\family typewriter 
\series bold 
\size small 
01:
\family sans 
\series default 
\size default 
 Single precision vector floating point (
\family typewriter 
\size small 
\emph on 
op
\series bold 
\emph default 
fv
\family sans 
\series default 
\size default 
 mnemonic).
 The operation is performed on both 32 bit halves (in IEEE single precision
 format) of the 64-bit inputs in parallel
\layout Itemize


\family typewriter 
\series bold 
\size small 
1x:
\family sans 
\series default 
\size default 
 Double precision scalar floating point (
\family typewriter 
\size small 
\emph on 
op
\series bold 
\emph default 
fd
\family sans 
\series default 
\size default 
 mnemonic).
 The operation is performed on the full 64 bit inputs (in IEEE double precision
 format)
\layout Standard


\family sans 
Most floating point operations merge the result with the 
\emph on 
ra
\emph default 
 operand to prepare the destination.
 Since a full 64-bit result is generated with the vector and double formats,
 the 
\emph on 
ra
\emph default 
 operand is not needed and may be specified as zero to reduce dependencies.
\layout Standard


\family sans 
Exceptions to this encoding are listed where appropriate.
\layout Standard


\family sans 
Unless otherwise noted, all operations update the internal floating point
 status register (FPSR, equivalent to the MXCSR register in x86 code) by
 ORing in any exceptions that occur.
 If the uop is encoded to generate an actual exception on excepting conditions,
 the 
\family typewriter 
\size small 
FLAG_INV
\family sans 
\size default 
 flag is attached to the output to cause an exception at commit time.
\layout Standard


\family sans 
No condition code flags are generated by floating point uops unless otherwise
 noted.
\layout Standard
\line_bottom \pagebreak_top 

\family typewriter 
\series bold 
\size large 
addf subf mulf divf minf maxf
\family sans 
\series default 
\size default 

\newline 

\size larger 
Floating Point Arithmetic
\layout Standard


\begin_inset  Tabular
<lyxtabular version="3" rows="7" columns="3">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Mnemonic
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Syntax
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Operation
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
addf
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = ra 
\begin_inset Formula $\leftarrow$
\end_inset 

 ra + rb
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
subf
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = ra 
\begin_inset Formula $\leftarrow$
\end_inset 

 ra - rb
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
mulf
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = ra 
\begin_inset Formula $\leftarrow$
\end_inset 

 ra 
\begin_inset Formula $\times$
\end_inset 

 rb
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
divf
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = ra 
\begin_inset Formula $\leftarrow$
\end_inset 

 ra / rb
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
minf
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = ra 
\begin_inset Formula $\leftarrow$
\end_inset 

 (ra < rb) ? ra : rb
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
maxf
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = ra 
\begin_inset Formula $\leftarrow$
\end_inset 

 (ra >= rb) ? ra : rb
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Standard
\added_space_top medskip 

\family sans 
\series bold 
Notes:
\layout Itemize


\family sans 
These uops do arithmetic on floating point numbers in various formats as
 specified in the 
\emph on 
Floating Point Format and Merging
\emph default 
 page.
\layout Standard
\line_bottom \pagebreak_top 

\family typewriter 
\series bold 
\size large 
maddf msubf
\family sans 
\series default 
\size default 

\newline 

\size larger 
Fused Multiply Add and Subtract
\layout Standard


\begin_inset  Tabular
<lyxtabular version="3" rows="3" columns="3">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Mnemonic
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Syntax
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Operation
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
maddf
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb,rc
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = ra 
\begin_inset Formula $\leftarrow$
\end_inset 

 (ra 
\begin_inset Formula $\times$
\end_inset 

 rb) + rc
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
msubf
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb,rc
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = ra 
\begin_inset Formula $\leftarrow$
\end_inset 

 (ra 
\begin_inset Formula $\times$
\end_inset 

 rb) - rc
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Standard
\added_space_top medskip 

\family sans 
\series bold 
Notes:
\layout Itemize


\family sans 
The 
\family typewriter 
\size small 
maddf
\family sans 
\size default 
 and 
\family typewriter 
\size small 
msubf
\family sans 
\size default 
 uops perform fused multiply and accumulate operations on three operands.
\layout Itemize


\family sans 
The full internal precision is preserved between the multiply and add operations
; rounding only occurs at the end.
\layout Itemize


\family sans 
These uops are primarily used by microcode to calculate floating point division,
 square root and reciprocal.
\layout Standard
\line_bottom \pagebreak_top 

\family typewriter 
\series bold 
\size large 
sqrtf rcpf rsqrtf
\family sans 
\series default 
\size default 

\newline 

\size larger 
Square Root, Reciprocal and Reciprocal Square Root
\layout Standard


\begin_inset  Tabular
<lyxtabular version="3" rows="4" columns="3">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Mnemonic
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Syntax
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Operation
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
sqrtf
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = ra 
\begin_inset Formula $\leftarrow$
\end_inset 

 sqrt(rb)
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
rcpf
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = ra 
\begin_inset Formula $\leftarrow$
\end_inset 

 1 / rb
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
rsqrtf
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = ra 
\begin_inset Formula $\leftarrow$
\end_inset 

 1 / sqrt(rb)
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Standard
\added_space_top medskip 

\family sans 
\series bold 
Notes:
\layout Itemize


\family sans 
These uops perform the specified unary operation on rb and merge the result
 into ra (for a single precision scalar mode only)
\layout Itemize


\family sans 
The 
\family typewriter 
\size small 
rcpf
\family sans 
\size default 
 and 
\family typewriter 
\size small 
rsqrtf
\family sans 
\size default 
 uops are approximates - they do not provide the full precision results.
 These approximations are in accordance with the standard x86 SSE/SSE2 semantics.
\layout Standard
\line_bottom \pagebreak_top 

\family typewriter 
\series bold 
\size large 
cmpf
\family sans 
\series default 
\size default 

\newline 

\size larger 
Compare Floating Point
\layout Standard


\begin_inset  Tabular
<lyxtabular version="3" rows="2" columns="3">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Mnemonic
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Syntax
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Operation
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
cmpf
\emph on 
.type
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = ra 
\begin_inset Formula $\leftarrow$
\end_inset 

 CompareFP(ra, rb, type) ? -1 : 0
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Standard
\added_space_top medskip 

\family sans 
\series bold 
Notes:
\layout Itemize


\family sans 
This uop performs the specified comparison of 
\emph on 
ra
\emph default 
 and 
\emph on 
rb
\emph default 
.
 If the comparison is true, the result is set to all '1' bits; otherwise
 it is zero.
 The result is then merged into ra.
\layout Itemize


\family sans 
The 
\emph on 
cond
\emph default 
 field in the uop encoding holds the comparison type.
 The set of compare types matches the x86 SSE/SSE2 CMPxx instructions.
\layout Standard
\line_bottom \pagebreak_top 

\family typewriter 
\series bold 
\size large 
cmpccf
\family sans 
\series default 
\size default 

\newline 

\size larger 
Compare Floating Point and Generate Condition Codes
\layout Standard


\begin_inset  Tabular
<lyxtabular version="3" rows="2" columns="3">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Mnemonic
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Syntax
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Operation
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
cmpccf
\emph on 
.type
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd.flags = CompareFPFlags(ra, rb)
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Standard
\added_space_top medskip 

\family sans 
\series bold 
Notes:
\layout Itemize


\family sans 
This uop performs all comparisons of 
\emph on 
ra
\emph default 
 and 
\emph on 
rb
\emph default 
 and produces x86 condition code flags (ZF, PF, CF) to represent the result.
\layout Itemize


\family sans 
The semantics of the generated condition code flags exactly matches the
 x86 SSE/SSE2 instructions 
\family typewriter 
\size small 
COMISS
\family sans 
\size default 
/
\family typewriter 
\size small 
COMISD
\family sans 
\size default 
/
\family typewriter 
\size small 
UCOMISS
\family sans 
\size default 
/
\family typewriter 
\size small 
UCOMISD
\family sans 
\size default 
.
\layout Itemize


\family sans 
Unlike most encodings, the 
\emph on 
size
\emph default 
 field holds the comparison type of the two values as follows:
\begin_deeper 
\layout Itemize


\family typewriter 
\series bold 
\size small 
00:
\family sans 
\series default 
\size default 
 
\family typewriter 
\size small 
cmpccfp
\family sans 
\size default 
: single precision ordered compare (same semantics as x86 SSE 
\family typewriter 
\size small 
COMISS
\family sans 
\size default 
)
\layout Itemize


\family typewriter 
\series bold 
\size small 
01:
\family sans 
\series default 
\size default 
 
\family typewriter 
\size small 
cmpccfp.u
\family sans 
\size default 
: single precision unordered compare (same semantics as x86 SSE 
\family typewriter 
\size small 
UCOMISS
\family sans 
\size default 
)
\layout Itemize


\family typewriter 
\series bold 
\size small 
10:
\family sans 
\series default 
\size default 
 
\family typewriter 
\size small 
cmpccfd
\family sans 
\size default 
: double precision ordered compare (same semantics as x86 SSE2 
\family typewriter 
\size small 
COMISD
\family sans 
\size default 
)
\layout Itemize


\family typewriter 
\series bold 
\size small 
11:
\family sans 
\series default 
\size default 
 
\family typewriter 
\size small 
cmpccfd.u
\family sans 
\size default 
: double precision ordered compare (same semantics as x86 SSE2 
\family typewriter 
\size small 
UCOMISD
\family sans 
\size default 
)
\end_deeper 
\layout Standard
\line_bottom \pagebreak_top 

\family typewriter 
\series bold 
\size large 
cvtf.i2s.ins cvtf.i2s.p cvtf.i2d.lo cvtf.i2d.hi
\family sans 
\series default 
\size default 

\newline 

\size larger 
Convert 32-bit Integer to Floating Point
\layout Standard


\begin_inset  Tabular
<lyxtabular version="3" rows="5" columns="4">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="block" valignment="top" width="50col%">
<column alignment="block" valignment="top" width="10col%">
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Mnemonic
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Syntax
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Operation
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Used By
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
cvtf.i2s.ins
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = ra 
\begin_inset Formula $\leftarrow$
\end_inset 

 Int32ToFloat(rb)
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
CVTSI2SS
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
cvtf.i2s.p
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = zero,rb
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd[31:0] = Int32ToFloat(rb[31:0])
\newline 
rd[63:32] = Int32ToFloat(rb[63:32])
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
CVTPI2PS
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
cvtf.i2d.lo
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = zero,rb
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = Int32ToDouble(rb[31:0])
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
CVTSI2SD
\newline 
CVTPI2PD
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
cvtf.i2d.hi
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = zero,rb
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = Int32ToDouble(rb[63:32])
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
CVTPI2PD
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Standard
\added_space_top medskip 

\family sans 
\series bold 
Notes:
\layout Itemize


\family sans 
These uops convert 32-bit integers to single or double precision floating
 point
\layout Itemize


\family sans 
The semantics of these instructions are identical to the semantics of the
 x86 SSE/SSE2 instructions shown in the table
\layout Itemize


\family sans 
The uop 
\emph on 
size
\emph default 
 field is not used by these uops
\layout Standard
\line_bottom \pagebreak_top 

\family typewriter 
\series bold 
\size large 
cvtf.q2s.ins cvtf.q2d
\family sans 
\series default 
\size default 

\newline 

\size larger 
Convert 64-bit Integer to Floating Point
\layout Standard


\begin_inset  Tabular
<lyxtabular version="3" rows="3" columns="4">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="block" valignment="top" width="50col%">
<column alignment="block" valignment="top" width="10col%">
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Mnemonic
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Syntax
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Operation
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Used By
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
cvtf.q2s.ins
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = ra 
\begin_inset Formula $\leftarrow$
\end_inset 

 Int64ToFloat(rb)
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
CVTSI2SS
\family sans 
\size default 

\newline 
(x86-64)
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
cvtf.q2d
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = Int64ToDouble(ra)
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
CVTPI2PS
\newline 

\family sans 
\size default 
(x86-64)
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Standard
\added_space_top medskip 

\family sans 
\series bold 
Notes:
\layout Itemize


\family sans 
These uops convert 64-bit integers to single or double precision floating
 point
\layout Itemize


\family sans 
The semantics of these instructions are identical to the semantics of the
 x86 SSE/SSE2 instructions shown in the table
\layout Itemize


\family sans 
The uop 
\emph on 
size
\emph default 
 field is not used by these uops
\layout Standard
\line_bottom \pagebreak_top 

\family typewriter 
\series bold 
\size large 
cvtf.s2i cvt.s2q cvtf.s2i.p
\family sans 
\series default 
\size default 

\newline 

\size larger 
Convert Single Precision Floating Point to Integer
\layout Standard


\begin_inset  Tabular
<lyxtabular version="3" rows="4" columns="4">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="block" valignment="top" width="50col%">
<column alignment="block" valignment="top" width="10col%">
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Mnemonic
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Syntax
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Operation
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Used By
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
cvtf.s2i
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = FloatToInt32(ra[31:0])
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
CVTSS2SI
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
cvtf.s2i.p
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd[31:0] = FloatToInt32(ra[31:0])
\newline 
rd[63:32] = FloatToInt32(ra[63:32])
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
CVTPS2PI
\newline 
CVTPS2DQ
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
cvtf.s2q
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = FloatToInt64(ra)
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
CVTSS2SI
\family default 
\size default 

\newline 

\family sans 
(x86-64)
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Standard
\added_space_top medskip 

\family sans 
\series bold 
Notes:
\layout Itemize


\family sans 
These uops convert single precision floating point values to 32-bit or 64-bit
 integers
\layout Itemize


\family sans 
The semantics of these instructions are identical to the semantics of the
 x86 SSE/SSE2 instructions shown in the table
\layout Itemize


\family sans 
Unlike most encodings, the 
\emph on 
size
\emph default 
 field holds the rounding type of the result as follows:
\begin_deeper 
\layout Itemize


\family typewriter 
\series bold 
\size small 
x0:
\family sans 
\series default 
\size default 
 normal IEEE rounding (as determined by FPSR)
\layout Itemize


\family typewriter 
\series bold 
\size small 
x1:
\family sans 
\series default 
\size default 
 truncate to zero
\end_deeper 
\layout Standard
\line_bottom \pagebreak_top 

\family typewriter 
\series bold 
\size large 
cvtf.d2i cvtf.d2q cvtf.d2i.p
\family sans 
\series default 
\size default 

\newline 

\size larger 
Convert Double Precision Floating Point to Integer
\layout Standard


\begin_inset  Tabular
<lyxtabular version="3" rows="4" columns="4">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="block" valignment="top" width="50col%">
<column alignment="block" valignment="top" width="10col%">
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Mnemonic
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Syntax
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Operation
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Used By
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
cvtf.d2i
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = DoubleToInt32(ra)
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
CVTSD2SI
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
cvtf.d2i.p
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd[63:32] = DoubleToInt32(ra)
\newline 
rd[31:0] = DoubleToInt32(rb)
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
CVTPD2PI
\newline 
CVTPD2DQ
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
cvtf.d2q
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = DoubleToInt64(ra)
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
CVTSD2SI
\family default 
\size default 

\newline 

\family sans 
(x86-64)
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Standard
\added_space_top medskip 

\family sans 
\series bold 
Notes:
\layout Itemize


\family sans 
These uops convert double precision floating point values to 32-bit or 64-bit
 integers
\layout Itemize


\family sans 
The semantics of these instructions are identical to the semantics of the
 x86 SSE/SSE2 instructions shown in the table
\layout Itemize


\family sans 
Unlike most encodings, the 
\emph on 
size
\emph default 
 field holds the rounding type of the result as follows:
\begin_deeper 
\layout Itemize


\family typewriter 
\series bold 
\size small 
x0:
\family sans 
\series default 
\size default 
 normal IEEE rounding (as determined by FPSR)
\layout Itemize


\family typewriter 
\series bold 
\size small 
x1:
\family sans 
\series default 
\size default 
 truncate to zero
\end_deeper 
\layout Standard
\line_bottom \pagebreak_top 

\family typewriter 
\series bold 
\size large 
cvtf.d2s.ins cvtf.d2s.p cvtf.s2d.lo cvtf.s2d.hi
\family sans 
\series default 
\size default 

\newline 

\size larger 
Convert Between Double Precision and Single Precision Floating Point
\layout Standard


\begin_inset  Tabular
<lyxtabular version="3" rows="5" columns="4">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="block" valignment="top" width="50col%">
<column alignment="block" valignment="top" width="10col%">
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Mnemonic
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Syntax
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Operation
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Used By
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
cvtf.d2s.ins
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = ra 
\begin_inset Formula $\leftarrow$
\end_inset 

 DoubleToFloat(rb)
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
CVTSD2SS
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
cvtf.d2s.p
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = ra,rb
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd[63:32] = DoubleToFloat(ra)
\newline 
rd[31:0] = DoubleToFloat(rb)
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
CVTPD2PS
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
cvtf.s2d.lo
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = zero,rb
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = FloatToDouble(rb[31:0])
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
CVTSS2SD
\newline 
CVTPS2PD
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\series bold 
\size small 
cvtf.s2d.hi
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
rd = zero,rb
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
rd = FloatToDouble(rb[63:32])
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family typewriter 
\size small 
CVTPS2PD
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Standard
\added_space_top medskip 

\family sans 
\series bold 
Notes:
\layout Itemize


\family sans 
These uops convert single precision floating point values to double precision
 floating point values
\layout Itemize


\family sans 
The semantics of these instructions are identical to the semantics of the
 x86 SSE/SSE2 instructions shown in the table
\layout Itemize


\family sans 
The uop 
\emph on 
size
\emph default 
 field is not used by these uops
\layout Chapter


\begin_inset LatexCommand \label{sec:PerformanceCounters}

\end_inset 

Performance Counters
\layout Standard

PTLsim maintains hundreds of performance and statistical counters and data
 points as it simulates user code.
 In Section 
\begin_inset LatexCommand \ref{sec:StatisticsInfrastructure}

\end_inset 

, the basic mechanisms and data structures through which PTLsim collects
 these data were disclosed, and a guide to extending the existing set of
 collection points was presented.
\layout Standard

This section is a reference listing of all the current performance counters
 present in PTLsim by default.
 The sections below are arranged in a hierarchical tree format, just as
 the data are represented in PTLsim's data store.
\layout Section

General
\layout Standard

As described in Section 
\begin_inset LatexCommand \ref{sec:StatisticsInfrastructure}

\end_inset 

, PTLsim maintains a hierarchical tree of statistical data.
 At the root of the tree are a potentially large number of snapshots, numbered
 starting at 0.
 The final snapshot, taken just before simulation completes, is labeled
 as 
\begin_inset Quotes eld
\end_inset 

final
\begin_inset Quotes erd
\end_inset 

.
 Each snapshot branch contains all of the data structures described in the
 next few sections.
 Snapshots are enabled with the 
\family typewriter 
\size small 
-snapshot
\family default 
\size default 
 configuration option (Section 
\begin_inset LatexCommand \ref{sec:ConfigurationOptions}

\end_inset 

); if they are disabled, only the 
\begin_inset Quotes eld
\end_inset 

0
\begin_inset Quotes erd
\end_inset 

 and 
\begin_inset Quotes eld
\end_inset 

final
\begin_inset Quotes erd
\end_inset 

 snapshots are provided.
\layout Standard

In addition to the snapshots, the root of the data tree contains a 
\begin_inset Quotes eld
\end_inset 

ptlsim
\begin_inset Quotes erd
\end_inset 

 node with the following miscellaneous information:
\layout Standard


\family sans 
\series bold 
ptlsim:
\family default 
\series default 
 metadata about the PTLsim build and host system it is running on
\layout Itemize


\family sans 
\series bold 
executable:
\family default 
\series default 
 the full path of the program being simulated
\layout Itemize


\family sans 
\series bold 
args:
\family default 
\series default 
 arguments to the program being simulated
\layout Itemize


\family sans 
\series bold 
hw-ver:
\family default 
\series default 
 simulated core hardware version
\layout Itemize


\family sans 
\series bold 
ptl-ver:
\family default 
\series default 
 microcode version
\layout Itemize


\family sans 
\series bold 
build-hostname:
\family default 
\series default 
 the machine on which PTLsim was compiled
\layout Itemize


\family sans 
\series bold 
build-timestamp:
\family default 
\series default 
 the date on which PTLsim was compiled (this is set whenever 
\family typewriter 
\size small 
config.o
\family default 
\size default 
 is compiled)
\layout Itemize


\family sans 
\series bold 
build-compiler-version:
\family default 
\series default 
 gcc version used to build PTLsim
\layout Itemize


\family sans 
\series bold 
hostname:
\family default 
\series default 
 the host machine PTLsim is running on
\layout Itemize


\family sans 
\series bold 
native-mhz:
\family default 
\series default 
 the clock speed of the host microprocessor running PTLsim (this is obtained
 in accordance with Section 
\begin_inset LatexCommand \ref{sec:Timing}

\end_inset 

)
\layout Section

Out of Order Core
\layout Standard


\family sans 
\series bold 
summary:
\family default 
\series default 
 summarizes the performance of user code running on the simulator
\layout Itemize


\family sans 
\series bold 
cycles:
\family default 
\series default 
 total number of processor cycles simulated
\layout Itemize


\family sans 
\series bold 
commits:
\family default 
\series default 
 total number of committed uops
\layout Itemize


\family sans 
\series bold 
usercommits:
\family default 
\series default 
 total number of committed x86 instructions
\layout Itemize


\family sans 
\series bold 
issues:
\family default 
\series default 
 total number of uops issued.
 This includes uops issued more than once by through replay (Section 
\begin_inset LatexCommand \ref{sec:Scheduling}

\end_inset 

).
\layout Itemize


\family sans 
\series bold 
ipc:
\family default 
\series default 
 Instructions Per Cycle (IPC) statistics
\begin_deeper 
\layout Itemize


\family sans 
\series bold 
commit-in-uops:
\family default 
\series default 
 average number of uops committed per cycle
\layout Itemize


\family sans 
\series bold 
issue-in-uops:
\family default 
\series default 
 average number of uops issued per cycle
\layout Itemize


\family sans 
\series bold 
commit-in-user-insns:
\family default 
\series default 
 average number of x86 instructions committed per cycle
\newline 

\series bold 
\emph on 

\newline 
NOTE:
\series default 
\emph default 
 Because one x86 instruction may be broken up into numerous uops, it is
 
\series bold 
\emph on 
\bar under 
never
\series default 
\emph default 
\bar default 
 appropriate to compare IPC figures for committed x86 instructions per clock
 with IPC values from a RISC machine.
 Furthermore, different x86 implementations use varying numbers of uops
 per x86 instruction as a matter of encoding, so even comparing the uop
 based IPC between x86 implementations or RISC-like machines is inaccurate.
 Users are strongly advised to use relative performance measures instead
 (e.g.
 total cycles taken to complete a given benchmark).
\end_deeper 
\layout Standard


\family sans 
\series bold 
simulator:
\family default 
\series default 
 describes the performance of PTLsim itself.
 Useful for tuning the simulator.
\layout Itemize


\family sans 
\series bold 
cycles:
\family default 
\series default 
 total time in seconds 
\emph on 
(not simulated cycles!)
\emph default 
 spent in various parts of the simulator.
 Please refer to the source code (in 
\emph on 
ooocore.cpp
\emph default 
) for the range of code each time value corresponds to.
\layout Itemize


\family sans 
\series bold 
rate:
\family default 
\series default 
 PTLsim simulator performance
\begin_deeper 
\layout Itemize


\family sans 
\series bold 
total-secs:
\family default 
\series default 
 total seconds spent in simulation mode (native mode does not count towards
 this total)
\layout Itemize


\family sans 
\series bold 
cycles-per-sec:
\family default 
\series default 
 average number of processor cycles simulated per second
\layout Itemize


\family sans 
\series bold 
issues-per-sec:
\family default 
\series default 
 average number of uops issued in the simulator per second
\layout Itemize


\family sans 
\series bold 
commits-per-sec:
\family default 
\series default 
 average number of uops committed in the simulator per second
\layout Itemize


\family sans 
\series bold 
user-commits-per-sec:
\family default 
\series default 
 average number of x86 instructions committed in the simulator per second
\end_deeper 
\layout Itemize


\family sans 
\series bold 
bbcache:
\family default 
\series default 
 Decoded basic block cache performance
\begin_deeper 
\layout Itemize


\family sans 
\series bold 
count:
\family default 
\series default 
 total basic blocks encountered in the user code
\layout Itemize


\family sans 
\series bold 
inserts:
\family default 
\series default 
 insertions into the basic block cache
\layout Itemize


\family sans 
\series bold 
removes:
\family default 
\series default 
 removals from the basic block cache (e.g.
 when a block must be re-translated after unaligned loads and stores are
 found, etc.)
\end_deeper 
\layout Standard


\family sans 
\series bold 
fetch:
\family default 
\series default 
 fetch stage statistics
\layout Itemize


\family sans 
\series bold 
width:
\family default 
\series default 
 histogram of the fetch width actually used on each cycle
\layout Itemize


\family sans 
\series bold 
stop:
\family default 
\series default 
 totals up the reasons why fetching finally stopped in each cycle
\begin_deeper 
\layout Itemize


\family sans 
\series bold 
icache-miss:
\family default 
\series default 
 an instruction cache miss prevented further fetches
\layout Itemize


\family sans 
\series bold 
fetchq-full:
\family default 
\series default 
 the uop fetch queue is full
\layout Itemize


\family sans 
\series bold 
bogus-rip:
\family default 
\series default 
 speculative execution redirected the fetch unit to an inaccessible (or
 non-executable) page.
 The fetch unit remains stalled in this state until the mis-speculation
 is resolved.
\layout Itemize


\family sans 
\series bold 
branch-taken:
\family default 
\series default 
 taken branches to non-sequential addresses always stop fetching
\layout Itemize


\family sans 
\series bold 
full-width:
\family default 
\series default 
 the maximum fetch width was utilized without encountering any of the events
 above
\end_deeper 
\layout Itemize


\family sans 
\series bold 
blocks:
\family default 
\series default 
 blocks of x86 instructions fetched (typically the processor can read at
 most e.g.
 16 bytes out of a 64 byte instruction cache line per cycle)
\layout Itemize


\family sans 
\series bold 
uops:
\family default 
\series default 
 total number of uops fetched
\layout Itemize


\family sans 
\series bold 
user-insns:
\family default 
\series default 
 total number of x86 instructions fetched
\layout Itemize


\family sans 
\series bold 
opclass:
\family default 
\series default 
 histogram of how many uops of various operation classes passed through
 the fetch unit.
 The operation classes are defined in 
\family typewriter 
\size small 
ptlhwdef.h
\family default 
\size default 
 and assigned to various opcodes in 
\family typewriter 
\size small 
ptlhwdef.cpp
\family default 
\size default 
.
\layout Standard


\family sans 
\series bold 
frontend:
\family default 
\series default 
 frontend pipeline (decode, allocate, rename) statistics
\layout Itemize


\family sans 
\series bold 
width:
\family default 
\series default 
 histogram of the frontend width actually used on each cycle
\layout Itemize


\family sans 
\series bold 
status:
\family default 
\series default 
 totals up the reasons why frontend processing finally stopped in each cycle
\begin_deeper 
\layout Itemize


\family sans 
\series bold 
complete:
\family default 
\series default 
 all uops were successfully allocated and renamed
\layout Itemize


\family sans 
\series bold 
fetchq-empty:
\family default 
\series default 
 no more uops were available for allocation
\layout Itemize


\family sans 
\series bold 
rob-full:
\family default 
\series default 
 reorder buffer (ROB) was full
\layout Itemize


\family sans 
\series bold 
physregs-full:
\family default 
\series default 
 physical register file was full even though an ROB slot was free
\layout Itemize


\family sans 
\series bold 
ldq-full:
\family default 
\series default 
 load queue was full (too many loads in the pipeline) even though physical
 registers were available
\layout Itemize


\family sans 
\series bold 
stq-full:
\family default 
\series default 
 store queue was full (too many stores in the pipeline)
\end_deeper 
\layout Itemize


\family sans 
\series bold 
renamed:
\family default 
\series default 
 summarizes the type of renaming that occurred for each uop (of the destination,
 not the operands)
\begin_deeper 
\layout Itemize


\family sans 
\series bold 
none:
\family default 
\series default 
 uop did not rename its destination (primarily for stores and branches)
\layout Itemize


\family sans 
\series bold 
reg:
\family default 
\series default 
 uop renamed destination architectural register
\layout Itemize


\family sans 
\series bold 
flags:
\family default 
\series default 
 uop renamed one or more of the ZAPS, CF, OF flag sets but had no destination
 architectural register
\layout Itemize


\family sans 
\series bold 
reg-and-flags:
\family default 
\series default 
 uop renamed one or more of the ZAPS, CF, OF flag sets as well as a destination
 architectural register
\end_deeper 
\layout Itemize


\family sans 
\series bold 
alloc:
\family default 
\series default 
 summarizes the type of resource allocation that occurred for each uop (in
 addition to its ROB slot):
\begin_deeper 
\layout Itemize


\family sans 
\series bold 
reg:
\family default 
\series default 
 uop was allocated a physical register
\layout Itemize


\family sans 
\series bold 
ldreg:
\family default 
\series default 
 uop was a load and was allocated both a physical register and a load queue
 entry
\layout Itemize


\family sans 
\series bold 
sfr:
\family default 
\series default 
 uop was a store and was allocated a store forwarding register (SFR), a.k.a.
 store queue entry
\layout Itemize


\family sans 
\series bold 
br:
\family default 
\series default 
 uop was a branch and was allocated branch-related resources (possibly including
 a destination physical register)
\end_deeper 
\layout Standard


\family sans 
\series bold 
dispatch:
\family default 
\series default 
 dispatch unit statistics
\layout Itemize


\family sans 
\series bold 
source:
\family default 
\series default 
 totals up where each operand to each uop currently resided at the time
 the uop was dispatched
\begin_deeper 
\layout Itemize


\family sans 
\series bold 
waiting:
\family default 
\series default 
 how many operands were waiting (i.e.
 not yet ready)
\layout Itemize


\family sans 
\series bold 
bypass:
\family default 
\series default 
 how many operands would come from the bypass network if the uop were immediatel
y issued
\layout Itemize


\family sans 
\series bold 
physreg:
\family default 
\series default 
 how many operands were already written back to physical registers
\layout Itemize


\family sans 
\series bold 
archreg:
\family default 
\series default 
 how many operands would be obtained from architectural registers
\end_deeper 
\layout Itemize


\family sans 
\series bold 
cluster:
\family default 
\series default 
 tracks the number of uops issued to each cluster (or issue queue) in the
 processor.
 This list will vary depending on the processor configuration.
 The value 
\emph on 
none
\emph default 
 means that no cluster could accept the uop because all issue queues were
 full.
\layout Itemize


\family sans 
\series bold 
redispatch:
\family default 
\series default 
 statistics on the redispatch speculation recovery rmechanism (Section 
\begin_inset LatexCommand \ref{sec:SpeculationRecovery}

\end_inset 

)
\begin_deeper 
\layout Itemize


\family sans 
\series bold 
deadlock-flushes
\family default 
\series default 
 measures how many times the pipeline must be flushed to resolve a deadlock.
\layout Itemize


\family sans 
\series bold 
trigger-uops
\family default 
\series default 
 measures how many uops triggered redispatching because of a mis-speculation.
 This number does not count towards the statistics below.
\layout Itemize


\family sans 
\series bold 
dependent-uops
\family default 
\series default 
 is a histogram of how many uops depended on each trigger uop, not including
 the trigger uop itself.
\end_deeper 
\layout Standard


\family sans 
\series bold 
issue:
\family default 
\series default 
 issue statistics
\layout Itemize


\family sans 
\series bold 
result:
\family default 
\series default 
 histogram of the final disposition of issuing each uop
\begin_deeper 
\layout Itemize


\family sans 
\series bold 
no-fu:
\family default 
\series default 
 no functional unit was available within the uop's assigned cluster even
 though it was already issued
\layout Itemize


\family sans 
\series bold 
replay:
\family default 
\series default 
 uop attempted to execute but could not complete, so it must remain in the
 issue queue to be replayed.
 This event generally occurs when a load or store detects a previously unknown
 forwarding dependency on a prior store, when the data to actually store
 is not yet available, or when insufficient resources are available to complete
 the memory operation.
 Details are given in Sections 
\begin_inset LatexCommand \ref{sec:IssuingLoads}

\end_inset 

 and 
\begin_inset LatexCommand \ref{sec:SplitPhaseStores}

\end_inset 

.
\layout Itemize


\family sans 
\series bold 
misspeculation:
\family default 
\series default 
 uop mis-speculated and now all uops after and including the issued uop
 must be annulled.
 This generally occurs with loads (Section 
\begin_inset LatexCommand \ref{sec:IssuingLoads}

\end_inset 

) and stores (Section 
\begin_inset LatexCommand \ref{sub:AliasCheck}

\end_inset 

) when unaligned accesses or load-store aliasing occurs.
 This event is handled in accordance with Section 
\begin_inset LatexCommand \ref{sec:SpeculationRecovery}

\end_inset 

.
\layout Itemize


\family sans 
\series bold 
branch-mispredict:
\family default 
\series default 
 uop was a branch and mispredicted, such that all uops after (but not including)
 the branch uop must be annulled.
 See Section 
\begin_inset LatexCommand \ref{sec:SpeculationAndRecovery}

\end_inset 

 for details.
\layout Itemize


\family sans 
\series bold 
exception:
\family default 
\series default 
 uop caused an exception (though this may not be a user visible error due
 to speculative execution)
\layout Itemize


\family sans 
\series bold 
complete:
\family default 
\series default 
 uop completed successfully.
 Note that this does 
\emph on 
not
\emph default 
 mean the result is immediately ready; for loads it simply means the request
 was issued to the cache.
\end_deeper 
\layout Itemize


\family sans 
\series bold 
source:
\family default 
\series default 
 totals up where each operand to each uop was read from as it was issued
\begin_deeper 
\layout Itemize


\family sans 
\series bold 
bypass:
\family default 
\series default 
 how many operands came directly off the bypass network
\layout Itemize


\family sans 
\series bold 
physreg:
\family default 
\series default 
 how many operands were read from physical registers
\layout Itemize


\family sans 
\series bold 
archreg:
\family default 
\series default 
 how many operands were read from committed architectural registers
\end_deeper 
\layout Itemize


\family sans 
\series bold 
width:
\family default 
\series default 
 histogram of the issue width actually used on each cycle in each cluster.
 This object is further broken down by cluster, since various clusters have
 different issue width and policies.
\layout Itemize


\family sans 
\series bold 
opclass:
\family default 
\series default 
 histogram of how many uops of various operation classes were issued.
 The operation classes are defined in 
\family typewriter 
\size small 
ptlhwdef.h
\family default 
\size default 
 and assigned to various opcodes in 
\family typewriter 
\size small 
ptlhwdef.cpp
\family default 
\size default 
.
\layout Standard


\family sans 
\series bold 
writeback:
\family default 
\series default 
 writeback stage statistics
\layout Itemize


\family sans 
\series bold 
total:
\family default 
\series default 
 total number of results written back to the physical register file
\layout Itemize


\family sans 
\series bold 
transient:
\family default 
\series default 
 transient versus persistent values
\begin_deeper 
\layout Itemize


\family sans 
\series bold 
transient:
\family default 
\series default 
 the result technically does not have to be written back to the physical
 register file at all, since all consumers sourced the value off the bypass
 network and the result is no longer available since the destination architectur
al register pointing to it has since been renamed.
\layout Itemize


\family sans 
\series bold 
persistent:
\family default 
\series default 
 all values which do not meet the conditions above and hence must still
 be written back
\end_deeper 
\layout Itemize


\family sans 
\series bold 
width:
\family default 
\series default 
 histogram of the writeback width actually used on each cycle in each cluster.
 This object is further broken down by cluster, since various clusters have
 different issue width and policies.
\layout Standard


\family sans 
\series bold 
commit:
\family default 
\series default 
 commit unit statistics
\layout Itemize


\family sans 
\series bold 
uops:
\family default 
\series default 
 total number of uops committed
\layout Itemize


\family sans 
\series bold 
userinsns:
\family default 
\series default 
 total number of x86 instructions committed
\layout Itemize


\family sans 
\series bold 
result:
\family default 
\series default 
 histogram of the final disposition of attempting to commit each uop
\begin_deeper 
\layout Itemize


\family sans 
\series bold 
none:
\family default 
\series default 
 one or more uops comprising the x86 instruction at the head of the ROB
 were not yet ready to commit, so commitment is terminated for that cycle
\layout Itemize


\family sans 
\series bold 
ok:
\family default 
\series default 
 result was successfully committed
\layout Itemize


\family sans 
\series bold 
exception:
\family default 
\series default 
 result caused a genuine user visible exception.
 Generally this will terminate the simulation.
\layout Itemize


\family sans 
\series bold 
skipblock:
\family default 
\series default 
 This occurs in extremely rare cases when the processor must skip over the
 currently executing instruction (such as in pathological cases of the 
\family typewriter 
\size small 
rep
\family default 
\size default 
 x86 instructions).
\layout Itemize


\family sans 
\series bold 
barrier:
\family default 
\series default 
 the processor encountered a barrier instruction, such as a system call,
 assist or pipeline flush.
 The frontend has already been stopped and fetching has been redirected
 to the code to handle the barrier; this condition simply commits the barrier
 instruction itself.
\layout Itemize


\family sans 
\series bold 
stop:
\family default 
\series default 
 special case for when the simulation is to be stopped after committing
 a certain number of x86 instructions (e.g.
 via the 
\family typewriter 
\size small 
-stopinsns
\family default 
\size default 
 option in Section 
\begin_inset LatexCommand \ref{sec:ConfigurationOptions}

\end_inset 

).
\end_deeper 
\layout Itemize


\family sans 
\series bold 
setflags:
\family default 
\series default 
 how many uops updated the condition code flags as they committed
\begin_deeper 
\layout Itemize


\family sans 
\series bold 
yes:
\family default 
\series default 
 how many uops updated at least one of the ZAPS, CF, OF flag sets (the 
\family typewriter 
\size small 
REG_flags
\family default 
\size default 
 internal architectural register)
\layout Itemize


\family sans 
\series bold 
no:
\family default 
\series default 
 how many uops did not update any flags
\end_deeper 
\layout Itemize


\family sans 
\series bold 
freereg:
\family default 
\series default 
 how many uops were able to free the old physical register mapped to their
 architectural destination register at commit time
\begin_deeper 
\layout Itemize


\family sans 
\series bold 
pending:
\family default 
\series default 
 old physical register was still referenced within the pipeline or by one
 or more rename table entries
\layout Itemize


\family sans 
\series bold 
free:
\family default 
\series default 
 old physical register could be immediately freed
\end_deeper 
\layout Itemize


\family sans 
\series bold 
physreg-recycled:
\family default 
\series default 
 how many physical registers were recycled (garbage collected) later than
 normal because of one of the conditions above
\layout Itemize


\family sans 
\series bold 
width:
\family default 
\series default 
 histogram of the issue width actually used on each cycle in each cluster.
 This object is further broken down by cluster, since various clusters have
 different issue width and policies.
\layout Itemize


\family sans 
\series bold 
opclass:
\family default 
\series default 
 histogram of how many uops of various operation classes were issued.
 The operation classes are defined in 
\family typewriter 
\size small 
ptlhwdef.h
\family default 
\size default 
 and assigned to various opcodes in 
\family typewriter 
\size small 
ptlhwdef.cpp
\family default 
\size default 
.
\layout Standard


\family sans 
\series bold 
branchpred:
\family default 
\series default 
 branch predictor statistics
\layout Itemize


\family sans 
\series bold 
predictions:
\family default 
\series default 
 total number of branch predictions of any type
\layout Itemize


\family sans 
\series bold 
updates:
\family default 
\series default 
 total number of branch predictor updates of any type
\layout Itemize


\family sans 
\series bold 
cond:
\family default 
\series default 
 conditional branch (
\family typewriter 
\size small 
br.cc
\family default 
\size default 
 uop) prediction outcomes, broken down into correct predictions and mispredictio
ns
\layout Itemize


\family sans 
\series bold 
indir:
\family default 
\series default 
 indirect branch (
\family typewriter 
\size small 
jmp
\family default 
\size default 
 uop) prediction outcomes, broken down into correct predictions and mispredictio
ns
\layout Itemize


\family sans 
\series bold 
return:
\family default 
\series default 
 return (
\family typewriter 
\size small 
jmp
\family default 
\size default 
 uop with 
\family typewriter 
\size small 
BRANCH_HINT_RET
\family default 
\size default 
 flag) prediction outcomes, broken down into correct predictions and mispredicti
ons
\layout Itemize


\family sans 
\series bold 
summary:
\family default 
\series default 
 summary of all prediction outcomes of the three types above, broken down
 into correct predictions and mispredictions
\layout Itemize


\family sans 
\series bold 
ras:
\family default 
\series default 
 return address stack (RAS) operations
\begin_deeper 
\layout Itemize


\family sans 
\series bold 
push:
\family default 
\series default 
 RAS pushes on calls
\layout Itemize


\family sans 
\series bold 
push-overflows:
\family default 
\series default 
 RAS pushes on calls in which the RAS overflowed
\layout Itemize


\family sans 
\series bold 
pop:
\family default 
\series default 
 RAS pops on returns
\layout Itemize


\family sans 
\series bold 
pop-underflows:
\family default 
\series default 
 RAS pops on returns in which the RAS was empty
\layout Itemize


\family sans 
\series bold 
annuls:
\family default 
\series default 
 annulment operations in which speculative updates to the RAS were rolled
 back
\end_deeper 
\layout Section

Cache Subsystem
\layout Standard


\family sans 
\series bold 
load:
\family default 
\series default 
 load unit statistics
\layout Itemize


\family sans 
\series bold 
result:
\family default 
\series default 
 histogram of the final disposition of issuing each load uop
\begin_deeper 
\layout Itemize


\family sans 
\series bold 
complete:
\family default 
\series default 
 cache hit
\layout Itemize


\family sans 
\series bold 
miss:
\family default 
\series default 
 L1 cache miss, and possibly lower levels as well (Sections 
\begin_inset LatexCommand \ref{sec:CacheMissHandling}

\end_inset 

 and 
\begin_inset LatexCommand \ref{sec:InitiatingCacheMiss}

\end_inset 

)
\layout Itemize


\family sans 
\series bold 
exception:
\family default 
\series default 
 load generated an exception (typically a page fault), although the exception
 may still be speculative (Section 
\begin_inset LatexCommand \ref{sec:IssuingLoads}

\end_inset 

)
\layout Itemize


\family sans 
\series bold 
ordering:
\family default 
\series default 
 load was misordered with respect to stores (Section 
\begin_inset LatexCommand \ref{sub:AliasCheck}

\end_inset 

)
\layout Itemize


\family sans 
\series bold 
unaligned:
\family default 
\series default 
 load was unaligned and will need to be re-executed as a pair of low and
 high loads (Sections 
\begin_inset LatexCommand \ref{sub:UnalignedLoadsAndStores}

\end_inset 

 and 
\begin_inset LatexCommand \ref{sec:IssuingLoads}

\end_inset 

)
\layout Itemize


\family sans 
\series bold 
replay:
\family default 
\series default 
 histogram of events in which a load needed to be replayed (Section 
\begin_inset LatexCommand \ref{sec:IssuingLoads}

\end_inset 

)
\begin_deeper 
\layout Itemize


\family sans 
\series bold 
sfr-addr-and-data-not-ready:
\family default 
\series default 
 load was predicted to forward data from a prior store (Section 
\begin_inset LatexCommand \ref{sub:AliasCheck}

\end_inset 

), but neither the address nor the data of that store has resolved yet
\layout Itemize


\family sans 
\series bold 
sfr-addr-not-ready:
\family default 
\series default 
 load was predicted to forward data from a prior store, but the address
 of that store has not resolved yet
\layout Itemize


\family sans 
\series bold 
sfr-data-not-ready:
\family default 
\series default 
 load address matched a prior store in the store queue, but the data that
 store should write has not resolved yet
\layout Itemize


\family sans 
\series bold 
missbuf-full:
\family default 
\series default 
 load missed the cache but the miss buffer and/or LFRQ (Section 
\begin_inset LatexCommand \ref{sec:InitiatingCacheMiss}

\end_inset 

) was full at the time
\end_deeper 
\end_deeper 
\layout Itemize


\family sans 
\series bold 
hit:
\family default 
\series default 
 histogram of the cache hierarchy level each load finally hit
\begin_deeper 
\layout Itemize


\family sans 
\series bold 
L1:
\family default 
\series default 
 L1 cache hit
\layout Itemize


\family sans 
\series bold 
L2:
\family default 
\series default 
 L1 cache miss, L2 cache hit
\layout Itemize


\family sans 
\series bold 
L3:
\family default 
\series default 
 L! and L2 cache miss, L3 cache hit
\layout Itemize


\family sans 
\series bold 
mem:
\family default 
\series default 
 all caches missed; value read from main memory
\end_deeper 
\layout Itemize


\family sans 
\series bold 
forward:
\family default 
\series default 
 histogram of which sources were used to fill each load
\begin_deeper 
\layout Itemize


\family sans 
\series bold 
cache:
\family default 
\series default 
 how many loads obtained all their data from the cache
\layout Itemize


\family sans 
\series bold 
sfr:
\family default 
\series default 
 how many loads obtained all their data from a prior store in the pipeline
 (i.e.
 load completely overlapped that store)
\layout Itemize


\family sans 
\series bold 
sfr-and-cache:
\family default 
\series default 
 how many loads obtained their data from a combination of the cache and
 a prior store
\end_deeper 
\layout Itemize


\family sans 
\series bold 
dependency:
\family default 
\series default 
 histogram of how loads related to previous stores
\begin_deeper 
\layout Itemize


\family sans 
\series bold 
independent:
\family default 
\series default 
 load was independent of any store currently in the pipeline
\layout Itemize


\family sans 
\series bold 
predicted-alias-unresolved:
\family default 
\series default 
 load was stalled because the load store alias predictor (LSAP) predicted
 that an earlier store would overlap the load's address address even though
 that earlier store's address was unresolved (Section 
\begin_inset LatexCommand \ref{sub:AliasCheck}

\end_inset 

)
\layout Itemize


\family sans 
\series bold 
stq-address-match:
\family default 
\series default 
 load depended on an earlier store still found in the store queue
\end_deeper 
\layout Itemize


\family sans 
\series bold 
type:
\family default 
\series default 
 histogram of the type of each load uop
\begin_deeper 
\layout Itemize


\family sans 
\series bold 
aligned:
\family default 
\series default 
 normal aligned loads
\layout Itemize


\family sans 
\series bold 
unaligned:
\family default 
\series default 
 special unaligned load uops 
\family typewriter 
\size small 
ld.lo
\family default 
\size default 
 or 
\family typewriter 
\size small 
ld.hi
\family default 
\size default 
 (Section 
\begin_inset LatexCommand \ref{sub:UnalignedLoadsAndStores}

\end_inset 

)
\layout Itemize


\family sans 
\series bold 
internal:
\family default 
\series default 
 loads from PTLsim space by microcode
\end_deeper 
\layout Itemize


\family sans 
\series bold 
size:
\family default 
\series default 
 histogram of the size in bytes of each load uop
\layout Itemize


\family sans 
\series bold 
transfer-L2-to-L1:
\family default 
\series default 
 histogram of the types of L2 to L1 line transfers that occurred (Section
 
\begin_inset LatexCommand \ref{sec:CacheHierarchy}

\end_inset 

)
\begin_deeper 
\layout Itemize


\family sans 
\series bold 
full-L2-to-L1:
\family default 
\series default 
 all bytes in cache line were transferred from L2 to L1 cache
\layout Itemize


\family sans 
\series bold 
partial-L2-to-L1:
\family default 
\series default 
 some bytes in the L1 line were already valid (because of stores to those
 bytes), but the remaining bytes still need to be fetched
\layout Itemize


\family sans 
\series bold 
L2-to-L1I:
\family default 
\series default 
 all bytes in the L2 line were transferred into the L1 instruction cache
\end_deeper 
\layout Itemize


\family sans 
\series bold 
dtlb:
\family default 
\series default 
 data cache translation lookaside buffer hit versus miss rate (Section 
\begin_inset LatexCommand \ref{sec:TranslationLookasideBuffers}

\end_inset 

)
\layout Standard


\family sans 
\series bold 
fetch:
\family default 
\series default 
 instruction fetch unit statistics (Section 
\begin_inset LatexCommand \ref{sec:FetchStage}

\end_inset 

)
\layout Itemize


\family sans 
\series bold 
hit:
\family default 
\series default 
 histogram of the cache hierarchy level each fetch finally hit
\begin_deeper 
\layout Itemize


\family sans 
\series bold 
L1:
\family default 
\series default 
 L1 cache hit
\layout Itemize


\family sans 
\series bold 
L2:
\family default 
\series default 
 L1 cache miss, L2 cache hit
\layout Itemize


\family sans 
\series bold 
L3:
\family default 
\series default 
 L! and L2 cache miss, L3 cache hit
\layout Itemize


\family sans 
\series bold 
mem:
\family default 
\series default 
 all caches missed; value read from main memory
\end_deeper 
\layout Itemize


\family sans 
\series bold 
itlb:
\family default 
\series default 
 instruction cache translation lookaside buffer hit versus miss rate (Section
 
\begin_inset LatexCommand \ref{sec:TranslationLookasideBuffers}

\end_inset 

)
\layout Standard


\family sans 
\series bold 
prefetches:
\family default 
\series default 
 prefetch engine statistics
\layout Itemize


\family sans 
\series bold 
in-L1:
\family default 
\series default 
 requested data already in L1 cache
\layout Itemize


\family sans 
\series bold 
in-L2:
\family default 
\series default 
 requested data already in L2 cache (and possibly also in L1 cache)
\layout Itemize


\family sans 
\series bold 
required:
\family default 
\series default 
 prefetch was actually required (data was not cached or was in L3 or lower
 levels)
\layout Standard


\family sans 
\series bold 
missbuf:
\family default 
\series default 
 miss buffer performance (Sections 
\begin_inset LatexCommand \ref{sec:InitiatingCacheMiss}

\end_inset 

 and 
\begin_inset LatexCommand \ref{sec:FillingCacheMiss}

\end_inset 

)
\layout Itemize


\family sans 
\series bold 
inserts:
\family default 
\series default 
 total number of lines inserted into the miss buffer
\layout Itemize


\family sans 
\series bold 
delivers:
\family default 
\series default 
 total number of lines delivered to various cache hierarchy levels from
 the miss buffer
\begin_deeper 
\layout Itemize


\family sans 
\series bold 
mem-to-L3:
\family default 
\series default 
 deliver line from main memory to the L3 cache
\layout Itemize


\family sans 
\series bold 
L3-to-L2:
\family default 
\series default 
 deliver line to the L3 cache to the L2 cache
\layout Itemize


\family sans 
\series bold 
L2-to-L1D:
\family default 
\series default 
 deliver line from the L2 cache to the L1 data cache
\layout Itemize


\family sans 
\series bold 
L2-to-L1I:
\family default 
\series default 
 deliver line from the L2 cache to the L1 instruction cache
\end_deeper 
\layout Standard


\family sans 
\series bold 
lfrq:
\family default 
\series default 
 load fill request queue (LFRQ) performance (Sections 
\begin_inset LatexCommand \ref{sec:InitiatingCacheMiss}

\end_inset 

 and 
\begin_inset LatexCommand \ref{sec:FillingCacheMiss}

\end_inset 

)
\layout Itemize


\family sans 
\series bold 
inserts:
\family default 
\series default 
 total number of loads inserted into the LFRQ
\layout Itemize


\family sans 
\series bold 
wakeups:
\family default 
\series default 
 total number of loads awakened from the LFRQ
\layout Itemize


\family sans 
\series bold 
annuls:
\family default 
\series default 
 total number of loads annulled in the LFRQ (after they were annulled in
 the processor core)
\layout Itemize


\family sans 
\series bold 
resets:
\family default 
\series default 
 total number of LFRQ resets (all entries cleared)
\layout Itemize


\family sans 
\series bold 
total-latency:
\family default 
\series default 
 total latency in cycles of all loads passing through the LFRQ
\layout Itemize


\family sans 
\series bold 
average-miss-latency:
\family default 
\series default 
 average load latency, weighted by cache level hit and latency to that level
\layout Itemize


\family sans 
\series bold 
width:
\family default 
\series default 
 histogram of how many loads were awakened per cycle by the LFRQ
\layout Standard


\family sans 
\series bold 
store:
\family default 
\series default 
 store unit statistics
\layout Itemize


\family sans 
\series bold 
issue:
\family default 
\series default 
 histogram of the final disposition of issuing each store uop
\begin_deeper 
\layout Itemize


\family sans 
\series bold 
complete:
\family default 
\series default 
 store completed without problems
\layout Itemize


\family sans 
\series bold 
exception:
\family default 
\series default 
 store generated an exception (typically a page fault), although the exception
 may still be speculative (Section 
\begin_inset LatexCommand \ref{sec:StoreMerging}

\end_inset 

)
\layout Itemize


\family sans 
\series bold 
ordering:
\family default 
\series default 
 store detected that a later load in program order aliased the store but
 was issued earlier than the store (Section 
\begin_inset LatexCommand \ref{sub:AliasCheck}

\end_inset 

)
\layout Itemize


\family sans 
\series bold 
unaligned:
\family default 
\series default 
 store was unaligned and will need to be re-executed as a pair of low and
 high stores (Sections 
\begin_inset LatexCommand \ref{sub:UnalignedLoadsAndStores}

\end_inset 

)
\layout Itemize


\family sans 
\series bold 
replay:
\family default 
\series default 
 histogram of events in which a store needed to be replayed (Sections 
\begin_inset LatexCommand \ref{sec:SplitPhaseStores}

\end_inset 

 and 
\begin_inset LatexCommand \ref{sec:StoreMerging}

\end_inset 

)
\begin_deeper 
\layout Itemize


\family sans 
\series bold 
wait-sfraddr-sfrdata:
\family default 
\series default 
 neither the address nor the data of a prior store this store inherits some
 of its data from was ready
\layout Itemize


\family sans 
\series bold 
wait-sfraddr:
\family default 
\series default 
 the data of a prior store was ready but its address was still unavailable
\layout Itemize


\family sans 
\series bold 
wait-sfrdata:
\family default 
\series default 
 the address of a prior store was ready but its data was still unavailable
\layout Itemize


\family sans 
\series bold 
wait-storedata-sfraddr-sfrdata:
\family default 
\series default 
 the actual data value to store was not ready (Section 
\begin_inset LatexCommand \ref{sec:SplitPhaseStores}

\end_inset 

), in addition to having neither the data nor the address of a prior store
 (Section 
\begin_inset LatexCommand \ref{sec:StoreMerging}

\end_inset 

)
\layout Itemize


\family sans 
\series bold 
wait-storedata-sfraddr:
\family default 
\series default 
 the actual data value to store was not ready (Section 
\begin_inset LatexCommand \ref{sec:SplitPhaseStores}

\end_inset 

), in addition to not having the address of the prior store (Section 
\begin_inset LatexCommand \ref{sec:StoreMerging}

\end_inset 

)
\layout Itemize


\family sans 
\series bold 
wait-storedata-sfrdata:
\family default 
\series default 
 the actual data value to store was not ready (Section 
\begin_inset LatexCommand \ref{sec:SplitPhaseStores}

\end_inset 

), in addition to not having the data from the prior store (Section 
\begin_inset LatexCommand \ref{sec:StoreMerging}

\end_inset 

)
\end_deeper 
\end_deeper 
\layout Itemize


\family sans 
\series bold 
forward:
\family default 
\series default 
 histogram of which sources were used to construct the merged store buffer:
\begin_deeper 
\layout Itemize


\family sans 
\series bold 
zero:
\family default 
\series default 
 no prior store overlapping the current store was found in the pipeline
\layout Itemize


\family sans 
\series bold 
sfr:
\family default 
\series default 
 data from a prior store in the pipeline was merged with the value to be
 stored to form the final store buffer
\end_deeper 
\layout Itemize


\family sans 
\series bold 
type:
\family default 
\series default 
 histogram of the type of each store uop
\begin_deeper 
\layout Itemize


\family sans 
\series bold 
aligned:
\family default 
\series default 
 normal aligned store
\layout Itemize


\family sans 
\series bold 
unaligned:
\family default 
\series default 
 special unaligned store uops 
\family typewriter 
\size small 
st.lo
\family default 
\size default 
 or 
\family typewriter 
\size small 
st.hi
\family default 
\size default 
 (Section 
\begin_inset LatexCommand \ref{sub:UnalignedLoadsAndStores}

\end_inset 

)
\layout Itemize


\family sans 
\series bold 
internal:
\family default 
\series default 
 stores to PTLsim space by microcode
\end_deeper 
\layout Itemize


\family sans 
\series bold 
size:
\family default 
\series default 
 histogram of the size in bytes of each store uop
\layout Itemize


\family sans 
\series bold 
commit:
\family default 
\series default 
 histogram of how stores are committed
\begin_deeper 
\layout Itemize


\family sans 
\series bold 
direct:
\family default 
\series default 
 store committed directly to the data cache in the commit stage (Section
 
\begin_inset LatexCommand \ref{sec:CommitStage}

\end_inset 

)
\end_deeper 
\layout Standard
\pagebreak_top \noindent \align center 

\series bold 
\emph on 
The End
\the_end
