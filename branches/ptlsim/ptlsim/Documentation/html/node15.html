<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<!--Converted with LaTeX2HTML 2002-2-1 (1.70)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Load Issue</TITLE>
<META NAME="description" CONTENT="Load Issue">
<META NAME="keywords" CONTENT="PTLsimManual">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<META NAME="Generator" CONTENT="LaTeX2HTML v2002-2-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="PTLsimManual.css">

<LINK REL="next" HREF="node16.html">
<LINK REL="previous" HREF="node14.html">
<LINK REL="up" HREF="node9.html">
<LINK REL="next" HREF="node16.html">
</HEAD>

<BODY >
<!--Navigation Panel-->
<A NAME="tex2html545"
  HREF="node16.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html541"
  HREF="node9.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html535"
  HREF="node14.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html543"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html546"
  HREF="node16.html">Stores</A>
<B> Up:</B> <A NAME="tex2html542"
  HREF="node9.html">Out of Order Processor</A>
<B> Previous:</B> <A NAME="tex2html536"
  HREF="node14.html">Speculation and Recovery</A>
 &nbsp; <B>  <A NAME="tex2html544"
  HREF="node1.html">Contents</A></B> 
<BR>
<BR>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL>
<LI><A NAME="tex2html547"
  HREF="node15.html#SECTION04610000000000000000">Issuing Loads</A>
<LI><A NAME="tex2html548"
  HREF="node15.html#SECTION04620000000000000000">Store Queue Check and Store Dependencies</A>
<LI><A NAME="tex2html549"
  HREF="node15.html#SECTION04630000000000000000">Data Extraction</A>
<LI><A NAME="tex2html550"
  HREF="node15.html#SECTION04640000000000000000">Cache Miss Handling</A>
</UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION04600000000000000000">
Load Issue</A>
</H1>

<P>

<H1><A NAME="SECTION04610000000000000000"></A><A NAME="sec:IssuingLoads"></A>
<BR>
Issuing Loads
</H1>

<P>
The <TT><FONT SIZE="-1">ReorderBufferEntry::issueload()</FONT></TT> function is responsible
for issuing all load uops. The <TT><FONT SIZE="-1">issueload()</FONT></TT> method
starts by computing the effective physical address of the value to
load. In the released version of PTLsim, physical and virtual addresses
are the same. If the load is one of the special unaligned fixup forms
(<TT><FONT SIZE="-1">ld.lo</FONT></TT>, <TT><FONT SIZE="-1">ld.hi</FONT></TT>) described in Section
<A HREF="node8.html#sub:UnalignedLoadsAndStores">5.7</A>, the address is re-aligned according
to the type of instruction. At this point, the <TT><FONT SIZE="-1">check_access_and_alignment()</FONT></TT>
function is called to resolve any immediately obvious exceptions such
as page faults or alignment problems (for normal loads).

<P>
If a given load or store accesses an unaligned address but is not
one of the special <TT><FONT SIZE="-1">ld.lo</FONT></TT>/<TT><FONT SIZE="-1">ld.hi</FONT></TT>/<TT><FONT SIZE="-1">st.lo</FONT></TT>/<TT><FONT SIZE="-1">st.hi</FONT></TT>
uops described in Section <A HREF="node8.html#sub:UnalignedLoadsAndStores">5.7</A>, the
processor responds by annulling all uops after and including the problem
load; it then refetches instructions starting at the RIP address of
the load itself. When the load instruction is refetched, it is transformed
into a pair of <TT><FONT SIZE="-1">ld.lo</FONT></TT>/<TT><FONT SIZE="-1">ld.hi</FONT></TT> or <TT><FONT SIZE="-1">st.lo</FONT></TT>/<TT><FONT SIZE="-1">st.hi</FONT></TT>
uops in accordance with Section <A HREF="node8.html#sub:UnalignedLoadsAndStores">5.7</A>.
This refetch approach is required rather than a simple replay operation
since a replay would require allocating two entries in the issue queue
and potentially two ROBs, which is not possible with the PTLsim design
once uops have been renamed.

<P>
Technically, PTLsim splits loads into into low and high fixup uops
by simply retranslating the basic block starting at the problem load's
RIP. In real processors, the frontend pipeline generally has logic
for predicting which loads and stores will be unaligned and will dynamically
split them into aligned parts. Functionally these two approaches are
the same, since in effect PTLsim predicts which loads need to be split
by simply retaining the retranslated basic block with the split loads.

<P>
If a load from the effective address would cause a page fault at this
point, the load is aborted and execution returns to the <TT><FONT SIZE="-1">ReorderBufferEntry::issue()</FONT></TT>
method, causing the result to be marked with an exception (<TT><FONT SIZE="-1">EXCEPTION_PageFaultOnRead</FONT></TT>).

<P>
One x86-specific complication arises at this point. If a load (or
store) uop is the high part (<TT><FONT SIZE="-1">ld.hi</FONT></TT> or <TT><FONT SIZE="-1">st.hi</FONT></TT>)
of an unaligned load or store pair, but the actual user address did
not overlap any of the high 64 bits accessed by the <TT><FONT SIZE="-1">ld.hi</FONT></TT>
or <TT><FONT SIZE="-1">st.hi</FONT></TT> uop, the load should be completely ignored,
even if the high part overlapped onto an invalid page. This is because
it is perfectly legal to do an unaligned load or store at the very
end of a page such that the next 64 bit chunk is not mapped to a valid
page; the x86 architecture mandates that the load or store execute
correctly as far as the user program is concerned.

<P>

<H1><A NAME="SECTION04620000000000000000">
Store Queue Check and Store Dependencies</A>
</H1>

<P>
After doing these exception checks, the load/store queue (LSQ) is
scanned backwards in time from the current load's entry to the LSQ's
head. If a given LSQ entry corresponds to a store, the store's address
has been resolved and the memory range needed by the load overlaps
the memory range touched by the store, the load effectively has a
dependency on the earlier store that must be resolved before the load
can issue. The meaning of ``overlapping memory range'' is defined
more specifically in Section <A HREF="node16.html#sec:StoreMerging">12.1</A>.

<P>
In some cases, the addresses of one or more prior stores that a load
may depend on may not have been resolved by the time the load issues.
Some processors will stall the load uop until <I>all</I> prior store
addresses are known, but this can decrease performance by incorrectly
preventing independent loads from starting as soon as their address
is available. For this reason, the PTLsim processor model aggressively
issues loads as soon as possible unless the load is predicted to frequently
alias another store currently in the pipeline. This load/store aliasing
prediction technique is described in Section <A HREF="node16.html#sub:AliasCheck">12.2.1</A>.

<P>
In either of the cases above, in which an overlapping store is identified
by address but that store's data is not yet available for forwarding
to the load, or where a prior store's address has not been resolved
but is <I>predicted</I> to overlap the load, the load effectively
has a data flow dependency on the earlier store. This dependency is
represented by setting the load's fourth <TT><FONT SIZE="-1">rs</FONT></TT> operand
(<TT><FONT SIZE="-1">operands[RS]</FONT></TT> in the <TT><FONT SIZE="-1">ReorderBufferEntry</FONT></TT>)
to the store the load is waiting on. After adding this dependency,
the <TT><FONT SIZE="-1">replay()</FONT></TT> method is used to force the load back
to the dispatched state, where it waits until the prior store is resolved.
After the load is re-issued for a second time, the store queue is
scanned again to make sure no intervening stores arrived in the meantime.
If a different match is found this time, the load is replayed a third
time. In practice, loads are rarely replayed more than once.

<P>

<H1><A NAME="SECTION04630000000000000000">
Data Extraction</A>
</H1>

<P>
Once the prior store a load depends on (if any) is ready and all the
exception checks above have passed, it is time to actually obtain
the load's data. This process can be complicated since some bytes
in the region accessed by the load could come from the data cache
while other bytes may be forwarded from a prior store. If one or more
bytes need to be obtained from the data cache, the L1 cache is probed
(via the <TT><FONT SIZE="-1">probe_cache_and_sfr()</FONT></TT> function) to see
if the required line is present. If so, and the combination of the
forwarded store (if any) and the L1 line fills in all bytes required
by the load, the final data can be extracted.

<P>
To extract the data, the load unit creates a 64-bit temporary buffer
by overlaying the bytes touched by the prior store (if any) on top
of the bytes obtained from the cache. The correct word is then extracted
and sign extended (if required) from this buffer to form the result
of the load. Unaligned loads (described in Section <A HREF="node8.html#sub:UnalignedLoadsAndStores">5.7</A>)
are somewhat more complex in that both the low and high 64 bit chunks
from the <TT><FONT SIZE="-1">ld.lo</FONT></TT> and <TT><FONT SIZE="-1">ld.hi</FONT></TT> uops, respectively,
are placed into a 128-bit buffer from which the final result is extracted.

<P>
<B><I>NOTE:</I></B> For simulation purposes only, the data to load
is immediately accessed and recorded by <TT><FONT SIZE="-1">issueload()</FONT></TT>
regardless of whether or not there is a cache miss. This makes the
loaded data significantly easier to track. In a real processor, the
data extraction process obviously only happens after the missing line
actually arrives, however our implementation in no way affects performance.

<P>

<H1><A NAME="SECTION04640000000000000000"></A><A NAME="sec:CacheMissHandling"></A>
<BR>
Cache Miss Handling
</H1>

<P>
If no combination of the prior store's forwarded bytes and data present
in the L1 cache can fulfill a load, this is miss and lower cache levels
must be accessed. This process is described in Sections <A HREF="node19.html#sec:InitiatingCacheMiss">15.2</A>
and <A HREF="node19.html#sec:FillingCacheMiss">15.3</A>. As far as the core is concerned,
the load is completed at this point even if the data has not yet arrived.
The issue queue entry for the load can be released since the load
is now officially in progress and cannot be replayed. Once the loaded
data has arrived, the cache subsystem calls the <TT><FONT SIZE="-1">ReorderBuffer::loadwakeup()</FONT></TT>,
which marks both the physical register and LSQ entry of the load as
ready, and places the load's ROB into the <I>completed</I> state.
This allows the processor to wake up dependents of the load on the
next cycle.

<P>
<HR>
<!--Navigation Panel-->
<A NAME="tex2html545"
  HREF="node16.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html541"
  HREF="node9.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html535"
  HREF="node14.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html543"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html546"
  HREF="node16.html">Stores</A>
<B> Up:</B> <A NAME="tex2html542"
  HREF="node9.html">Out of Order Processor</A>
<B> Previous:</B> <A NAME="tex2html536"
  HREF="node14.html">Speculation and Recovery</A>
 &nbsp; <B>  <A NAME="tex2html544"
  HREF="node1.html">Contents</A></B> 
<!--End of Navigation Panel-->
<ADDRESS>
Matt T Yourst
2005-10-03
</ADDRESS>
</BODY>
</HTML>
